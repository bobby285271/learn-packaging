From dcc264b59c1d7d45e53803710505fd692819c7dd Mon Sep 17 00:00:00 2001
From: liushuyu <liushuyu011@gmail.com>
Date: Fri, 17 Apr 2020 20:17:52 -0600
Subject: [PATCH] revive XAA renderer

---
 configure.ac                       |    5 +
 hw/xfree86/Makefile.am             |    6 +-
 hw/xfree86/common/Makefile.am      |    6 +-
 hw/xfree86/doc/README.modes        |    9 +-
 hw/xfree86/doc/ddxDesign.xml       |   50 +-
 hw/xfree86/doc/exa-driver.txt      |    9 +-
 hw/xfree86/ramdac/Makefile.am      |   12 +-
 hw/xfree86/ramdac/xf86CursorPriv.h |    2 +
 hw/xfree86/ramdac/xf86HWCurs.c     |    9 -
 hw/xfree86/sdksyms.sh              |    7 +
 hw/xfree86/xaa/.gitignore          |    4 +
 hw/xfree86/xaa/Makefile.am         |   79 +
 hw/xfree86/xaa/XAA.HOWTO           | 1427 ++++++++++++++++
 hw/xfree86/xaa/xaa.h               | 1038 ++++++++++++
 hw/xfree86/xaa/xaaBitBlt.c         |  230 +++
 hw/xfree86/xaa/xaaBitOrder.c       |   16 +
 hw/xfree86/xaa/xaaBitmap.c         |  477 ++++++
 hw/xfree86/xaa/xaaCpyArea.c        |  409 +++++
 hw/xfree86/xaa/xaaCpyPlane.c       |  204 +++
 hw/xfree86/xaa/xaaCpyWin.c         |   78 +
 hw/xfree86/xaa/xaaDashLine.c       |  353 ++++
 hw/xfree86/xaa/xaaFallback.c       |  281 ++++
 hw/xfree86/xaa/xaaFillArc.c        |  202 +++
 hw/xfree86/xaa/xaaFillPoly.c       |  991 +++++++++++
 hw/xfree86/xaa/xaaFillRect.c       | 1101 ++++++++++++
 hw/xfree86/xaa/xaaGC.c             |  564 +++++++
 hw/xfree86/xaa/xaaGCmisc.c         |  412 +++++
 hw/xfree86/xaa/xaaImage.c          |  534 ++++++
 hw/xfree86/xaa/xaaInit.c           |  635 +++++++
 hw/xfree86/xaa/xaaInitAccel.c      | 1571 +++++++++++++++++
 hw/xfree86/xaa/xaaLine.c           |  422 +++++
 hw/xfree86/xaa/xaaLineMisc.c       |  149 ++
 hw/xfree86/xaa/xaaNonTEGlyph.c     |  192 +++
 hw/xfree86/xaa/xaaNonTEText.c      |  591 +++++++
 hw/xfree86/xaa/xaaOffscreen.c      |  163 ++
 hw/xfree86/xaa/xaaOverlay.c        |  122 ++
 hw/xfree86/xaa/xaaOverlayDF.c      |  906 ++++++++++
 hw/xfree86/xaa/xaaPCache.c         | 2527 ++++++++++++++++++++++++++++
 hw/xfree86/xaa/xaaPict.c           |  654 +++++++
 hw/xfree86/xaa/xaaROP.c            |  182 ++
 hw/xfree86/xaa/xaaRect.c           |  121 ++
 hw/xfree86/xaa/xaaSpans.c          |  876 ++++++++++
 hw/xfree86/xaa/xaaStateChange.c    | 1665 ++++++++++++++++++
 hw/xfree86/xaa/xaaStipple.c        |  915 ++++++++++
 hw/xfree86/xaa/xaaTEGlyph.c        | 1083 ++++++++++++
 hw/xfree86/xaa/xaaTEText.c         |  295 ++++
 hw/xfree86/xaa/xaaTables.c         |  152 ++
 hw/xfree86/xaa/xaaWideLine.c       |  924 ++++++++++
 hw/xfree86/xaa/xaacexp.h           |  126 ++
 hw/xfree86/xaa/xaalocal.h          | 1437 ++++++++++++++++
 hw/xfree86/xaa/xaarop.h            |  268 +++
 hw/xfree86/xaa/xaawrap.h           |   75 +
 include/gcstruct.h                 |    5 +-
 mi/Makefile.am                     |    2 +
 mi/mi.h                            |    1 +
 mi/mifillarc.c                     |    4 +-
 mi/mifillarc.h                     |   10 +
 mi/mispans.c                       |  530 ++++++
 mi/mispans.h                       |   87 +
 mi/miwideline.c                    |    8 +-
 mi/miwideline.h                    |   26 +
 mi/miwindow.c                      |   14 +
 miext/Makefile.am                  |    3 +
 miext/cw/Makefile.am               |   11 +
 miext/cw/cw.c                      |  524 ++++++
 miext/cw/cw.h                      |  173 ++
 miext/cw/cw_ops.c                  |  477 ++++++
 miext/cw/cw_render.c               |  383 +++++
 render/picture.c                   |   70 +
 render/picturestr.h                |    3 +
 70 files changed, 26861 insertions(+), 36 deletions(-)
 create mode 100644 hw/xfree86/xaa/.gitignore
 create mode 100644 hw/xfree86/xaa/Makefile.am
 create mode 100644 hw/xfree86/xaa/XAA.HOWTO
 create mode 100644 hw/xfree86/xaa/xaa.h
 create mode 100644 hw/xfree86/xaa/xaaBitBlt.c
 create mode 100644 hw/xfree86/xaa/xaaBitOrder.c
 create mode 100644 hw/xfree86/xaa/xaaBitmap.c
 create mode 100644 hw/xfree86/xaa/xaaCpyArea.c
 create mode 100644 hw/xfree86/xaa/xaaCpyPlane.c
 create mode 100644 hw/xfree86/xaa/xaaCpyWin.c
 create mode 100644 hw/xfree86/xaa/xaaDashLine.c
 create mode 100644 hw/xfree86/xaa/xaaFallback.c
 create mode 100644 hw/xfree86/xaa/xaaFillArc.c
 create mode 100644 hw/xfree86/xaa/xaaFillPoly.c
 create mode 100644 hw/xfree86/xaa/xaaFillRect.c
 create mode 100644 hw/xfree86/xaa/xaaGC.c
 create mode 100644 hw/xfree86/xaa/xaaGCmisc.c
 create mode 100644 hw/xfree86/xaa/xaaImage.c
 create mode 100644 hw/xfree86/xaa/xaaInit.c
 create mode 100644 hw/xfree86/xaa/xaaInitAccel.c
 create mode 100644 hw/xfree86/xaa/xaaLine.c
 create mode 100644 hw/xfree86/xaa/xaaLineMisc.c
 create mode 100644 hw/xfree86/xaa/xaaNonTEGlyph.c
 create mode 100644 hw/xfree86/xaa/xaaNonTEText.c
 create mode 100644 hw/xfree86/xaa/xaaOffscreen.c
 create mode 100644 hw/xfree86/xaa/xaaOverlay.c
 create mode 100644 hw/xfree86/xaa/xaaOverlayDF.c
 create mode 100644 hw/xfree86/xaa/xaaPCache.c
 create mode 100644 hw/xfree86/xaa/xaaPict.c
 create mode 100644 hw/xfree86/xaa/xaaROP.c
 create mode 100644 hw/xfree86/xaa/xaaRect.c
 create mode 100644 hw/xfree86/xaa/xaaSpans.c
 create mode 100644 hw/xfree86/xaa/xaaStateChange.c
 create mode 100644 hw/xfree86/xaa/xaaStipple.c
 create mode 100644 hw/xfree86/xaa/xaaTEGlyph.c
 create mode 100644 hw/xfree86/xaa/xaaTEText.c
 create mode 100644 hw/xfree86/xaa/xaaTables.c
 create mode 100644 hw/xfree86/xaa/xaaWideLine.c
 create mode 100644 hw/xfree86/xaa/xaacexp.h
 create mode 100644 hw/xfree86/xaa/xaalocal.h
 create mode 100644 hw/xfree86/xaa/xaarop.h
 create mode 100644 hw/xfree86/xaa/xaawrap.h
 create mode 100644 mi/mispans.c
 create mode 100644 mi/mispans.h
 create mode 100644 miext/cw/Makefile.am
 create mode 100644 miext/cw/cw.c
 create mode 100644 miext/cw/cw.h
 create mode 100644 miext/cw/cw_ops.c
 create mode 100644 miext/cw/cw_render.c

diff --git a/configure.ac b/configure.ac
index a58954f89..187ca0573 100644
--- a/configure.ac
+++ b/configure.ac
@@ -570,6 +570,7 @@ AC_ARG_ENABLE(config-udev-kms,    AS_HELP_STRING([--enable-config-udev-kms], [Bu
 AC_ARG_ENABLE(config-hal,     AS_HELP_STRING([--disable-config-hal], [Build HAL support (default: auto)]), [CONFIG_HAL=$enableval], [CONFIG_HAL=auto])
 AC_ARG_ENABLE(config-wscons,  AS_HELP_STRING([--enable-config-wscons], [Build wscons config support (default: auto)]), [CONFIG_WSCONS=$enableval], [CONFIG_WSCONS=auto])
 AC_ARG_ENABLE(xfree86-utils,     AS_HELP_STRING([--enable-xfree86-utils], [Build xfree86 DDX utilities (default: enabled)]), [XF86UTILS=$enableval], [XF86UTILS=yes])
+AC_ARG_ENABLE(xaa,               AS_HELP_STRING([--enable-xaa], [Build XAA (default: enabled)]), [XAA=$enableval], [XAA=yes])
 AC_ARG_ENABLE(vgahw,          AS_HELP_STRING([--enable-vgahw], [Build Xorg with vga access (default: enabled)]), [VGAHW=$enableval], [VGAHW=yes])
 AC_ARG_ENABLE(vbe,            AS_HELP_STRING([--enable-vbe], [Build Xorg with VBE module (default: enabled)]), [VBE=$enableval], [VBE=yes])
 AC_ARG_ENABLE(int10-module,     AS_HELP_STRING([--enable-int10-module], [Build Xorg with int10 module (default: enabled)]), [INT10MODULE=$enableval], [INT10MODULE=yes])
@@ -664,6 +665,7 @@ case $host_os in
 		PCI=no
 		VGAHW=no
 		VBE=no
+		XAA=no
 		XF86UTILS=no
 		XF86VIDMODE=no
 		XSELINUX=no
@@ -1345,6 +1347,7 @@ XI_LIB='$(top_builddir)/Xi/libXi.la'
 XI_INC='-I$(top_srcdir)/Xi'
 
 AM_CONDITIONAL(XF86UTILS, test "x$XF86UTILS" = xyes)
+AM_CONDITIONAL(XAA, test "x$XAA" = xyes)
 AM_CONDITIONAL(VGAHW, test "x$VGAHW" = xyes)
 AM_CONDITIONAL(VBE, test "x$VBE" = xyes)
 AM_CONDITIONAL(INT10MODULE, test "x$INT10MODULE" = xyes)
@@ -2449,6 +2452,7 @@ record/Makefile
 config/Makefile
 mi/Makefile
 miext/Makefile
+miext/cw/Makefile
 miext/sync/Makefile
 miext/damage/Makefile
 miext/shadow/Makefile
@@ -2501,6 +2505,7 @@ hw/xfree86/shadowfb/Makefile
 hw/xfree86/vbe/Makefile
 hw/xfree86/vgahw/Makefile
 hw/xfree86/x86emu/Makefile
+hw/xfree86/xaa/Makefile
 hw/xfree86/xkb/Makefile
 hw/xfree86/utils/Makefile
 hw/xfree86/utils/man/Makefile
diff --git a/hw/xfree86/Makefile.am b/hw/xfree86/Makefile.am
index 9aeaea1a6..86de9f816 100644
--- a/hw/xfree86/Makefile.am
+++ b/hw/xfree86/Makefile.am
@@ -26,6 +26,8 @@ if XF86UTILS
 XF86UTILS_SUBDIR = utils
 endif
 
+XAA_SUBDIR = xaa
+
 if VGAHW
 VGAHW_SUBDIR = vgahw
 endif
@@ -40,12 +42,12 @@ endif
 
 SUBDIRS = common ddc x86emu $(INT10_SUBDIR) os-support parser \
 	  ramdac $(VGAHW_SUBDIR) loader modes $(DRI_SUBDIR) \
-	  $(DRI2_SUBDIR) . $(VBE_SUBDIR) i2c dixmods xkb \
+	  $(DRI2_SUBDIR) . $(VBE_SUBDIR) $(XAA_SUBDIR) i2c dixmods xkb \
 	  fbdevhw shadowfb exa $(XF86UTILS_SUBDIR) doc man \
 	  $(GLAMOR_EGL_SUBDIR) drivers
 
 DIST_SUBDIRS = common ddc i2c x86emu int10 fbdevhw os-support \
-               parser ramdac shadowfb vbe vgahw \
+               parser ramdac shadowfb vbe vgahw xaa \
                loader dixmods xkb dri dri2 exa modes \
 	       utils doc man glamor_egl drivers
 
diff --git a/hw/xfree86/common/Makefile.am b/hw/xfree86/common/Makefile.am
index 41758fd2e..ce430b34f 100644
--- a/hw/xfree86/common/Makefile.am
+++ b/hw/xfree86/common/Makefile.am
@@ -59,8 +59,7 @@ sdk_HEADERS = compiler.h fourcc.h xf86.h xf86Module.h xf86Opt.h \
               xf86cmap.h xf86fbman.h xf86str.h xf86Xinput.h xisb.h \
               $(XVSDKINCS) $(XF86VMODE_SDK) $(DGA_SDK) xorgVersion.h \
               xf86sbusBus.h xf86VGAarbiter.h xf86Optionstr.h \
-	      xf86platformBus.h xf86MatchDrivers.h \
-	      xaarop.h
+	      xf86platformBus.h xf86MatchDrivers.h
 
 DISTCLEANFILES = xf86Build.h
 CLEANFILES = $(BUILT_SOURCES)
@@ -91,8 +90,7 @@ EXTRA_DIST = \
 	modeline2c.awk \
 	xf86VGAarbiter.h \
 	xf86VGAarbiterPriv.h \
-        $(DISTKBDSOURCES) \
-	xaarop.h
+        $(DISTKBDSOURCES)
 
 if LNXACPI
 XORG_CFLAGS += -DHAVE_ACPI
diff --git a/hw/xfree86/doc/README.modes b/hw/xfree86/doc/README.modes
index ea228e592..894e21313 100644
--- a/hw/xfree86/doc/README.modes
+++ b/hw/xfree86/doc/README.modes
@@ -133,10 +133,11 @@ this function computes an initial configuration for the server. It tries to
 enable as much hardware as possible using some fairly simple heuristics. 
 
 The 'canGrow' parameter indicates that the frame buffer does not have a fixed
-size. When the frame buffer has a fixed size, the configuration selects a
-'reasonablely large' frame buffer so that common reconfiguration options are
-possible. For resizable frame buffers, the frame buffer is set to the smallest
-size that encloses the desired configuration.
+size (fixed size frame buffers are required by XAA). When the frame buffer
+has a fixed size, the configuration selects a 'reasonablely large' frame
+buffer so that common reconfiguration options are possible. For resizable
+frame buffers, the frame buffer is set to the smallest size that encloses
+the desired configuration.
     
 3.2 ScreenInit functions
 
diff --git a/hw/xfree86/doc/ddxDesign.xml b/hw/xfree86/doc/ddxDesign.xml
index 367844136..32abb616c 100644
--- a/hw/xfree86/doc/ddxDesign.xml
+++ b/hw/xfree86/doc/ddxDesign.xml
@@ -331,8 +331,8 @@ that.  This is a significant difference compared with the old design.
 
     <para>
 The entry points for drawing operations are already taken care of by
-the framebuffer code.  Extensions and enhancements to framebuffer code
-are outside the scope of this document.
+the framebuffer code (including, XAA).  Extensions and enhancements to
+framebuffer code are outside the scope of this document.
     </para>
 
     <para>
@@ -1981,9 +1981,10 @@ also include the video card's saved state.
       </para>
 
       <para>
-Per-screen data for other modules that the driver uses that is reset for each
-server generation is hooked into the <structname>ScrnInfoRec</structname>
-through its <structfield>privates</structfield> field.
+Per-screen data for other modules that the driver uses (for example,
+the XAA module) that is reset for each server generation is hooked into
+the <structname>ScrnInfoRec</structname> through it's <structfield>privates</structfield>
+field.
       </para>
 
       <para>
@@ -3256,6 +3257,14 @@ The following include files are typically required by video drivers:
 	      </filename></literallayout>
 	  </para>
 
+	  <para>
+  If a driver uses XAA, it needs these:
+	    <literallayout><filename>
+    "xaa.h"
+    "xaalocal.h"
+	      </filename></literallayout>
+	  </para>
+
 	  <para>
   If a driver uses the fb manager, it needs this:
 	    <literallayout><filename>
@@ -3474,6 +3483,31 @@ manager is allowed to manage.  This is typically a box with a width of
 can be fit within the total video memory, however, the driver can reserve
 areas at the extremities by passing a smaller area to the manager.
     </para>
+
+    <para>
+<function>xf86InitFBManager()</function> must be called before XAA is
+initialized since XAA uses the manager for it's pixmap cache.
+    </para>
+
+    <para>
+An alternative function is provided to allow the driver to initialize
+the framebuffer manager with a Region rather than a box.
+
+    <programlisting>
+    Bool xf86InitFBManagerRegion(ScreenPtr pScreen,
+                                 RegionPtr FullRegion);
+    </programlisting>
+
+<function>xf86InitFBManagerRegion()</function>, unlike
+<function>xf86InitFBManager()</function>, does not remove the area used for
+the visible screen so that area should not be included in the region
+passed to the function.  <function>xf86InitFBManagerRegion()</function> is
+useful when non-contiguous areas are available to be managed, and is
+required when multiple framebuffers are stored in video memory (as in
+the case where an overlay of a different depth is stored as a second
+framebuffer in offscreen memory).
+    </para>
+
   </sect1>
 
   <sect1 id="cmap">
@@ -8289,6 +8323,12 @@ ZZZPreInit(ScrnInfoPtr pScrn, int flags)
         ZZZFreeRec(pScrn);
         return FALSE;
 
+    /* Load XAA if needed */
+    if (!pZzz-&gt;noAccel || pZzz-&gt;hwCursor)
+        if (!xf86LoadSubModule(pScrn, "xaa")) {
+            ZZZFreeRec(pScrn);
+            return FALSE;
+        }
 
     /* Done */
     return TRUE;
diff --git a/hw/xfree86/doc/exa-driver.txt b/hw/xfree86/doc/exa-driver.txt
index da39d3f91..048307ee7 100644
--- a/hw/xfree86/doc/exa-driver.txt
+++ b/hw/xfree86/doc/exa-driver.txt
@@ -8,10 +8,15 @@ from system memory, and Porter-Duff compositing and transform operations.
 
 Configuration
 -------------
+A new config file option, AccelMethod, should be added to your driver, to allow
+the user to select between the EXA and XAA acceleration APIs.
+
 Some drivers implement a per-instance useEXA flag to track whether EXA is
-active or not.
+active or not.  It can be helpful to also conditionalize XAA support with an
+ifdef so that it can easily be turned off/removed in the future.
 
-Setting the flag can be done in the driver's Options parsing routine.
+Setting the flag and checking for AccelMethod can be done in the driver's
+Options parsing routine.
 
 Loading EXA
 ------------
diff --git a/hw/xfree86/ramdac/Makefile.am b/hw/xfree86/ramdac/Makefile.am
index 59e0996ad..f6c7fd60e 100644
--- a/hw/xfree86/ramdac/Makefile.am
+++ b/hw/xfree86/ramdac/Makefile.am
@@ -1,12 +1,20 @@
 noinst_LTLIBRARIES = libramdac.la
 
 libramdac_la_SOURCES = xf86RamDac.c xf86RamDacCmap.c \
-                       xf86CursorRD.c xf86HWCurs.c IBM.c BT.c TI.c
+                       xf86CursorRD.c xf86HWCurs.c IBM.c BT.c TI.c \
+                       xf86BitOrder.c
 
 sdk_HEADERS = BT.h IBM.h TI.h xf86Cursor.h xf86RamDac.h
 
+DISTCLEANFILES = xf86BitOrder.c
 EXTRA_DIST = BTPriv.h IBMPriv.h TIPriv.h xf86CursorPriv.h xf86RamDacPriv.h \
 	CURSOR.NOTES
 
-AM_CFLAGS = $(DIX_CFLAGS) $(XORG_CFLAGS)
+AM_CFLAGS = -DXAAReverseBitOrder=xf86ReverseBitOrder -DRAMDAC_MODULE \
+            $(DIX_CFLAGS) $(XORG_CFLAGS)
+INCLUDES = $(XORG_INCS)
+
+xf86BitOrder.c:
+	$(AM_V_GEN)echo "#define XAAReverseBitOrder xf86ReverseBitOrder" > $@
+	$(AM_V_GEN)echo "#include \"$(srcdir)/../xaa/xaaBitOrder.c\"" >> $@
 AM_CPPFLAGS = $(XORG_INCS)
diff --git a/hw/xfree86/ramdac/xf86CursorPriv.h b/hw/xfree86/ramdac/xf86CursorPriv.h
index 397d2a14b..568583c22 100644
--- a/hw/xfree86/ramdac/xf86CursorPriv.h
+++ b/hw/xfree86/ramdac/xf86CursorPriv.h
@@ -43,6 +43,8 @@ void xf86MoveCursor(ScreenPtr pScreen, int x, int y);
 void xf86RecolorCursor(ScreenPtr pScreen, CursorPtr pCurs, Bool displayed);
 Bool xf86InitHardwareCursor(ScreenPtr pScreen, xf86CursorInfoPtr infoPtr);
 
+CARD32 xf86ReverseBitOrder(CARD32 data);
+
 Bool xf86CheckHWCursor(ScreenPtr pScreen, CursorPtr cursor, xf86CursorInfoPtr infoPtr);
 extern _X_EXPORT DevPrivateKeyRec xf86CursorScreenKeyRec;
 
diff --git a/hw/xfree86/ramdac/xf86HWCurs.c b/hw/xfree86/ramdac/xf86HWCurs.c
index 366837c01..1b601c504 100644
--- a/hw/xfree86/ramdac/xf86HWCurs.c
+++ b/hw/xfree86/ramdac/xf86HWCurs.c
@@ -25,15 +25,6 @@
 static void
 xf86RecolorCursor_locked(xf86CursorScreenPtr ScreenPriv, CursorPtr pCurs);
 
-static CARD32
-xf86ReverseBitOrder(CARD32 v)
-{
-    return (((0x01010101 & v) << 7) | ((0x02020202 & v) << 5) |
-            ((0x04040404 & v) << 3) | ((0x08080808 & v) << 1) |
-            ((0x10101010 & v) >> 1) | ((0x20202020 & v) >> 3) |
-            ((0x40404040 & v) >> 5) | ((0x80808080 & v) >> 7));
-}
-
 #if BITMAP_SCANLINE_PAD == 64
 
 #if 1
diff --git a/hw/xfree86/sdksyms.sh b/hw/xfree86/sdksyms.sh
index 7897aae22..72d53fd1c 100755
--- a/hw/xfree86/sdksyms.sh
+++ b/hw/xfree86/sdksyms.sh
@@ -199,6 +199,13 @@ cat > sdksyms.c << EOF
 # include "dristruct.h"
 #endif
 
+/* hw/xfree86/xaa/Makefile.am -- module */
+/*
+#include "xaa.h"
+#include "xaalocal.h"
+#include "xaarop.h"
+ */
+
 
 /* mi/Makefile.am */
 #include "micmap.h"
diff --git a/hw/xfree86/xaa/.gitignore b/hw/xfree86/xaa/.gitignore
new file mode 100644
index 000000000..1211d01e1
--- /dev/null
+++ b/hw/xfree86/xaa/.gitignore
@@ -0,0 +1,4 @@
+#		Add & Override for this directory and it's subdirectories
+[lms]-xaa*.c
+[lm]f3-xaa*.c
+[lm][f3]-xaa*.c
diff --git a/hw/xfree86/xaa/Makefile.am b/hw/xfree86/xaa/Makefile.am
new file mode 100644
index 000000000..5614d723a
--- /dev/null
+++ b/hw/xfree86/xaa/Makefile.am
@@ -0,0 +1,79 @@
+LSB_FIRST = l-xaaBitmap.c l-xaaStipple.c l-xaaTEGlyph.c
+LSB_3_FIRST = l3-xaaBitmap.c l3-xaaStipple.c
+MSB_FIRST = m-xaaBitmap.c m-xaaStipple.c m-xaaTEGlyph.c
+MSB_3_FIRST = m3-xaaBitmap.c m3-xaaStipple.c
+LSB_FIXED = lf-xaaBitmap.c lf-xaaStipple.c lf-xaaTEGlyph.c
+LSB_3_FIXED = lf3-xaaBitmap.c lf3-xaaStipple.c
+MSB_FIXED = mf-xaaBitmap.c mf-xaaStipple.c mf-xaaTEGlyph.c
+MSB_3_FIXED = mf3-xaaBitmap.c mf3-xaaStipple.c
+POLYSEG = s-xaaLine.c s-xaaDashLine.c
+
+if XAA
+
+libxaa_la_LDFLAGS = -module -avoid-version $(LD_NO_UNDEFINED_FLAG)
+libxaa_la_LIBADD = $(PIXMAN_LIBS)
+if COMPOSITE
+libxaa_la_LIBADD += $(top_builddir)/miext/cw/libcw.la
+endif
+
+module_LTLIBRARIES = libxaa.la
+libxaa_la_SOURCES = xaaInit.c xaaGC.c xaaInitAccel.c xaaFallback.c \
+                   xaaBitBlt.c xaaCpyArea.c xaaGCmisc.c xaaCpyWin.c \
+                   xaaCpyPlane.c xaaFillRect.c xaaTEText.c xaaNonTEText.c \
+                   xaaPCache.c xaaSpans.c xaaROP.c xaaImage.c \
+                   xaaRect.c xaaLineMisc.c xaaBitOrder.c \
+                   xaaFillPoly.c xaaWideLine.c xaaTables.c xaaFillArc.c \
+                   xaaLine.c xaaDashLine.c xaaOverlay.c xaaOffscreen.c \
+                   xaaOverlayDF.c xaaStateChange.c xaaPict.c $(POLYSEG) \
+                   $(LSB_FIRST) $(MSB_FIRST) $(LSB_FIXED) $(MSB_FIXED) \
+                   $(LSB_3_FIRST) $(MSB_3_FIRST) $(LSB_3_FIXED) $(MSB_3_FIXED)
+${POLYSEG}:
+	$(AM_V_GEN)echo "#define POLYSEGMENT" > $@
+	$(AM_V_GEN)echo '#include "$(srcdir)/${@:s-%=%}"' >> $@
+${LSB_FIRST}:
+	$(AM_V_GEN)echo "#define LSBFIRST" > $@
+	$(AM_V_GEN)echo '#include "$(srcdir)/${@:l-%=%}"' >> $@
+${LSB_3_FIRST}:
+	$(AM_V_GEN)echo "#define LSBFIRST" > $@
+	$(AM_V_GEN)echo "#define TRIPLE_BITS" >> $@
+	$(AM_V_GEN)echo '#include "$(srcdir)/${@:l3-%=%}"' >> $@
+${LSB_FIXED}:
+	$(AM_V_GEN)echo "#define LSBFIRST" > $@
+	$(AM_V_GEN)echo "#define FIXEDBASE" >> $@
+	$(AM_V_GEN)echo '#include "$(srcdir)/${@:lf-%=%}"' >> $@
+${LSB_3_FIXED}:
+	$(AM_V_GEN)echo "#define LSBFIRST" > $@
+	$(AM_V_GEN)echo "#define TRIPLE_BITS" >> $@
+	$(AM_V_GEN)echo "#define FIXEDBASE" >> $@
+	$(AM_V_GEN)echo '#include "$(srcdir)/${@:lf3-%=%}"' >> $@
+${MSB_FIRST}:
+	$(AM_V_GEN)echo "#define MSBFIRST" > $@
+	$(AM_V_GEN)echo '#include "$(srcdir)/${@:m-%=%}"' >> $@
+${MSB_3_FIRST}:
+	$(AM_V_GEN)echo "#define MSBFIRST" > $@
+	$(AM_V_GEN)echo "#define TRIPLE_BITS" >> $@
+	$(AM_V_GEN)echo '#include "$(srcdir)/${@:m3-%=%}"' >> $@
+${MSB_FIXED}:
+	$(AM_V_GEN)echo "#define MSBFIRST" > $@
+	$(AM_V_GEN)echo "#define FIXEDBASE" >> $@
+	$(AM_V_GEN)echo '#include "$(srcdir)/${@:mf-%=%}"' >> $@
+${MSB_3_FIXED}:
+	$(AM_V_GEN)echo "#define MSBFIRST" > $@
+	$(AM_V_GEN)echo "#define TRIPLE_BITS" >> $@
+	$(AM_V_GEN)echo "#define FIXEDBASE" >> $@
+	$(AM_V_GEN)echo '#include "$(srcdir)/${@:mf3-%=%}"' >> $@
+
+endif # XAA
+
+DISTCLEANFILES = $(POLYSEG) \
+	$(LSB_FIRST) $(LSB_FIXED) $(MSB_FIRST) $(MSB_FIXED) \
+	$(LSB_3_FIRST) $(LSB_3_FIXED) $(MSB_3_FIRST) $(MSB_3_FIXED)
+
+sdk_HEADERS = xaa.h xaalocal.h xaarop.h
+EXTRA_DIST = xaacexp.h xaawrap.h xaaLine.c xaaDashLine.c \
+             xaaStipple.c xaaTEGlyph.c xaaNonTEGlyph.c xaaBitmap.c \
+             XAA.HOWTO
+
+INCLUDES = $(XORG_INCS) -I$(srcdir)/../../../miext/cw
+
+AM_CFLAGS = $(DIX_CFLAGS) $(XORG_CFLAGS)
diff --git a/hw/xfree86/xaa/XAA.HOWTO b/hw/xfree86/xaa/XAA.HOWTO
new file mode 100644
index 000000000..cbd71c138
--- /dev/null
+++ b/hw/xfree86/xaa/XAA.HOWTO
@@ -0,0 +1,1427 @@
+
+
+                          XAA.HOWTO
+
+  This file describes how to add basic XAA support to a chipset driver.
+
+0)  What is XAA
+1)  XAA Initialization and Shutdown
+2)  The Primitives
+  2.0  Generic Flags
+  2.1  Screen to Screen Copies
+  2.2  Solid Fills
+  2.3  Solid Lines
+  2.4  Dashed Lines
+  2.5  Color Expand Fills
+    2.5.1 Screen to Screen Color Expansion
+    2.5.2 CPU to Screen Color Expansion
+      2.5.2.1 The Direct Method
+      2.5.2.2 The Indirect Method
+  2.6  8x8 Mono Pattern Fills
+  2.7  8x8 Color Pattern Fills
+  2.8  Image Writes
+    2.8.1 The Direct Method
+    2.8.2 The Indirect Method
+  2.9 Clipping
+3)  The Pixmap Cache
+4)  Offscreen Pixmaps
+
+/********************************************************************/
+
+0) WHAT IS XAA
+	
+   XAA (the XFree86 Acceleration Architecture) is a device dependent
+layer that encapsulates the unaccelerated framebuffer rendering layer,
+intercepting rendering commands sent to it from higher levels of the
+server.  For rendering tasks where hardware acceleration is not 
+possible, XAA allows the requests to proceed to the software rendering
+code.  Otherwise, XAA breaks the sometimes complicated X primitives
+into simpler primitives more suitable for hardware acceleration and
+will use accelerated functions exported by the chipset driver to 
+render these.
+
+   XAA provides a simple, easy to use driver interface that allows
+the driver to communicate its acceleration capabilities and restrictions
+back to XAA.  XAA will use the information provided by the driver
+to determine whether or not acceleration will be possible for a
+particular X primitive.
+
+
+
+1) XAA INITIALIZATION AND SHUTDOWN
+
+   All relevant prototypes and defines are in xaa.h.
+
+   To Initialize the XAA layer, the driver should allocate an XAAInfoRec
+via XAACreateInfoRec(), fill it out as described in this document
+and pass it to XAAInit().  XAAInit() must be called _after_ the 
+framebuffer initialization (usually cfb?ScreenInit or similar) since 
+it is "wrapping" that layer.  XAAInit() should be called _before_ the 
+cursor initialization (usually miDCInitialize) since the cursor
+layer needs to "wrap" all the rendering code including XAA.
+
+   When shutting down, the driver should free the XAAInfoRec
+structure in its CloseScreen function via XAADestroyInfoRec().
+The prototypes for the functions mentioned above are as follows:
+
+   XAAInfoRecPtr XAACreateInfoRec(void);
+   Bool XAAInit(ScreenPtr, XAAInfoRecPtr);
+   void XAADestroyInfoRec(XAAInfoRec);
+
+   The driver informs XAA of it's acceleration capablities by
+filling out an XAAInfoRec structure and passing it to XAAInit().
+The XAAInfoRec structure contains many fields, most of which are
+function pointers and flags.  Each primitive will typically have
+two functions and a set of flags associated with it, but it may
+have more.  These two functions are the "SetupFor" and "Subsequent" 
+functions.  The "SetupFor" function tells the driver that the 
+hardware should be initialized for a particular type of graphics 
+operation.  After the "SetupFor" function, one or more calls to the 
+"Subsequent" function will be made to indicate that an instance
+of the particular primitive should be rendered by the hardware.
+The details of each instance (width, height, etc...) are given
+with each "Subsequent" function.   The set of flags associated
+with each primitive lets the driver tell XAA what its hardware
+limitations are (eg. It doesn't support a planemask, it can only
+do one of the raster-ops, etc...).
+
+  Of the XAAInfoRec fields, one is required.  This is the
+Sync function.  XAA initialization will fail if this function
+is not provided.
+
+void Sync(ScrnInfoPtr pScrn)			/* Required */
+
+   Sync will be called when XAA needs to be certain that all
+   graphics coprocessor operations are finished, such as when
+   the framebuffer must be written to or read from directly
+   and it must be certain that the accelerator will not be
+   overwriting the area of interest.
+
+   One needs to make certain that the Sync function not only
+   waits for the accelerator fifo to empty, but that it waits for
+   the rendering of that last operation to complete.
+
+   It is guaranteed that no direct framebuffer access will
+   occur after a "SetupFor" or "Subsequent" function without
+   the Sync function being called first.
+
+
+
+2)  THE PRIMITIVES
+
+2.0  Generic Flags
+
+  Each primitive type has a set of flags associated with it which
+allow the driver to tell XAA what the hardware limitations are.
+The common ones are as follows:
+
+/* Foreground, Background, rop and planemask restrictions */
+
+   GXCOPY_ONLY
+
+     This indicates that the accelerator only supports GXcopy
+     for the particular primitive.
+
+   ROP_NEEDS_SOURCE
+
+     This indicates that the accelerator doesn't supports a
+     particular primitive with rops that don't involve the source.
+     These rops are GXclear, GXnoop, GXinvert and GXset. If neither
+     this flag nor GXCOPY_ONLY is defined, it is assumed that the
+     accelerator supports all 16 raster operations (rops) for that
+     primitive.
+
+   NO_PLANEMASK
+
+     This indicates that the accelerator does not support a hardware
+     write planemask for the particular primitive.
+
+   RGB_EQUAL
+
+     This indicates that the particular primitive requires the red, 
+     green and blue bytes of the foreground color (and background color,
+     if applicable) to be equal. This is useful for 24bpp when a graphics
+     coprocessor is used in 8bpp mode, which is not uncommon in older
+     hardware since some have no support for or only limited support for 
+     acceleration at 24bpp. This way, many operations will be accelerated 
+     for the common case of "grayscale" colors.  This flag should only
+     be used in 24bpp.
+
+  In addition to the common ones listed above which are possible for
+nearly all primitives, each primitive may have its own flags specific
+to that primitive.  If such flags exist they are documented in the
+descriptions of those primitives below.
+ 
+
+
+
+2.1  Screen to Screen Copies
+
+   The SetupFor and Subsequent ScreenToScreenCopy functions provide
+   an interface for copying rectangular areas from video memory to
+   video memory.  To accelerate this primitive the driver should
+   provide both the SetupFor and Subsequent functions and indicate
+   the hardware restrictions via the ScreenToScreenCopyFlags.  The
+   NO_PLANEMASK, GXCOPY_ONLY and ROP_NEEDS_SOURCE flags as described
+   in Section 2.0 are valid as well as the following:
+
+    NO_TRANSPARENCY
+     
+      This indicates that the accelerator does not support skipping
+      of color keyed pixels when copying from the source to the destination.
+
+    TRANSPARENCY_GXCOPY_ONLY
+
+      This indicates that the accelerator supports skipping of color keyed
+      pixels only when the rop is GXcopy.
+
+    ONLY_LEFT_TO_RIGHT_BITBLT
+
+      This indicates that the hardware only accepts blitting when the
+      x direction is positive.
+
+    ONLY_TWO_BITBLT_DIRECTIONS
+
+      This indicates that the hardware can only cope with blitting when
+      the direction of x is the same as the direction in y.
+
+
+void SetupForScreenToScreenCopy( ScrnInfoPtr pScrn,
+			int xdir, int ydir,
+			int rop,
+			unsigned int planemask,
+			int trans_color )
+
+    When this is called, SubsequentScreenToScreenCopy will be called
+    one or more times directly after.  If ydir is 1, then the accelerator
+    should copy starting from the top (minimum y) of the source and
+    proceed downward.  If ydir is -1, then the accelerator should copy
+    starting from the bottom of the source (maximum y) and proceed
+    upward.  If xdir is 1, then the accelerator should copy each
+    y scanline starting from the leftmost pixel of the source.  If
+    xdir is -1, it should start from the rightmost pixel.  
+       If trans_color is not -1 then trans_color indicates that the
+    accelerator should not copy pixels with the color trans_color
+    from the source to the destination, but should skip them. 
+    Trans_color is always -1 if the NO_TRANSPARENCY flag is set.
+ 
+
+void SubsequentScreenToScreenCopy(ScrnInfoPtr pScrn,
+			int x1, int y1,
+			int x2, int y2,
+			int width, int height)
+
+    Copy a rectangle "width" x "height" from the source (x1,y1) to the 
+    destination (x2,y2) using the parameters passed by the last
+    SetupForScreenToScreenCopy call. (x1,y1) and (x2,y2) always denote 
+    the upper left hand corners of the source and destination regardless 
+    of which xdir and ydir values are given by SetupForScreenToScreenCopy.  
+
+
+
+2.2 Solid Fills
+
+   The SetupFor and Subsequent SolidFill(Rect/Trap) functions provide
+   an interface for filling rectangular areas of the screen with a
+   foreground color.  To accelerate this primitive the driver should
+   provide both the SetupForSolidFill and SubsequentSolidFillRect 
+   functions and indicate the hardware restrictions via the SolidFillFlags.
+   The driver may optionally provide a SubsequentSolidFillTrap if
+   it is capable of rendering the primitive correctly.  
+   The GXCOPY_ONLY, ROP_NEEDS_SOURCE, NO_PLANEMASK and RGB_EQUAL flags
+   as described in Section 2.0 are valid.
+
+  
+void SetupForSolidFill(ScrnInfoPtr pScrn, 
+                       int color, int rop, unsigned int planemask)
+
+    SetupForSolidFill indicates that any combination of the following 
+    may follow it.
+
+	SubsequentSolidFillRect
+	SubsequentSolidFillTrap
+
+
+ 
+void SubsequentSolidFillRect(ScrnInfoPtr pScrn, int x, int y, int w, int h)
+
+     Fill a rectangle of dimensions "w" by "h" with origin at (x,y) 
+     using the color, rop and planemask given by the last 
+     SetupForSolidFill call.
+
+void SubsequentSolidFillTrap(ScrnInfoPtr pScrn, int y, int h, 
+	int left, int dxL, int dyL, int eL,
+	int right, int dxR, int dyR, int eR)
+
+     These parameters describe a trapezoid via a version of
+     Bresenham's parameters. "y" is the top line. "h" is the
+     number of spans to be filled in the positive Y direction.
+     "left" and "right" indicate the starting X values of the
+     left and right edges.  dy/dx describes the edge slope.
+     These are not the deltas between the beginning and ending
+     points on an edge.  They merely describe the slope. "e" is
+     the initial error term.  It's the relationships between dx,
+     dy and e that define the edge.
+	If your engine does not do bresenham trapezoids or does
+     not allow the programmer to specify the error term then
+     you are not expected to be able to accelerate them.
+
+
+2.3  Solid Lines
+
+    XAA provides an interface for drawing thin lines.  In order to
+    draw X lines correctly a high degree of accuracy is required.
+    This usually limits line acceleration to hardware which has a
+    Bresenham line engine, though depending on the algorithm used,
+    other line engines may come close if they accept 16 bit line 
+    deltas.  XAA has both a Bresenham line interface and a two-point
+    line interface for drawing lines of arbitrary orientation.  
+    Additionally there is a SubsequentSolidHorVertLine which will
+    be used for all horizontal and vertical lines.  Horizontal and
+    vertical lines are handled separately since hardware that doesn't
+    have a line engine (or has one that is unusable due to precision
+    problems) can usually draw these lines by some other method such
+    as drawing them as thin rectangles.  Even for hardware that can
+    draw arbitrary lines via the Bresenham or two-point interfaces,
+    the SubsequentSolidHorVertLine is used for horizontal and vertical
+    lines since most hardware is able to render the horizontal lines
+    and sometimes the vertical lines faster by other methods (Hint:
+    try rendering horizontal lines as flattened rectangles).  If you have 
+    not provided a SubsequentSolidHorVertLine but you have provided 
+    Bresenham or two-point lines, a SubsequentSolidHorVertLine function 
+    will be supplied for you.
+
+    The flags field associated with Solid Lines is SolidLineFlags and 
+    the GXCOPY_ONLY, ROP_NEEDS_SOURCE, NO_PLANEMASK and RGB_EQUAL flags as
+    described in Section 2.0 are valid restrictions.  
+
+    Some line engines have line biases hardcoded to comply with
+    Microsoft line biasing rules.  A tell-tale sign of this is the
+    hardware lines not matching the software lines in the zeroth and
+    fourth octants.  The driver can set the flag:
+	
+	MICROSOFT_ZERO_LINE_BIAS
+
+    in the AccelInfoRec.Flags field to adjust the software lines to
+    match the hardware lines.   This is in the generic flags field
+    rather than the SolidLineFlags since this flag applies to all
+    software zero-width lines on the screen and not just the solid ones.
+
+
+void SetupForSolidLine(ScrnInfoPtr pScrn, 
+                       int color, int rop, unsigned int planemask)
+
+    SetupForSolidLine indicates that any combination of the following 
+    may follow it.
+
+	SubsequentSolidBresenhamLine
+	SubsequentSolidTwoPointLine
+        SubsequentSolidHorVertLine 	
+
+
+void SubsequentSolidHorVertLine( ScrnInfoPtr pScrn,
+        			int x, int y, int len, int dir )
+
+    All vertical and horizontal solid thin lines are rendered with
+    this function.  The line starts at coordinate (x,y) and extends
+    "len" pixels inclusive.  In the direction indicated by "dir."
+    The direction is either DEGREES_O or DEGREES_270.  That is, it
+    always extends to the right or down.
+
+
+
+void SubsequentSolidTwoPointLine(ScrnInfoPtr pScrn,
+        	int x1, int y1, int x2, int y2, int flags)
+
+    Draw a line from (x1,y1) to (x2,y2).  If the flags field contains
+    the flag OMIT_LAST, the last pixel should not be drawn.  Otherwise,
+    the pixel at (x2,y2) should be drawn.
+
+    If you use the TwoPoint line interface there is a good possibility
+    that your line engine has hard-coded line biases that do not match
+    the default X zero-width lines.  If so, you may need to set the
+    MICROSOFT_ZERO_LINE_BIAS flag described above.  Note that since
+    any vertex in the 16-bit signed coordinate system is valid, your
+    line engine is expected to handle 16-bit values if you have hardware
+    line clipping enabled.  If your engine cannot handle 16-bit values,
+    you should not use hardware line clipping.
+
+
+void SubsequentSolidBresenhamLine(ScrnInfoPtr pScrn,
+        int x, int y, int major, int minor, int err, int len, int octant)
+
+    "X" and "y" are the starting point of the line.  "Major" and "minor" 
+    are the major and minor step constants.  "Err" is the initial error
+    term.  "Len" is the number of pixels to be drawn (inclusive). "Octant"
+    can be any combination of the following flags OR'd together:
+
+      Y_MAJOR		Y is the major axis (X otherwise)
+      X_DECREASING	The line is drawn from right to left
+      Y_DECREASING	The line is drawn from bottom to top
+	  
+    The major, minor and err terms are the "raw" Bresenham parameters
+    consistent with a line engine that does:
+
+	e = err;
+	while(len--) {
+	   DRAW_POINT(x,y);
+	   e += minor;
+	   if(e >= 0) {
+		e -= major;
+		TAKE_ONE_STEP_ALONG_MINOR_AXIS;
+	   }
+	   TAKE_ONE_STEP_ALONG_MAJOR_AXIS;
+	}
+
+    IBM 8514 style Bresenham line interfaces require their parameters
+    modified in the following way:
+
+	Axial = minor;
+	Diagonal = minor - major;
+	Error = minor + err;
+
+SolidBresenhamLineErrorTermBits
+
+    This field allows the driver to tell XAA how many bits large its
+    Bresenham parameter registers are.  Many engines have registers that
+    only accept 12 or 13 bit Bresenham parameters, and the parameters
+    for clipped lines may overflow these if they are not scaled down.
+    If this field is not set, XAA will assume the engine can accomodate
+    16 bit parameters, otherwise, it will scale the parameters to the
+    size specified.
+
+
+2.4  Dashed Lines
+
+    The same degree of accuracy required by the solid lines is required
+    for drawing dashed lines as well.  The dash pattern itself is a
+    buffer of binary data where ones are expanded into the foreground
+    color and zeros either correspond to the background color or
+    indicate transparency depending on whether or not DoubleDash or
+    OnOffDashes are being drawn.  
+
+    The flags field associated with dashed Lines is DashedLineFlags and 
+    the GXCOPY_ONLY, ROP_NEEDS_SOURCE, NO_PLANEMASK and RGB_EQUAL flags as
+    described in Section 2.0 are valid restrictions.  Additionally, the
+    following flags are valid:
+
+      NO_TRANSPARENCY
+
+	This indicates that the driver cannot support dashed lines
+	with transparent backgrounds (OnOffDashes).
+
+      TRANSPARENCY_ONLY
+
+	This indicates that the driver cannot support dashes with
+	both a foreground and background color (DoubleDashes).
+
+      LINE_PATTERN_POWER_OF_2_ONLY
+
+	This indicates that only patterns with a power of 2 length
+	can be accelerated.
+
+      LINE_PATTERN_LSBFIRST_MSBJUSTIFIED
+      LINE_PATTERN_LSBFIRST_LSBJUSTIFIED
+      LINE_PATTERN_MSBFIRST_MSBJUSTIFIED
+      LINE_PATTERN_MSBFIRST_LSBJUSTIFIED
+
+	These describe how the line pattern should be packed.
+	The pattern buffer is DWORD padded.  LSBFIRST indicates
+	that the pattern runs from the LSB end to the MSB end.
+	MSBFIRST indicates that the pattern runs from the MSB end
+	to the LSB end.  When the pattern does not completely fill
+	the DWORD padded buffer, the pattern will be justified 
+	towards the MSB or LSB end based on the flags above.
+
+
+    The following field indicates the maximum length dash pattern that
+    should be accelerated.
+
+	int DashPatternMaxLength
+
+
+void SetupForDashedLine(ScrnInfoPtr pScrn,
+		int fg, int bg, int rop, unsigned int planemask,
+        	int length, unsigned char *pattern)
+
+    
+    SetupForDashedLine indicates that any combination of the following 
+    may follow it.
+
+	SubsequentDashedBresenhamLine
+	SubsequentDashedTwoPointLine
+
+    If "bg" is -1, then the background (pixels corresponding to clear
+    bits in the pattern) should remain unmodified. "Bg" indicates the
+    background color otherwise.  "Length" indicates the length of
+    the pattern in bits and "pattern" points to the DWORD padded buffer
+    holding the pattern which has been packed according to the flags
+    set above.  
+
+    
+void SubsequentDashedTwoPointLine( ScrnInfoPtr pScrn,
+        int x1, int y1, int x2, int y2, int flags, int phase)
+
+void SubsequentDashedBresenhamLine(ScrnInfoPtr pScrn,
+        int x1, int y1, int major, int minor, int err, int len, int octant,
+        int phase)
+  
+    These are the same as the SubsequentSolidTwoPointLine and
+    SubsequentBresenhamLine functions except for the addition
+    of the "phase" field which indicates the offset into the dash 
+    pattern that the pixel at (x1,y1) corresponds to.
+
+    As with the SubsequentBresenhamLine, there is an
+ 
+	int DashedBresenhamLineErrorTermBits 
+   
+    field which indicates the size of the error term registers
+    used with dashed lines.  This is usually the same value as
+    the field for the solid lines (because it's usually the same
+    register).
+       
+      
+
+2.5   Color Expansion Fills
+
+    When filling a color expansion rectangle, the accelerator
+    paints each pixel depending on whether or not a bit in a
+    corresponding bitmap is set or clear. Opaque expansions are 
+    when a set bit corresponds to the foreground color and a clear 
+    bit corresponds to the background color.  A transparent expansion
+    is when a set bit corresponds to the foreground color and a
+    clear bit indicates that the pixel should remain unmodified.
+   
+    The graphics accelerator usually has access to the source 
+    bitmap in one of two ways: 1) the bitmap data is sent serially
+    to the accelerator by the CPU through some memory mapped aperture
+    or 2) the accelerator reads the source bitmap out of offscreen
+    video memory.  Some types of primitives are better suited towards 
+    one method or the other.  Type 2 is useful for reusable patterns
+    such as stipples which can be cached in offscreen memory.  The
+    aperature method can be used for stippling but the CPU must pass
+    the data across the bus each time a stippled fill is to be performed.  
+    For expanding 1bpp client pixmaps or text strings to the screen,
+    the aperature method is usually superior because the intermediate
+    copy in offscreen memory needed by the second method would only be 
+    used once.  Unfortunately, many accelerators can only do one of these
+    methods and not both.  
+
+    XAA provides both ScreenToScreen and CPUToScreen color expansion 
+    interfaces for doing color expansion fills.  The ScreenToScreen
+    functions can only be used with hardware that supports reading
+    of source bitmaps from offscreen video memory, and these are only
+    used for cacheable patterns such as stipples.  There are two
+    variants of the CPUToScreen routines - a direct method intended
+    for hardware that has a transfer aperature, and an indirect method
+    intended for hardware without transfer aperatures or hardware
+    with unusual transfer requirements.  Hardware that can only expand
+    bitmaps from video memory should supply ScreenToScreen routines
+    but also ScanlineCPUToScreen (indirect) routines to optimize transfers 
+    of non-cacheable data.  Hardware that can only accept source bitmaps
+    through an aperature should supply CPUToScreen (or ScanlineCPUToScreen) 
+    routines. Hardware that can do both should provide both ScreenToScreen 
+    and CPUToScreen routines.
+
+    For both ScreenToScreen and CPUToScreen interfaces, the GXCOPY_ONLY,
+    ROP_NEEDS_SOURCE, NO_PLANEMASK and RGB_EQUAL flags described in
+    Section 2.0 are valid as well as the following:
+
+    /* bit order requirements (one of these must be set) */
+   
+    BIT_ORDER_IN_BYTE_LSBFIRST
+
+      This indicates that least significant bit in each byte of the source
+      data corresponds to the leftmost of that block of 8 pixels.  This
+      is the prefered format.
+
+    BIT_ORDER_IN_BYTE_MSBFIRST    
+
+      This indicates that most significant bit in each byte of the source
+      data corresponds to the leftmost of that block of 8 pixels.
+
+    /* transparency restrictions */
+
+    NO_TRANSPARENCY
+
+      This indicates that the accelerator cannot do a transparent expansion.
+
+    TRANSPARENCY_ONLY
+
+      This indicates that the accelerator cannot do an opaque expansion.
+      In cases where where the background needs to be filled, XAA will
+      render the primitive in two passes when using the CPUToScreen
+      interface, but will not do so with the ScreenToScreen interface 
+      since that would require caching of two patterns.  Some 
+      ScreenToScreen hardware may be able to render two passes at the
+      driver level and remove the TRANSPARENCY_ONLY restriction if
+      it can render pixels corresponding to the zero bits.
+
+
+
+2.5.1  Screen To Screen Color Expansion
+
+    The ScreenToScreenColorExpandFill routines provide an interface
+    for doing expansion blits from source patterns stored in offscreen
+    video memory.
+
+    void SetupForScreenToScreenColorExpandFill (ScrnInfoPtr pScrn,
+        			int fg, int bg, 
+				int rop, unsigned int planemask)
+
+
+    Ones in the source bitmap will correspond to the fg color.
+    Zeros in the source bitmap will correspond to the bg color
+    unless bg = -1.  In that case the pixels corresponding to the
+    zeros in the bitmap shall be left unmodified by the accelerator.
+
+    For hardware that doesn't allow an easy implementation of skipleft, the
+    driver can replace CacheMonoStipple function with one that stores multiple
+    rotated copies of the stipple and select between them. In this case the
+    driver should set CacheColorExpandDensity to tell XAA how many copies of
+    the pattern are stored in the width of a cache slot. For instance if the
+    hardware can specify the starting address in bytes, then 8 rotated copies
+    of the stipple are needed and CacheColorExpandDensity should be set to 8.
+
+    void SubsequentScreenToScreenColorExpandFill( ScrnInfoPtr pScrn,
+				int x, int y, int w, int h,
+				int srcx, int srcy, int offset )
+
+   
+    Fill a rectangle "w" x "h" at location (x,y).  The source pitch
+    between scanlines is the framebuffer pitch (pScrn->displayWidth
+    pixels) and srcx and srcy indicate the start of the source pattern 
+    in units of framebuffer pixels. "Offset" indicates the bit offset
+    into the pattern that corresponds to the pixel being painted at
+    "x" on the screen.  Some hardware accepts source coordinates in
+    units of bits which makes implementation of the offset trivial.
+    In that case, the bit address of the source bit corresponding to
+    the pixel painted at (x,y) would be:
+	
+     (srcy * pScrn->displayWidth + srcx) * pScrn->bitsPerPixel + offset
+
+    It should be noted that the offset assumes LSBFIRST hardware.  
+    For MSBFIRST hardware, the driver may need to implement the 
+    offset by bliting only from byte boundaries and hardware clipping.
+
+
+
+2.5.2  CPU To Screen Color Expansion
+
+
+    The CPUToScreenColorExpandFill routines provide an interface for 
+    doing expansion blits from source patterns stored in system memory.
+    There are two varieties of this primitive, a CPUToScreenColorExpandFill
+    and a ScanlineCPUToScreenColorExpandFill.  With the 
+    CPUToScreenColorExpandFill method, the source data is sent serially
+    through a memory mapped aperature.  With the Scanline version, the
+    data is rendered scanline at a time into intermediate buffers with
+    a call to SubsequentColorExpandScanline following each scanline.
+
+    These two methods have separate flags fields, the
+    CPUToScreenColorExpandFillFlags and ScanlineCPUToScreenColorExpandFillFlags
+    respectively.  Flags specific to one method or the other are described 
+    in sections 2.5.2.1 and 2.5.2.2 but for both cases the bit order and
+    transparency restrictions listed at the beginning of section 2.5 are 
+    valid as well as the following:
+    
+    /* clipping  (optional) */
+    
+    LEFT_EDGE_CLIPPING
+ 
+      This indicates that the accelerator supports omission of up to
+      31 pixels on the left edge of the rectangle to be filled.  This
+      is beneficial since it allows transfer of the source bitmap to
+      always occur from DWORD boundaries. 
+
+    LEFT_EDGE_CLIPPING_NEGATIVE_X
+
+      This flag indicates that the accelerator can render color expansion
+      rectangles even if the value of x origin is negative (off of
+      the screen on the left edge).
+
+    /* misc */
+
+    TRIPLE_BITS_24BPP
+
+      When enabled (must be in 24bpp mode), color expansion functions
+      are expected to require three times the amount of bits to be
+      transferred so that 24bpp grayscale colors can be used with color
+      expansion in 8bpp coprocessor mode. Each bit is expanded to 3
+      bits when writing the monochrome data.
+
+
+ 2.5.1 The Direct Method 
+
+
+    Using the direct method of color expansion XAA will send all
+    bitmap data to the accelerator serially through an memory mapped
+    transfer window defined by the following two fields:
+
+      unsigned char *ColorExpandBase
+
+        This indicates the memory address of the beginning of the aperture.
+
+      int ColorExpandRange
+
+        This indicates the size in bytes of the aperture.
+
+    The driver should specify how the transfered data should be padded.
+    There are options for both the padding of each Y scanline and for the
+    total transfer to the aperature.
+    One of the following two flags must be set:
+
+      CPU_TRANSFER_PAD_DWORD
+
+        This indicates that the total transfer (sum of all scanlines) sent
+        to the aperature must be DWORD padded.  This is the default behavior.
+
+      CPU_TRANSFER_PAD_QWORD 
+
+	This indicates that the total transfer (sum of all scanlines) sent
+	to the aperature must be QWORD padded.  With this set, XAA will send
+        an extra DWORD to the aperature when needed to ensure that only
+        an even number of DWORDs are sent.
+
+    And then there are the flags for padding of each scanline:
+
+      SCANLINE_PAD_DWORD
+
+	This indicates that each Y scanline should be DWORD padded.
+        This is the only option available and is the default.
+
+    Finally, there is the CPU_TRANSFER_BASE_FIXED flag which indicates
+    that the aperture is a single register rather than a range of
+    registers, and XAA should write all of the data to the first DWORD.
+    If the ColorExpandRange is not large enough to accomodate scanlines
+    the width of the screen, this option will be forced. That is, the
+    ColorExpandRange must be:
+
+        ((virtualX + 31)/32) * 4   bytes or more.
+
+        ((virtualX + 62)/32 * 4) if LEFT_EDGE_CLIPPING_NEGATIVE_X is set.
+  
+    If the TRIPLE_BITS_24BPP flag is set, the required area should be 
+    multiplied by three.
+     
+    
+void SetupForCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
+        		int fg, int bg,
+			int rop,
+			unsigned int planemask)
+
+  
+ 
+     Ones in the source bitmap will correspond to the fg color.
+     Zeros in the source bitmap will correspond to the bg color
+     unless bg = -1.  In that case the pixels corresponding to the
+     zeros in the bitmap shall be left unmodified by the accelerator.
+
+
+void SubsequentCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
+			int x, int y, int w, int h,
+			int skipleft )
+
+     When this function is called, the accelerator should be setup
+     to fill a rectangle of dimension "w" by "h" with origin at (x,y)
+     in the fill style prescribed by the last call to 
+     SetupForCPUToScreenColorExpandFill.  XAA will pass the data to 
+     the aperture immediately after this function is called.  If the 
+     skipleft is non-zero (and LEFT_EDGE_CLIPPING has been enabled), then 
+     the accelerator _should_not_ render skipleft pixels on the leftmost
+     edge of the rectangle.  Some engines have an alignment feature
+     like this built in, some others can do this using a clipping
+     window.
+
+     It can be arranged for XAA to call Sync() after it is through 
+     calling the Subsequent function by setting SYNC_AFTER_COLOR_EXPAND 
+     in the  CPUToScreenColorExpandFillFlags.  This can provide the driver 
+     with an oportunity to reset a clipping window if needed.
+
+    
+2.5.2  The Indirect Method 
+
+     Using the indirect method, XAA will render the bitmap data scanline
+     at a time to one or more buffers.  These buffers may be memory
+     mapped apertures or just intermediate storage.
+
+     int NumScanlineColorExpandBuffers
+
+       This indicates the number of buffers available.
+
+     unsigned char **ScanlineColorExpandBuffers
+
+       This is an array of pointers to the memory locations of each buffer.
+       Each buffer is expected to be large enough to accommodate scanlines
+       the width of the screen.  That is:
+
+        ((virtualX + 31)/32) * 4   bytes or more.
+
+        ((virtualX + 62)/32 * 4) if LEFT_EDGE_CLIPPING_NEGATIVE_X is set.
+  
+     Scanlines are always DWORD padded.
+     If the TRIPLE_BITS_24BPP flag is set, the required area should be 
+     multiplied by three.
+
+
+void SetupForScanlineCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
+        		int fg, int bg,
+			int rop,
+			unsigned int planemask)
+ 
+     Ones in the source bitmap will correspond to the fg color.
+     Zeros in the source bitmap will correspond to the bg color
+     unless bg = -1.  In that case the pixels corresponding to the
+     zeros in the bitmap shall be left unmodified by the accelerator.
+
+     
+void SubsequentScanlineCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
+			int x, int y, int w, int h,
+			int skipleft )
+
+void SubsequentColorExpandScanline(ScrnInfoPtr pScrn, int bufno)
+
+
+    When SubsequentScanlineCPUToScreenColorExpandFill is called, XAA 
+    will begin transfering the source data scanline at a time, calling  
+    SubsequentColorExpandScanline after each scanline.  If more than
+    one buffer is available, XAA will cycle through the buffers.
+    Subsequent scanlines will use the next buffer and go back to the
+    buffer 0 again when the last buffer is reached.  The index into
+    the ScanlineColorExpandBuffers array is presented as "bufno"
+    with each SubsequentColorExpandScanline call.
+
+    The skipleft field is the same as for the direct method.
+
+    The indirect method can be use to send the source data directly 
+    to a memory mapped aperture represented by a single color expand
+    buffer, scanline at a time, but more commonly it is used to place 
+    the data into offscreen video memory so that the accelerator can 
+    blit it to the visible screen from there.  In the case where the
+    accelerator permits rendering into offscreen video memory while
+    the accelerator is active, several buffers can be used so that
+    XAA can be placing source data into the next buffer while the
+    accelerator is blitting the current buffer.  For cases where
+    the accelerator requires some special manipulation of the source
+    data first, the buffers can be in system memory.  The CPU can
+    manipulate these buffers and then send the data to the accelerator.
+
+
+
+2.6   8x8 Mono Pattern Fills
+
+    XAA provides support for two types of 8x8 hardware patterns -
+    "Mono" patterns and "Color" patterns.  Mono pattern data is
+    64 bits of color expansion data with ones indicating the
+    foreground color and zeros indicating the background color.
+    The source bitmaps for the 8x8 mono patterns can be presented
+    to the graphics accelerator in one of two ways.  They can be
+    passed as two DWORDS to the 8x8 mono pattern functions or
+    they can be cached in offscreen memory and their locations
+    passed to the 8x8 mono pattern functions.  In addition to the
+    GXCOPY_ONLY, ROP_NEEDS_SOURCE, NO_PLANEMASK and RGB_EQUAL flags
+    defined in Section 2.0, the following are defined for the
+    Mono8x8PatternFillFlags:
+
+    HARDWARE_PATTERN_PROGRAMMED_BITS
+
+      This indicates that the 8x8 patterns should be packed into two
+      DWORDS and passed to the 8x8 mono pattern functions.  The default
+      behavior is to cache the patterns in offscreen video memory and
+      pass the locations of these patterns to the functions instead.
+      The pixmap cache must be enabled for the default behavior (8x8 
+      pattern caching) to work.  See Section 3 for how to enable the
+      pixmap cache. The pixmap cache is not necessary for 
+      HARDWARE_PATTERN_PROGRAMMED_BITS.
+
+    HARDWARE_PATTERN_PROGRAMMED_ORIGIN
+
+      If the hardware supports programmable pattern offsets then
+      this option should be set. See the table below for further
+      infomation.
+
+    HARDWARE_PATTERN_SCREEN_ORIGIN
+
+      Some hardware wants the pattern offset specified with respect to the
+      upper left-hand corner of the primitive being drawn.  Other hardware 
+      needs the option HARDWARE_PATTERN_SCREEN_ORIGIN set to indicate that 
+      all pattern offsets should be referenced to the upper left-hand 
+      corner of the screen.  HARDWARE_PATTERN_SCREEN_ORIGIN is preferable 
+      since this is more natural for the X-Window system and offsets will 
+      have to be recalculated for each Subsequent function otherwise.
+
+    BIT_ORDER_IN_BYTE_MSBFIRST
+    BIT_ORDER_IN_BYTE_LSBFIRST
+
+      As with other color expansion routines this indicates whether the
+      most or the least significant bit in each byte from the pattern is 
+      the leftmost on the screen.
+
+    TRANSPARENCY_ONLY
+    NO_TRANSPARENCY
+
+      This means the same thing as for the color expansion rect routines
+      except that for TRANSPARENCY_ONLY XAA will not render the primitive
+      in two passes since this is more easily handled by the driver.
+      It is recommended that TRANSPARENCY_ONLY hardware handle rendering
+      of opaque patterns in two passes (the background can be filled as
+      a rectangle in GXcopy) in the Subsequent function so that the
+      TRANSPARENCY_ONLY restriction can be removed. 
+
+
+
+    Additional information about cached patterns...
+    For the case where HARDWARE_PATTERN_PROGRAMMED_BITS is not set and 
+    the pattern must be cached in offscreen memory, the first pattern
+    starts at the cache slot boundary which is set by the 
+    CachePixelGranularity field used to configure the pixmap cache.
+    One should ensure that the CachePixelGranularity reflects any 
+    alignment restrictions that the accelerator may put on 8x8 pattern 
+    storage locations.  When HARDWARE_PATTERN_PROGRAMMED_ORIGIN is set 
+    there is only one pattern stored.  When this flag is not set,
+    all 64 pre-rotated copies of the pattern are cached in offscreen memory.
+    The MonoPatternPitch field can be used to specify the X position pixel
+    granularity that each of these patterns must align on.  If the
+    MonoPatternPitch is not supplied, the patterns will be densely packed
+    within the cache slot.  The behavior of the default XAA 8x8 pattern
+    caching mechanism to store all 8x8 patterns linearly in video memory.
+    If the accelerator needs the patterns stored in a more unusual fashion,
+    the driver will need to provide its own 8x8 mono pattern caching 
+    routines for XAA to use. 
+
+    The following table describes the meanings of the "patx" and "paty"
+    fields in both the SetupFor and Subsequent functions.
+
+    With HARDWARE_PATTERN_SCREEN_ORIGIN
+    -----------------------------------
+
+    HARDWARE_PATTERN_PROGRAMMED_BITS and HARDWARE_PATTERN_PROGRAMMED_ORIGIN
+
+	SetupFor: patx and paty are the first and second DWORDS of the
+		  8x8 mono pattern.
+
+	Subsequent: patx and paty are the x,y offset into that pattern.
+		    All Subsequent calls will have the same offset in 
+		    the case of HARDWARE_PATTERN_SCREEN_ORIGIN so only
+		    the offset specified by the first Subsequent call 
+		    after a SetupFor call will need to be observed.
+
+    HARDWARE_PATTERN_PROGRAMMED_BITS only
+
+	SetupFor: patx and paty hold the first and second DWORDS of
+		  the 8x8 mono pattern pre-rotated to match the desired
+		  offset.
+
+	Subsequent: These just hold the same patterns and can be ignored.
+
+    HARDWARE_PATTERN_PROGRAMMED_ORIGIN only
+
+	SetupFor: patx and paty hold the x,y coordinates of the offscreen
+		  memory location where the 8x8 pattern is stored.  The
+		  bits are stored linearly in memory at that location.
+
+	Subsequent: patx and paty hold the offset into the pattern.
+		    All Subsequent calls will have the same offset in 
+		    the case of HARDWARE_PATTERN_SCREEN_ORIGIN so only
+		    the offset specified by the first Subsequent call 
+		    after a SetupFor call will need to be observed.
+
+    Neither programmed bits or origin
+
+	SetupFor: patx and paty hold the x,y coordinates of the offscreen 	
+		  memory location where the pre-rotated 8x8 pattern is
+		  stored.
+
+	Subsequent: patx and paty are the same as in the SetupFor function
+		    and can be ignored.
+		  
+
+    Without HARDWARE_PATTERN_SCREEN_ORIGIN
+    -------------------------------------- 
+
+    HARDWARE_PATTERN_PROGRAMMED_BITS and HARDWARE_PATTERN_PROGRAMMED_ORIGIN
+
+	SetupFor: patx and paty are the first and second DWORDS of the
+		  8x8 mono pattern.
+
+	Subsequent: patx and paty are the x,y offset into that pattern.
+
+    HARDWARE_PATTERN_PROGRAMMED_BITS only
+
+	SetupFor: patx and paty holds the first and second DWORDS of
+		  the unrotated 8x8 mono pattern.  This can be ignored. 
+
+	Subsequent: patx and paty hold the rotated 8x8 pattern to be 
+		    rendered.
+
+    HARDWARE_PATTERN_PROGRAMMED_ORIGIN only
+
+	SetupFor: patx and paty hold the x,y coordinates of the offscreen
+		  memory location where the 8x8 pattern is stored.  The
+		  bits are stored linearly in memory at that location.
+
+	Subsequent: patx and paty hold the offset into the pattern.
+
+    Neither programmed bits or origin
+
+	SetupFor: patx and paty hold the x,y coordinates of the offscreen 	
+		  memory location where the unrotated 8x8 pattern is
+		  stored.  This can be ignored.
+
+	Subsequent: patx and paty hold the x,y coordinates of the
+		    rotated 8x8 pattern to be rendered.
+
+
+
+void SetupForMono8x8PatternFill(ScrnInfoPtr pScrn, int patx, int paty,
+        int fg, int bg, int rop, unsigned int planemask)
+
+    SetupForMono8x8PatternFill indicates that any combination of the 
+    following  may follow it.
+
+	SubsequentMono8x8PatternFillRect
+	SubsequentMono8x8PatternFillTrap
+
+    The fg, bg, rop and planemask fields have the same meaning as the
+    ones used for the other color expansion routines.  Patx's and paty's
+    meaning can be determined from the table above.
+
+ 
+void SubsequentMono8x8PatternFillRect( ScrnInfoPtr pScrn,
+        	int patx, int paty, int x, int y, int w, int h)
+
+     Fill a rectangle of dimensions "w" by "h" with origin at (x,y) 
+     using the parameters give by the last SetupForMono8x8PatternFill
+     call.  The meanings of patx and paty can be determined by the
+     table above.
+
+void SubsequentMono8x8PatternFillTrap( ScrnInfoPtr pScrn,
+     			   int patx, int paty, int y, int h, 
+     			   int left, int dxL, int dyL, int eL,
+     			   int right, int dxR, int dyR, int eR )
+
+     The meanings of patx and paty can be determined by the table above.
+     The rest of the fields have the same meanings as those in the 
+     SubsequentSolidFillTrap function. 
+
+
+
+2.7   8x8 Color Pattern Fills
+  
+    8x8 color pattern data is 64 pixels of full color data that
+    is stored linearly in offscreen video memory.  8x8 color patterns 
+    are useful as a substitute for 8x8 mono patterns when tiling,
+    doing opaque stipples, or in the case where transperency is
+    supported, regular stipples.  8x8 color pattern fills also have
+    the additional benefit of being able to tile full color 8x8
+    patterns instead of just 2 color ones like the mono patterns.
+    However, full color 8x8 patterns aren't used very often in the
+    X Window system so you might consider passing this primitive
+    by if you already can do mono patterns, especially if they 
+    require alot of cache area.  Color8x8PatternFillFlags is
+    the flags field for this primitive and the GXCOPY_ONLY,
+    ROP_NEEDS_SOURCE and NO_PLANEMASK flags as described in
+    Section 2.0 are valid as well as the following:
+
+
+    HARDWARE_PATTERN_PROGRAMMED_ORIGIN
+
+      If the hardware supports programmable pattern offsets then
+      this option should be set.  
+
+    HARDWARE_PATTERN_SCREEN_ORIGIN
+
+      Some hardware wants the pattern offset specified with respect to the
+      upper left-hand corner of the primitive being drawn.  Other hardware 
+      needs the option HARDWARE_PATTERN_SCREEN_ORIGIN set to indicate that 
+      all pattern offsets should be referenced to the upper left-hand 
+      corner of the screen.  HARDWARE_PATTERN_SCREEN_ORIGIN is preferable 
+      since this is more natural for the X-Window system and offsets will 
+      have to be recalculated for each Subsequent function otherwise.
+
+    NO_TRANSPARENCY
+    TRANSPARENCY_GXCOPY_ONLY
+
+      These mean the same as for the ScreenToScreenCopy functions.
+
+
+    The following table describes the meanings of patx and paty passed
+    to the SetupFor and Subsequent fields:
+
+    HARDWARE_PATTERN_PROGRAMMED_ORIGIN && HARDWARE_PATTERN_SCREEN_ORIGIN
+	
+	SetupFor: patx and paty hold the x,y location of the unrotated 
+		  pattern.
+
+	Subsequent: patx and paty hold the pattern offset.  For the case
+		    of HARDWARE_PATTERN_SCREEN_ORIGIN all Subsequent calls
+		    have the same offset so only the first call will need
+		    to be observed.
+
+    
+    HARDWARE_PATTERN_PROGRAMMED_ORIGIN only
+
+	SetupFor: patx and paty hold the x,y location of the unrotated
+		  pattern.
+
+	Subsequent: patx and paty hold the pattern offset. 
+
+    HARDWARE_PATTERN_SCREEN_ORIGIN
+
+	SetupFor: patx and paty hold the x,y location of the rotated pattern.
+
+	Subsequent: patx and paty hold the same location as the SetupFor
+		    function so these can be ignored.
+
+    neither flag
+
+	SetupFor: patx and paty hold the x,y location of the unrotated
+		  pattern.  This can be ignored.
+
+	Subsequent: patx and paty hold the x,y location of the rotated
+		    pattern.
+
+    Additional information about cached patterns...
+    All 8x8 color patterns are cached in offscreen video memory so
+    the pixmap cache must be enabled to use them. The first pattern
+    starts at the cache slot boundary which is set by the 
+    CachePixelGranularity field used to configure the pixmap cache.
+    One should ensure that the CachePixelGranularity reflects any 
+    alignment restrictions that the accelerator may put on 8x8 pattern 
+    storage locations.  When HARDWARE_PATTERN_PROGRAMMED_ORIGIN is set 
+    there is only one pattern stored.  When this flag is not set,
+    all 64 rotations off the pattern are accessible but it is assumed
+    that the accelerator is capable of accessing data stored on 8
+    pixel boundaries.  If the accelerator has stricter alignment 
+    requirements than this the dirver will need to provide its own 
+    8x8 color pattern caching routines. 
+
+
+void SetupForColor8x8PatternFill(ScrnInfoPtr pScrn, int patx, int paty,
+        	int rop, unsigned int planemask, int trans_color)
+
+    SetupForColor8x8PatternFill indicates that any combination of the 
+    following  may follow it.
+
+	SubsequentColor8x8PatternFillRect
+	SubsequentColor8x8PatternFillTrap	(not implemented yet)
+
+    For the meanings of patx and paty, see the table above.  Trans_color
+    means the same as for the ScreenToScreenCopy functions.
+
+
+ 
+void SubsequentColor8x8PatternFillRect( ScrnInfoPtr pScrn,
+        	int patx, int paty, int x, int y, int w, int h)
+
+     Fill a rectangle of dimensions "w" by "h" with origin at (x,y) 
+     using the parameters give by the last SetupForColor8x8PatternFill
+     call.  The meanings of patx and paty can be determined by the
+     table above.
+
+void SubsequentColor8x8PatternFillTrap( ScrnInfoPtr pScrn,
+     			   int patx, int paty, int y, int h, 
+     			   int left, int dxL, int dyL, int eL,
+     			   int right, int dxR, int dyR, int eR )
+
+    For the meanings of patx and paty, see the table above. 
+    The rest of the fields have the same meanings as those in the 
+    SubsequentSolidFillTrap function. 
+
+
+
+2.8  Image Writes
+
+    XAA provides a mechanism for transfering full color pixel data from
+    system memory to video memory through the accelerator.  This is 
+    useful for dealing with alignment issues and performing raster ops
+    on the data when writing it to the framebuffer.  As with color
+    expansion rectangles, there is a direct and indirect method.  The
+    direct method sends all data through a memory mapped aperature.
+    The indirect method sends the data to an intermediated buffer scanline 
+    at a time.
+
+    The direct and indirect methods have separate flags fields, the
+    ImageWriteFlags and ScanlineImageWriteFlags respectively.
+    Flags specific to one method or the other are described in sections 
+    2.8.1 and 2.8.2 but for both cases the GXCOPY_ONLY, ROP_NEEDS_SOURCE
+    and NO_PLANEMASK flags described in Section 2.0 are valid as well as
+    the following:
+
+    NO_GXCOPY
+
+      In order to have accelerated image transfers faster than the 
+      software versions for GXcopy, the engine needs to support clipping,
+      be using the direct method and have a large enough image transfer
+      range so that CPU_TRANSFER_BASE_FIXED doesn't need to be set.
+      If these are not supported, then it is unlikely that transfering
+      the data through the accelerator will be of any advantage for the
+      simple case of GXcopy.  In fact, it may be much slower.  For such
+      cases it's probably best to set the NO_GXCOPY flag so that 
+      Image writes will only be used for the more complicated rops.
+
+    /* transparency restrictions */
+
+    NO_TRANSPARENCY
+     
+      This indicates that the accelerator does not support skipping
+      of color keyed pixels when copying from the source to the destination.
+
+    TRANSPARENCY_GXCOPY_ONLY
+
+      This indicates that the accelerator supports skipping of color keyed
+      pixels only when the rop is GXcopy.
+
+    /* clipping  (optional) */
+    
+    LEFT_EDGE_CLIPPING
+ 
+      This indicates that the accelerator supports omission of up to
+      3 pixels on the left edge of the rectangle to be filled.  This
+      is beneficial since it allows transfer from the source pixmap to
+      always occur from DWORD boundaries. 
+
+    LEFT_EDGE_CLIPPING_NEGATIVE_X
+
+      This flag indicates that the accelerator can fill areas with
+      image write data even if the value of x origin is negative (off of
+      the screen on the left edge).
+
+
+2.8.1 The Direct Method
+
+    Using the direct method of ImageWrite XAA will send all
+    bitmap data to the accelerator serially through an memory mapped
+    transfer window defined by the following two fields:
+
+      unsigned char *ImageWriteBase
+
+        This indicates the memory address of the beginning of the aperture.
+
+      int ImageWriteRange
+
+        This indicates the size in bytes of the aperture.
+
+    The driver should specify how the transfered data should be padded.
+    There are options for both the padding of each Y scanline and for the
+    total transfer to the aperature.
+    One of the following two flags must be set:
+
+      CPU_TRANSFER_PAD_DWORD
+
+        This indicates that the total transfer (sum of all scanlines) sent
+        to the aperature must be DWORD padded.  This is the default behavior.
+
+      CPU_TRANSFER_PAD_QWORD 
+
+	This indicates that the total transfer (sum of all scanlines) sent
+	to the aperature must be QWORD padded.  With this set, XAA will send
+        an extra DWORD to the aperature when needed to ensure that only
+        an even number of DWORDs are sent.
+
+    And then there are the flags for padding of each scanline:
+
+      SCANLINE_PAD_DWORD
+
+	This indicates that each Y scanline should be DWORD padded.
+        This is the only option available and is the default.
+
+    Finally, there is the CPU_TRANSFER_BASE_FIXED flag which indicates
+    that the aperture is a single register rather than a range of
+    registers, and XAA should write all of the data to the first DWORD.
+    XAA will automatically select CPU_TRANSFER_BASE_FIXED if the 
+    ImageWriteRange is not large enough to accomodate an entire scanline.   
+
+
+void SetupForImageWrite(ScrnInfoPtr pScrn, int rop, unsigned int planemask,
+        			int trans_color, int bpp, int depth)
+
+     If trans_color is not -1 then trans_color indicates the transparency
+     color key and pixels with color trans_color passed through the 
+     aperature should not be transfered to the screen but should be 
+     skipped.  Bpp and depth indicate the bits per pixel and depth of
+     the source pixmap.  Trans_color is always -1 if the NO_TRANSPARENCY
+     flag is set.
+
+
+void SubsequentImageWriteRect(ScrnInfoPtr pScrn, 
+				int x, int y, int w, int h, int skipleft)
+
+     
+     Data passed through the aperature should be copied to a rectangle
+     of width "w" and height "h" with origin (x,y).  If LEFT_EDGE_CLIPPING
+     has been enabled, skipleft will correspond to the number of pixels
+     on the left edge that should not be drawn.  Skipleft is zero 
+     otherwise.
+
+     It can be arranged for XAA to call Sync() after it is through 
+     calling the Subsequent functions by setting SYNC_AFTER_IMAGE_WRITE 
+     in the  ImageWriteFlags.  This can provide the driver with an
+     oportunity to reset a clipping window if needed.
+
+2.8.2  The Indirect Method
+
+     Using the indirect method, XAA will render the pixel data scanline
+     at a time to one or more buffers.  These buffers may be memory
+     mapped apertures or just intermediate storage.
+
+     int NumScanlineImageWriteBuffers
+
+       This indicates the number of buffers available.
+
+     unsigned char **ScanlineImageWriteBuffers
+
+       This is an array of pointers to the memory locations of each buffer.
+       Each buffer is expected to be large enough to accommodate scanlines
+       the width of the screen.  That is:
+
+         pScrn->VirtualX * pScreen->bitsPerPixel/8   bytes or more.
+
+       If LEFT_EDGE_CLIPPING_NEGATIVE_X is set, add an additional 4
+       bytes to that requirement in 8 and 16bpp, 12 bytes in 24bpp.
+  
+     Scanlines are always DWORD padded.
+
+void SetupForScanlineImageWrite(ScrnInfoPtr pScrn, int rop, 
+				unsigned int planemask, int trans_color, 
+				int bpp, int depth)
+
+     If trans_color is not -1 then trans_color indicates the transparency
+     color key and pixels with color trans_color in the buffer should not 
+     be transfered to the screen but should be skipped.  Bpp and depth 
+     indicate the bits per pixel and depth of the source bitmap.  
+     Trans_color is always -1 if the NO_TRANSPARENCY flag is set.
+
+
+void SubsequentImageWriteRect(ScrnInfoPtr pScrn, 
+				int x, int y, int w, int h, int skipleft)
+
+     
+void SubsequentImageWriteScanline(ScrnInfoPtr pScrn, int bufno)
+
+
+    When SubsequentImageWriteRect is called, XAA will begin
+    transfering the source data scanline at a time, calling  
+    SubsequentImageWriteScanline after each scanline.  If more than
+    one buffer is available, XAA will cycle through the buffers.
+    Subsequent scanlines will use the next buffer and go back to the
+    buffer 0 again when the last buffer is reached.  The index into
+    the ScanlineImageWriteBuffers array is presented as "bufno"
+    with each SubsequentImageWriteScanline call.
+
+    The skipleft field is the same as for the direct method.
+
+    The indirect method can be use to send the source data directly 
+    to a memory mapped aperture represented by a single image write
+    buffer, scanline at a time, but more commonly it is used to place 
+    the data into offscreen video memory so that the accelerator can 
+    blit it to the visible screen from there.  In the case where the
+    accelerator permits rendering into offscreen video memory while
+    the accelerator is active, several buffers can be used so that
+    XAA can be placing source data into the next buffer while the
+    accelerator is blitting the current buffer.  For cases where
+    the accelerator requires some special manipulation of the source
+    data first, the buffers can be in system memory.  The CPU can
+    manipulate these buffers and then send the data to the accelerator.
+
+
+2.9 Clipping
+
+    XAA supports hardware clipping rectangles.  To use clipping
+    in this way it is expected that the graphics accelerator can
+    clip primitives with verticies anywhere in the 16 bit signed 
+    coordinate system. 
+
+void SetClippingRectangle ( ScrnInfoPtr pScrn,
+        		int left, int top, int right, int bottom)
+
+void DisableClipping (ScrnInfoPtr pScrn)
+
+    When SetClippingRectangle is called, all hardware rendering
+    following it should be clipped to the rectangle specified
+    until DisableClipping is called.
+
+    The ClippingFlags field indicates which operations this sort
+    of Set/Disable pairing can be used with.  Any of the following
+    flags may be OR'd together.
+
+	HARDWARE_CLIP_SCREEN_TO_SCREEN_COLOR_EXPAND
+	HARDWARE_CLIP_SCREEN_TO_SCREEN_COPY
+	HARDWARE_CLIP_MONO_8x8_FILL
+	HARDWARE_CLIP_COLOR_8x8_FILL
+	HARDWARE_CLIP_SOLID_FILL
+	HARDWARE_CLIP_DASHED_LINE
+	HARDWARE_CLIP_SOLID_LINE
+
+
+
+3)  XAA PIXMAP CACHE
+
+   /* NOTE:  XAA has no knowledge of framebuffer particulars so until
+	the framebuffer is able to render into offscreen memory, usage
+	of the pixmap cache requires that the driver provide ImageWrite
+	routines or a WritePixmap or WritePixmapToCache replacement so
+	that patterns can even be placed in the cache.
+
+      ADDENDUM: XAA can now load the pixmap cache without requiring
+	that the driver supply an ImageWrite function, but this can
+	only be done on linear framebuffers.  If you have a linear
+	framebuffer, set LINEAR_FRAMEBUFFER in the XAAInfoRec.Flags
+	field and XAA will then be able to upload pixmaps into the
+	cache without the driver providing functions to do so.
+   */
+
+
+   The XAA pixmap cache provides a mechanism for caching of patterns
+   in offscreen video memory so that tiled fills and in some cases
+   stippling can be done by blitting the source patterns from offscreen
+   video memory. The pixmap cache also provides the mechanism for caching 
+   of 8x8 color and mono hardware patterns.  Any unused offscreen video
+   memory gets used for the pixmap cache and that information is 
+   provided by the XFree86 Offscreen Memory Manager. XAA registers a 
+   callback with the manager so that it can be informed of any changes 
+   in the offscreen memory configuration.  The driver writer does not 
+   need to deal with any of this since it is all automatic.  The driver 
+   merely needs to initialize the Offscreen Memory Manager as described 
+   in the DESIGN document and set the PIXMAP_CACHE flag in the 
+   XAAInfoRec.Flags field.  The Offscreen Memory Manager initialization 
+   must occur before XAA is initialized or else pixmap cache 
+   initialization will fail.  
+
+   PixmapCacheFlags is an XAAInfoRec field which allows the driver to
+   control pixmap cache behavior to some extent.  Currently only one
+   flag is defined:
+
+   DO_NOT_BLIT_STIPPLES
+
+     This indicates that the stippling should not be done by blitting
+     from the pixmap cache.  This does not apply to 8x8 pattern fills. 
+
+
+   CachePixelGranularity is an optional field.  If the hardware requires
+   that a 8x8 patterns have some particular pixel alignment it should
+   be reflected in this field.  Ignoring this field or setting it to
+   zero or one means there are no alignment issues.
+
+
+4)  OFFSCREEN PIXMAPS
+
+   XAA has the ability to store pixmap drawables in offscreen video 
+   memory and render into them with full hardware acceleration.  Placement
+   of pixmaps in the cache is done automatically on a first-come basis and 
+   only if there is room.  To enable this feature, set the OFFSCREEN_PIXMAPS
+   flag in the XAAInfoRec.Flags field.  This is only available when a
+   ScreenToScreenCopy function is provided, when the Offscreen memory 
+   manager has been initialized and when the LINEAR_FRAMEBUFFER flag is
+   also set.
+
+   int maxOffPixWidth
+   int maxOffPixHeight
+
+       These two fields allow the driver to limit the maximum dimensions
+     of an offscreen pixmap.  If one of these is not set, it is assumed
+     that there is no limit on that dimension.  Note that if an offscreen
+     pixmap with a particular dimension is allowed, then your driver will be
+     expected to render primitives as large as that pixmap.  
+
+$XFree86: xc/programs/Xserver/hw/xfree86/xaa/XAA.HOWTO,v 1.12 2000/04/12 14:44:42 tsi Exp $
diff --git a/hw/xfree86/xaa/xaa.h b/hw/xfree86/xaa/xaa.h
new file mode 100644
index 000000000..451078aa6
--- /dev/null
+++ b/hw/xfree86/xaa/xaa.h
@@ -0,0 +1,1038 @@
+
+#ifndef _XAA_H
+#define _XAA_H
+
+#define XAA_VERSION_MAJOR   1
+#define XAA_VERSION_MINOR   2
+#define XAA_VERSION_RELEASE 1
+
+/*
+
+   ******** OPERATION SPECIFIC FLAGS *********
+
+   **** solid/dashed line flags ****
+ 
+---------               --------
+23           LINE_PATTERN_LSBFIRST_MSBJUSTIFIED
+22           LINE_PATTERN_LSBFIRST_LSBJUSTIFIED
+21           LINE_PATTERN_MSBFIRST_MSBJUSTIFIED
+20           LINE_PATTERN_MSBFIRST_LSBJUSTIFIED
+19           LINE_PATTERN_POWER_OF_2_ONLY
+18           LINE_LIMIT_COORDS
+17                         .
+16                         .
+---------               -------
+
+   **** screen to screen copy flags ****
+
+---------               --------
+23           ONLY_LEFT_TO_RIGHT_BITBLT
+22           ONLY_TWO_BITBLT_DIRECTIONS
+21                         .
+20                         .
+19                         .
+18                         .
+17                         .
+16                         .
+---------               -------
+
+   ****  clipping flags ****
+
+---------               --------
+23                         .
+22           HARDWARE_CLIP_SCREEN_TO_SCREEN_COLOR_EXPAND
+21           HARDWARE_CLIP_SCREEN_TO_SCREEN_COPY
+20           HARDWARE_CLIP_MONO_8x8_FILL
+19           HARDWARE_CLIP_COLOR_8x8_FILL    
+18           HARDWARE_CLIP_SOLID_FILL
+17           HARDWARE_CLIP_DASHED_LINE
+16           HARDWARE_CLIP_SOLID_LINE
+---------               -------
+
+   ****  hardware pattern flags ****
+
+---------               --------
+23                         .
+22                         .
+21           HARDWARE_PATTERN_SCREEN_ORIGIN
+20                         .
+19                         .
+18                         .
+17           HARDWARE_PATTERN_PROGRAMMED_ORIGIN
+16           HARDWARE_PATTERN_PROGRAMMED_BITS
+---------               -------
+
+   ****  write pixmap flags ****
+
+---------               --------
+23                         .
+22                         .
+21                         .
+20                         .
+19                         .
+18                         .
+17                         .
+16           CONVERT_32BPP_TO_24BPP
+---------               -------
+
+   ******** GENERIC FLAGS *********
+
+---------               -------
+15           SYNC_AFTER_COLOR_EXPAND
+14           CPU_TRANSFER_PAD_QWORD
+13                         .
+12           LEFT_EDGE_CLIPPING_NEGATIVE_X
+11	     LEFT_EDGE_CLIPPING
+10	     CPU_TRANSFER_BASE_FIXED
+ 9           BIT_ORDER_IN_BYTE_MSBFIRST           
+ 8           TRANSPARENCY_GXCOPY_ONLY
+---------               -------
+ 7           NO_TRANSPARENCY
+ 6           TRANSPARENCY_ONLY
+ 5           ROP_NEEDS_SOURCE
+ 4           TRIPLE_BITS_24BPP
+ 3           RGB_EQUAL
+ 2           NO_PLANEMASK
+ 1           NO_GXCOPY
+ 0           GXCOPY_ONLY
+---------               -------
+
+
+*/
+
+#include "gcstruct.h"
+#include "pixmapstr.h"
+#include "xf86str.h"
+#include "regionstr.h"
+#include "xf86fbman.h"
+
+#include "picturestr.h"
+
+/* Flags */
+#define PIXMAP_CACHE			0x00000001
+#define MICROSOFT_ZERO_LINE_BIAS	0x00000002
+#define OFFSCREEN_PIXMAPS		0x00000004
+#define LINEAR_FRAMEBUFFER		0x00000008
+
+/* GC fg, bg, and planemask restrictions */
+#define GXCOPY_ONLY			0x00000001
+#define NO_GXCOPY			0x00000002
+#define NO_PLANEMASK			0x00000004
+#define RGB_EQUAL			0x00000008
+#define TRIPLE_BITS_24BPP		0x00000010
+#define ROP_NEEDS_SOURCE		0x00000020
+
+/* transparency restrictions */
+#define TRANSPARENCY_ONLY		0x00000040
+#define NO_TRANSPARENCY			0x00000080
+#define TRANSPARENCY_GXCOPY_ONLY     	0x00000100
+
+/* bit order restrictions */
+#define BIT_ORDER_IN_BYTE_MSBFIRST	0x00000200
+#define BIT_ORDER_IN_BYTE_LSBFIRST	0x00000000
+
+/* transfer base restriction */
+#define CPU_TRANSFER_BASE_FIXED		0x00000400
+
+/* skipleft restrictions */
+#define LEFT_EDGE_CLIPPING		0x00000800
+#define LEFT_EDGE_CLIPPING_NEGATIVE_X	0x00001000
+
+/* data padding */
+#define CPU_TRANSFER_PAD_DWORD		0x00000000
+#define CPU_TRANSFER_PAD_QWORD		0x00004000
+#define SCANLINE_PAD_DWORD		0x00000000
+
+#define SYNC_AFTER_COLOR_EXPAND		0x00008000
+#define SYNC_AFTER_IMAGE_WRITE		SYNC_AFTER_COLOR_EXPAND
+
+/* hardware pattern */
+#define HARDWARE_PATTERN_PROGRAMMED_BITS	0x00010000
+#define HARDWARE_PATTERN_PROGRAMMED_ORIGIN	0x00020000
+#define HARDWARE_PATTERN_SCREEN_ORIGIN		0x00200000
+
+/* copyarea flags */
+#define ONLY_TWO_BITBLT_DIRECTIONS	0x00400000
+#define ONLY_LEFT_TO_RIGHT_BITBLT	0x00800000
+
+/* line flags */
+#define LINE_PATTERN_LSBFIRST_MSBJUSTIFIED	0x00800000
+#define LINE_PATTERN_LSBFIRST_LSBJUSTIFIED	0x00400000
+#define LINE_PATTERN_MSBFIRST_MSBJUSTIFIED	0x00200000
+#define LINE_PATTERN_MSBFIRST_LSBJUSTIFIED	0x00100000
+#define LINE_PATTERN_POWER_OF_2_ONLY		0x00080000
+#define LINE_LIMIT_COORDS			0x00040000
+
+/* clipping flags */
+#define HARDWARE_CLIP_SCREEN_TO_SCREEN_COLOR_EXPAND	0x00400000
+#define HARDWARE_CLIP_SCREEN_TO_SCREEN_COPY		0x00200000
+#define HARDWARE_CLIP_MONO_8x8_FILL			0x00100000
+#define HARDWARE_CLIP_COLOR_8x8_FILL			0x00080000
+#define HARDWARE_CLIP_SOLID_FILL			0x00040000
+#define HARDWARE_CLIP_DASHED_LINE			0x00020000
+#define HARDWARE_CLIP_SOLID_LINE			0x00010000
+
+#define HARDWARE_CLIP_LINE				0x00000000
+
+/* image write flags */
+#define CONVERT_32BPP_TO_24BPP			0x00010000
+
+/* pixmap cache flags */
+#define CACHE_MONO_8x8			0x00000001
+#define CACHE_COLOR_8x8			0x00000002
+#define DO_NOT_BLIT_STIPPLES		0x00000004
+#define DO_NOT_TILE_MONO_DATA		0x00000008
+#define DO_NOT_TILE_COLOR_DATA		0x00000010
+
+#define DEGREES_0	0
+#define DEGREES_90	1
+#define DEGREES_180	2
+#define DEGREES_270	3
+
+#define OMIT_LAST	1
+
+/* render flags */
+
+#define XAA_RENDER_POWER_OF_2_TILE_ONLY	0x00000008
+#define XAA_RENDER_NO_SRC_ALPHA		0x00000004
+#define XAA_RENDER_IMPRECISE_ONLY	0x00000002
+#define XAA_RENDER_NO_TILE		0x00000001
+
+#define XAA_RENDER_REPEAT		0x00000001
+
+typedef void (*ValidateGCProcPtr) (GCPtr pGC,
+                                   unsigned long changes, DrawablePtr pDraw);
+
+typedef struct {
+    unsigned char *bits;
+    int width;
+    int height;
+    int yoff;
+    int srcwidth;
+    int start;
+    int end;
+} NonTEGlyphInfo, *NonTEGlyphPtr;
+
+typedef struct {
+    int x;
+    int y;
+    int w;
+    int h;
+    int orig_w;
+    int orig_h;
+    unsigned long serialNumber;
+    int pat0;
+    int pat1;
+    int fg;
+    int bg;
+    int trans_color;
+    DDXPointPtr offsets;
+    DevUnion devPrivate;
+} XAACacheInfoRec, *XAACacheInfoPtr;
+
+typedef struct _PixmapLink {
+    PixmapPtr pPix;
+    struct _PixmapLink *next;
+    FBAreaPtr area;
+} PixmapLink, *PixmapLinkPtr;
+
+typedef struct _XAAInfoRec {
+    ScrnInfoPtr pScrn;
+    int Flags;
+
+    void (*Sync) (ScrnInfoPtr pScrn);
+
+    /* Restore Accel State is a driver callback that is used
+     * when another screen on the same device has been active.
+     * This allows multihead on a single device to work.
+     * If The entityProp has IS_SHARED_ACCEL defined then this
+     * function is required.
+     */
+
+    void (*RestoreAccelState) (ScrnInfoPtr pScrn);
+
+   /***************** Low Level *****************/
+
+/* Blits */
+    void (*SetupForScreenToScreenCopy) (ScrnInfoPtr pScrn,
+                                        int xdir, int ydir,
+                                        int rop,
+                                        unsigned int planemask,
+                                        int trans_color);
+    int ScreenToScreenCopyFlags;
+
+    void (*SubsequentScreenToScreenCopy) (ScrnInfoPtr pScrn,
+                                          int xsrc, int ysrc,
+                                          int xdst, int ydst, int w, int h);
+
+/* Solid fills */
+    void (*SetupForSolidFill) (ScrnInfoPtr pScrn,
+                               int color, int rop, unsigned int planemask);
+    int SolidFillFlags;
+
+    void (*SubsequentSolidFillRect) (ScrnInfoPtr pScrn,
+                                     int x, int y, int w, int h);
+
+    void (*SubsequentSolidFillTrap) (ScrnInfoPtr pScrn,
+                                     int y, int h,
+                                     int left, int dxL, int dyL, int eL,
+                                     int right, int dxR, int dyR, int eR);
+
+/* Solid lines */
+
+    void (*SetupForSolidLine) (ScrnInfoPtr pScrn,
+                               int color, int rop, unsigned int planemask);
+    int SolidLineFlags;
+
+    void (*SubsequentSolidTwoPointLine) (ScrnInfoPtr pScrn,
+                                         int xa, int ya, int xb, int yb,
+                                         int flags);
+
+    void (*SubsequentSolidBresenhamLine) (ScrnInfoPtr pScrn,
+                                          int x, int y, int absmaj, int absmin,
+                                          int err, int len, int octant);
+    int SolidBresenhamLineErrorTermBits;
+
+    void (*SubsequentSolidHorVertLine) (ScrnInfoPtr pScrn,
+                                        int x, int y, int len, int dir);
+
+/* Dashed lines */
+
+    void (*SetupForDashedLine) (ScrnInfoPtr pScrn,
+                                int fg, int bg,
+                                int rop,
+                                unsigned int planemask,
+                                int length, unsigned char *pattern);
+    int DashedLineFlags;
+    int DashPatternMaxLength;
+
+    void (*SubsequentDashedTwoPointLine) (ScrnInfoPtr pScrn,
+                                          int xa, int ya, int xb, int yb,
+                                          int flags, int phase);
+
+    void (*SubsequentDashedBresenhamLine) (ScrnInfoPtr pScrn,
+                                           int x, int y, int absmaj, int absmin,
+                                           int err, int len, int flags,
+                                           int phase);
+    int DashedBresenhamLineErrorTermBits;
+
+/* Clipper */
+
+    void (*SetClippingRectangle) (ScrnInfoPtr pScrn,
+                                  int left, int top, int right, int bottom);
+    int ClippingFlags;
+
+    void (*DisableClipping) (ScrnInfoPtr pScrn);
+
+/* 8x8 mono pattern fills */
+    void (*SetupForMono8x8PatternFill) (ScrnInfoPtr pScrn,
+                                        int patx, int paty,
+                                        int fg, int bg,
+                                        int rop, unsigned int planemask);
+    int Mono8x8PatternFillFlags;
+
+    void (*SubsequentMono8x8PatternFillRect) (ScrnInfoPtr pScrn,
+                                              int patx, int paty,
+                                              int x, int y, int w, int h);
+
+    void (*SubsequentMono8x8PatternFillTrap) (ScrnInfoPtr pScrn,
+                                              int patx, int paty,
+                                              int y, int h,
+                                              int left, int dxL, int dyL,
+                                              int eL, int right, int dxR,
+                                              int dyR, int eR);
+
+/* 8x8 color pattern fills */
+
+    void (*SetupForColor8x8PatternFill) (ScrnInfoPtr pScrn,
+                                         int patx, int paty,
+                                         int rop,
+                                         unsigned int planemask,
+                                         int transparency_color);
+    int Color8x8PatternFillFlags;
+
+    void (*SubsequentColor8x8PatternFillRect) (ScrnInfoPtr pScrn,
+                                               int patx, int paty,
+                                               int x, int y, int w, int h);
+
+    void (*SubsequentColor8x8PatternFillTrap) (ScrnInfoPtr pScrn,
+                                               int patx, int paty,
+                                               int y, int h,
+                                               int left, int dxL, int dyL,
+                                               int eL, int right, int dxR,
+                                               int dyR, int eR);
+
+/* Color expansion */
+
+    void (*SetupForCPUToScreenColorExpandFill) (ScrnInfoPtr pScrn,
+                                                int fg, int bg,
+                                                int rop,
+                                                unsigned int planemask);
+    int CPUToScreenColorExpandFillFlags;
+
+    void (*SubsequentCPUToScreenColorExpandFill) (ScrnInfoPtr pScrn,
+                                                  int x, int y, int w, int h,
+                                                  int skipleft);
+
+    unsigned char *ColorExpandBase;
+    int ColorExpandRange;
+
+/* Scanline color expansion  */
+
+    void (*SetupForScanlineCPUToScreenColorExpandFill) (ScrnInfoPtr pScrn,
+                                                        int fg, int bg,
+                                                        int rop,
+                                                        unsigned int planemask);
+    int ScanlineCPUToScreenColorExpandFillFlags;
+
+    void (*SubsequentScanlineCPUToScreenColorExpandFill) (ScrnInfoPtr pScrn,
+                                                          int x, int y, int w,
+                                                          int h, int skipleft);
+
+    void (*SubsequentColorExpandScanline) (ScrnInfoPtr pScrn, int bufno);
+
+    int NumScanlineColorExpandBuffers;
+    unsigned char **ScanlineColorExpandBuffers;
+
+/* Screen to screen color expansion */
+
+    void (*SetupForScreenToScreenColorExpandFill) (ScrnInfoPtr pScrn,
+                                                   int fg, int bg,
+                                                   int rop,
+                                                   unsigned int planemask);
+    int ScreenToScreenColorExpandFillFlags;
+
+    void (*SubsequentScreenToScreenColorExpandFill) (ScrnInfoPtr pScrn,
+                                                     int x, int y, int w, int h,
+                                                     int srcx, int srcy,
+                                                     int skipleft);
+
+/*  Image transfers */
+
+    void (*SetupForImageWrite) (ScrnInfoPtr pScrn,
+                                int rop,
+                                unsigned int planemask,
+                                int transparency_color, int bpp, int depth);
+    int ImageWriteFlags;
+
+    void (*SubsequentImageWriteRect) (ScrnInfoPtr pScrn,
+                                      int x, int y, int w, int h, int skipleft);
+    unsigned char *ImageWriteBase;
+    int ImageWriteRange;
+
+/*  Scanline Image transfers */
+
+    void (*SetupForScanlineImageWrite) (ScrnInfoPtr pScrn,
+                                        int rop,
+                                        unsigned int planemask,
+                                        int transparency_color,
+                                        int bpp, int depth);
+    int ScanlineImageWriteFlags;
+
+    void (*SubsequentScanlineImageWriteRect) (ScrnInfoPtr pScrn,
+                                              int x, int y, int w, int h,
+                                              int skipleft);
+
+    void (*SubsequentImageWriteScanline) (ScrnInfoPtr pScrn, int bufno);
+
+    int NumScanlineImageWriteBuffers;
+    unsigned char **ScanlineImageWriteBuffers;
+
+    /* Image Reads - OBSOLETE AND NOT USED */
+
+    void (*SetupForImageRead) (ScrnInfoPtr pScrn, int bpp, int depth);
+    int ImageReadFlags;
+
+    unsigned char *ImageReadBase;
+    int ImageReadRange;
+
+    void (*SubsequentImageReadRect) (ScrnInfoPtr pScrn,
+                                     int x, int y, int w, int h);
+
+   /***************** Mid Level *****************/
+    void (*ScreenToScreenBitBlt) (ScrnInfoPtr pScrn,
+                                  int nbox,
+                                  DDXPointPtr pptSrc,
+                                  BoxPtr pbox,
+                                  int xdir, int ydir,
+                                  int alu, unsigned int planmask);
+    int ScreenToScreenBitBltFlags;
+
+    void (*WriteBitmap) (ScrnInfoPtr pScrn,
+                         int x, int y, int w, int h,
+                         unsigned char *src,
+                         int srcwidth,
+                         int skipleft,
+                         int fg, int bg, int rop, unsigned int planemask);
+    int WriteBitmapFlags;
+
+    void (*FillSolidRects) (ScrnInfoPtr pScrn,
+                            int fg, int rop,
+                            unsigned int planemask, int nBox, BoxPtr pBox);
+    int FillSolidRectsFlags;
+
+    void (*FillMono8x8PatternRects) (ScrnInfoPtr pScrn,
+                                     int fg, int bg, int rop,
+                                     unsigned int planemask,
+                                     int nBox,
+                                     BoxPtr pBox,
+                                     int pat0, int pat1, int xorg, int yorg);
+    int FillMono8x8PatternRectsFlags;
+
+    void (*FillColor8x8PatternRects) (ScrnInfoPtr pScrn,
+                                      int rop,
+                                      unsigned int planemask,
+                                      int nBox,
+                                      BoxPtr pBox,
+                                      int xorg, int yorg,
+                                      XAACacheInfoPtr pCache);
+    int FillColor8x8PatternRectsFlags;
+
+    void (*FillCacheBltRects) (ScrnInfoPtr pScrn,
+                               int rop,
+                               unsigned int planemask,
+                               int nBox,
+                               BoxPtr pBox,
+                               int xorg, int yorg, XAACacheInfoPtr pCache);
+    int FillCacheBltRectsFlags;
+
+    void (*FillColorExpandRects) (ScrnInfoPtr pScrn,
+                                  int fg, int bg, int rop,
+                                  unsigned int planemask,
+                                  int nBox,
+                                  BoxPtr pBox,
+                                  int xorg, int yorg, PixmapPtr pPix);
+    int FillColorExpandRectsFlags;
+
+    void (*FillCacheExpandRects) (ScrnInfoPtr pScrn,
+                                  int fg, int bg, int rop,
+                                  unsigned int planemask,
+                                  int nBox,
+                                  BoxPtr pBox,
+                                  int xorg, int yorg, PixmapPtr pPix);
+    int FillCacheExpandRectsFlags;
+
+    void (*FillImageWriteRects) (ScrnInfoPtr pScrn,
+                                 int rop,
+                                 unsigned int planemask,
+                                 int nBox,
+                                 BoxPtr pBox,
+                                 int xorg, int yorg, PixmapPtr pPix);
+    int FillImageWriteRectsFlags;
+
+    void (*FillSolidSpans) (ScrnInfoPtr pScrn,
+                            int fg, int rop,
+                            unsigned int planemask,
+                            int n,
+                            DDXPointPtr points, int *widths, int fSorted);
+    int FillSolidSpansFlags;
+
+    void (*FillMono8x8PatternSpans) (ScrnInfoPtr pScrn,
+                                     int fg, int bg, int rop,
+                                     unsigned int planemask,
+                                     int n,
+                                     DDXPointPtr points,
+                                     int *widths,
+                                     int fSorted,
+                                     int pat0, int pat1, int xorg, int yorg);
+    int FillMono8x8PatternSpansFlags;
+
+    void (*FillColor8x8PatternSpans) (ScrnInfoPtr pScrn,
+                                      int rop,
+                                      unsigned int planemask,
+                                      int n,
+                                      DDXPointPtr points,
+                                      int *widths,
+                                      int fSorted,
+                                      XAACacheInfoPtr pCache,
+                                      int xorg, int yorg);
+    int FillColor8x8PatternSpansFlags;
+
+    void (*FillCacheBltSpans) (ScrnInfoPtr pScrn,
+                               int rop,
+                               unsigned int planemask,
+                               int n,
+                               DDXPointPtr points,
+                               int *widths,
+                               int fSorted,
+                               XAACacheInfoPtr pCache, int xorg, int yorg);
+    int FillCacheBltSpansFlags;
+
+    void (*FillColorExpandSpans) (ScrnInfoPtr pScrn,
+                                  int fg, int bg, int rop,
+                                  unsigned int planemask,
+                                  int n,
+                                  DDXPointPtr points,
+                                  int *widths,
+                                  int fSorted,
+                                  int xorg, int yorg, PixmapPtr pPix);
+    int FillColorExpandSpansFlags;
+
+    void (*FillCacheExpandSpans) (ScrnInfoPtr pScrn,
+                                  int fg, int bg, int rop,
+                                  unsigned int planemask,
+                                  int n,
+                                  DDXPointPtr ppt,
+                                  int *pwidth,
+                                  int fSorted,
+                                  int xorg, int yorg, PixmapPtr pPix);
+    int FillCacheExpandSpansFlags;
+
+    void (*TEGlyphRenderer) (ScrnInfoPtr pScrn,
+                             int x, int y, int w, int h, int skipleft,
+                             int startline, unsigned int **glyphs,
+                             int glyphWidth, int fg, int bg, int rop,
+                             unsigned planemask);
+    int TEGlyphRendererFlags;
+
+    void (*NonTEGlyphRenderer) (ScrnInfoPtr pScrn,
+                                int x, int y, int n,
+                                NonTEGlyphPtr glyphs,
+                                BoxPtr pbox,
+                                int fg, int rop, unsigned int planemask);
+    int NonTEGlyphRendererFlags;
+
+    void (*WritePixmap) (ScrnInfoPtr pScrn,
+                         int x, int y, int w, int h,
+                         unsigned char *src,
+                         int srcwidth,
+                         int rop,
+                         unsigned int planemask,
+                         int transparency_color, int bpp, int depth);
+    int WritePixmapFlags;
+
+    void (*ReadPixmap) (ScrnInfoPtr pScrn,
+                        int x, int y, int w, int h,
+                        unsigned char *dst, int dstwidth, int bpp, int depth);
+    int ReadPixmapFlags;
+
+   /***************** GC Level *****************/
+    RegionPtr (*CopyArea) (DrawablePtr pSrcDrawable,
+                           DrawablePtr pDstDrawable,
+                           GC * pGC,
+                           int srcx, int srcy,
+                           int width, int height, int dstx, int dsty);
+    int CopyAreaFlags;
+
+    RegionPtr (*CopyPlane) (DrawablePtr pSrc,
+                            DrawablePtr pDst,
+                            GCPtr pGC,
+                            int srcx, int srcy,
+                            int width, int height,
+                            int dstx, int dsty, unsigned long bitPlane);
+    int CopyPlaneFlags;
+
+    void (*PushPixelsSolid) (GCPtr pGC,
+                             PixmapPtr pBitMap,
+                             DrawablePtr pDrawable,
+                             int dx, int dy, int xOrg, int yOrg);
+    int PushPixelsFlags;
+
+   /** PolyFillRect **/
+
+    void (*PolyFillRectSolid) (DrawablePtr pDraw,
+                               GCPtr pGC, int nrectFill, xRectangle *prectInit);
+    int PolyFillRectSolidFlags;
+
+    void (*PolyFillRectStippled) (DrawablePtr pDraw,
+                                  GCPtr pGC,
+                                  int nrectFill, xRectangle *prectInit);
+    int PolyFillRectStippledFlags;
+
+    void (*PolyFillRectOpaqueStippled) (DrawablePtr pDraw,
+                                        GCPtr pGC,
+                                        int nrectFill, xRectangle *prectInit);
+    int PolyFillRectOpaqueStippledFlags;
+
+    void (*PolyFillRectTiled) (DrawablePtr pDraw,
+                               GCPtr pGC, int nrectFill, xRectangle *prectInit);
+    int PolyFillRectTiledFlags;
+
+   /** FillSpans **/
+
+    void (*FillSpansSolid) (DrawablePtr pDraw,
+                            GCPtr pGC,
+                            int nInit,
+                            DDXPointPtr ppt, int *pwidth, int fSorted);
+    int FillSpansSolidFlags;
+
+    void (*FillSpansStippled) (DrawablePtr pDraw,
+                               GCPtr pGC,
+                               int nInit,
+                               DDXPointPtr ppt, int *pwidth, int fSorted);
+    int FillSpansStippledFlags;
+
+    void (*FillSpansOpaqueStippled) (DrawablePtr pDraw,
+                                     GCPtr pGC,
+                                     int nInit,
+                                     DDXPointPtr ppt, int *pwidth, int fSorted);
+    int FillSpansOpaqueStippledFlags;
+
+    void (*FillSpansTiled) (DrawablePtr pDraw,
+                            GCPtr pGC,
+                            int nInit,
+                            DDXPointPtr ppt, int *pwidth, int fSorted);
+    int FillSpansTiledFlags;
+
+    int (*PolyText8TE) (DrawablePtr pDraw,
+                        GCPtr pGC, int x, int y, int count, char *chars);
+    int PolyText8TEFlags;
+
+    int (*PolyText16TE) (DrawablePtr pDraw,
+                         GCPtr pGC,
+                         int x, int y, int count, unsigned short *chars);
+    int PolyText16TEFlags;
+
+    void (*ImageText8TE) (DrawablePtr pDraw,
+                          GCPtr pGC, int x, int y, int count, char *chars);
+    int ImageText8TEFlags;
+
+    void (*ImageText16TE) (DrawablePtr pDraw,
+                           GCPtr pGC,
+                           int x, int y, int count, unsigned short *chars);
+    int ImageText16TEFlags;
+
+    void (*ImageGlyphBltTE) (DrawablePtr pDrawable,
+                             GCPtr pGC,
+                             int xInit, int yInit,
+                             unsigned int nglyph,
+                             CharInfoPtr * ppci, void *pglyphBase);
+    int ImageGlyphBltTEFlags;
+
+    void (*PolyGlyphBltTE) (DrawablePtr pDrawable,
+                            GCPtr pGC,
+                            int xInit, int yInit,
+                            unsigned int nglyph,
+                            CharInfoPtr * ppci, void *pglyphBase);
+    int PolyGlyphBltTEFlags;
+
+    int (*PolyText8NonTE) (DrawablePtr pDraw,
+                           GCPtr pGC, int x, int y, int count, char *chars);
+    int PolyText8NonTEFlags;
+
+    int (*PolyText16NonTE) (DrawablePtr pDraw,
+                            GCPtr pGC,
+                            int x, int y, int count, unsigned short *chars);
+    int PolyText16NonTEFlags;
+
+    void (*ImageText8NonTE) (DrawablePtr pDraw,
+                             GCPtr pGC, int x, int y, int count, char *chars);
+    int ImageText8NonTEFlags;
+
+    void (*ImageText16NonTE) (DrawablePtr pDraw,
+                              GCPtr pGC,
+                              int x, int y, int count, unsigned short *chars);
+    int ImageText16NonTEFlags;
+
+    void (*ImageGlyphBltNonTE) (DrawablePtr pDrawable,
+                                GCPtr pGC,
+                                int xInit, int yInit,
+                                unsigned int nglyph,
+                                CharInfoPtr * ppci, void *pglyphBase);
+    int ImageGlyphBltNonTEFlags;
+
+    void (*PolyGlyphBltNonTE) (DrawablePtr pDrawable,
+                               GCPtr pGC,
+                               int xInit, int yInit,
+                               unsigned int nglyph,
+                               CharInfoPtr * ppci, void *pglyphBase);
+    int PolyGlyphBltNonTEFlags;
+
+    void (*PolyRectangleThinSolid) (DrawablePtr pDrawable,
+                                    GCPtr pGC,
+                                    int nRectsInit, xRectangle *pRectsInit);
+    int PolyRectangleThinSolidFlags;
+
+    void (*PolylinesWideSolid) (DrawablePtr pDrawable,
+                                GCPtr pGC, int mode, int npt, DDXPointPtr pPts);
+    int PolylinesWideSolidFlags;
+
+    void (*PolylinesThinSolid) (DrawablePtr pDrawable,
+                                GCPtr pGC, int mode, int npt, DDXPointPtr pPts);
+    int PolylinesThinSolidFlags;
+
+    void (*PolySegmentThinSolid) (DrawablePtr pDrawable,
+                                  GCPtr pGC, int nseg, xSegment * pSeg);
+    int PolySegmentThinSolidFlags;
+
+    void (*PolylinesThinDashed) (DrawablePtr pDrawable,
+                                 GCPtr pGC,
+                                 int mode, int npt, DDXPointPtr pPts);
+    int PolylinesThinDashedFlags;
+
+    void (*PolySegmentThinDashed) (DrawablePtr pDrawable,
+                                   GCPtr pGC, int nseg, xSegment * pSeg);
+    int PolySegmentThinDashedFlags;
+
+    void (*FillPolygonSolid) (DrawablePtr pDrawable,
+                              GCPtr pGC,
+                              int shape,
+                              int mode, int count, DDXPointPtr ptsIn);
+    int FillPolygonSolidFlags;
+
+    void (*FillPolygonStippled) (DrawablePtr pDrawable,
+                                 GCPtr pGC,
+                                 int shape,
+                                 int mode, int count, DDXPointPtr ptsIn);
+    int FillPolygonStippledFlags;
+
+    void (*FillPolygonOpaqueStippled) (DrawablePtr pDrawable,
+                                       GCPtr pGC,
+                                       int shape,
+                                       int mode, int count, DDXPointPtr ptsIn);
+    int FillPolygonOpaqueStippledFlags;
+
+    void (*FillPolygonTiled) (DrawablePtr pDrawable,
+                              GCPtr pGC,
+                              int shape,
+                              int mode, int count, DDXPointPtr ptsIn);
+    int FillPolygonTiledFlags;
+
+    void (*PolyFillArcSolid) (DrawablePtr pDraw,
+                              GCPtr pGC, int narcs, xArc * parcs);
+    int PolyFillArcSolidFlags;
+
+    void (*PutImage) (DrawablePtr pDraw,
+                      GCPtr pGC,
+                      int depth,
+                      int x,
+                      int y,
+                      int w, int h, int leftPad, int format, char *pImage);
+    int PutImageFlags;
+
+    /* Validation masks */
+
+    unsigned long FillSpansMask;
+    ValidateGCProcPtr ValidateFillSpans;
+    unsigned long SetSpansMask;
+    ValidateGCProcPtr ValidateSetSpans;
+    unsigned long PutImageMask;
+    ValidateGCProcPtr ValidatePutImage;
+    unsigned long CopyAreaMask;
+    ValidateGCProcPtr ValidateCopyArea;
+    unsigned long CopyPlaneMask;
+    ValidateGCProcPtr ValidateCopyPlane;
+    unsigned long PolyPointMask;
+    ValidateGCProcPtr ValidatePolyPoint;
+    unsigned long PolylinesMask;
+    ValidateGCProcPtr ValidatePolylines;
+    unsigned long PolySegmentMask;
+    ValidateGCProcPtr ValidatePolySegment;
+    unsigned long PolyRectangleMask;
+    ValidateGCProcPtr ValidatePolyRectangle;
+    unsigned long PolyArcMask;
+    ValidateGCProcPtr ValidatePolyArc;
+    unsigned long FillPolygonMask;
+    ValidateGCProcPtr ValidateFillPolygon;
+    unsigned long PolyFillRectMask;
+    ValidateGCProcPtr ValidatePolyFillRect;
+    unsigned long PolyFillArcMask;
+    ValidateGCProcPtr ValidatePolyFillArc;
+    unsigned long PolyText8Mask;
+    ValidateGCProcPtr ValidatePolyText8;
+    unsigned long PolyText16Mask;
+    ValidateGCProcPtr ValidatePolyText16;
+    unsigned long ImageText8Mask;
+    ValidateGCProcPtr ValidateImageText8;
+    unsigned long ImageText16Mask;
+    ValidateGCProcPtr ValidateImageText16;
+    unsigned long PolyGlyphBltMask;
+    ValidateGCProcPtr ValidatePolyGlyphBlt;
+    unsigned long ImageGlyphBltMask;
+    ValidateGCProcPtr ValidateImageGlyphBlt;
+    unsigned long PushPixelsMask;
+    ValidateGCProcPtr ValidatePushPixels;
+
+    void (*ComputeDash) (GCPtr pGC);
+
+    /* Pixmap Cache */
+
+    int PixmapCacheFlags;
+    Bool UsingPixmapCache;
+    Bool CanDoMono8x8;
+    Bool CanDoColor8x8;
+
+    void (*InitPixmapCache) (ScreenPtr pScreen, RegionPtr areas, void *data);
+    void (*ClosePixmapCache) (ScreenPtr pScreen);
+
+    int (*StippledFillChooser) (GCPtr pGC);
+    int (*OpaqueStippledFillChooser) (GCPtr pGC);
+    int (*TiledFillChooser) (GCPtr pGC);
+
+    int CachePixelGranularity;
+    int MaxCacheableTileWidth;
+    int MaxCacheableTileHeight;
+    int MaxCacheableStippleWidth;
+    int MaxCacheableStippleHeight;
+
+     XAACacheInfoPtr(*CacheTile) (ScrnInfoPtr Scrn, PixmapPtr pPix);
+     XAACacheInfoPtr(*CacheStipple) (ScrnInfoPtr Scrn, PixmapPtr pPix,
+                                     int fg, int bg);
+     XAACacheInfoPtr(*CacheMonoStipple) (ScrnInfoPtr Scrn, PixmapPtr pPix);
+     XAACacheInfoPtr(*CacheMono8x8Pattern) (ScrnInfoPtr Scrn, int pat0,
+                                            int pat1);
+     XAACacheInfoPtr(*CacheColor8x8Pattern) (ScrnInfoPtr Scrn, PixmapPtr pPix,
+                                             int fg, int bg);
+
+    int MonoPatternPitch;
+    int CacheWidthMono8x8Pattern;
+    int CacheHeightMono8x8Pattern;
+
+    int ColorPatternPitch;
+    int CacheWidthColor8x8Pattern;
+    int CacheHeightColor8x8Pattern;
+
+    int CacheColorExpandDensity;
+
+    void (*WriteBitmapToCache) (ScrnInfoPtr pScrn,
+                                int x, int y, int w, int h,
+                                unsigned char *src,
+                                int srcwidth, int fg, int bg);
+    void (*WritePixmapToCache) (ScrnInfoPtr pScrn,
+                                int x, int y, int w, int h,
+                                unsigned char *src,
+                                int srcwidth, int bpp, int depth);
+    void (*WriteMono8x8PatternToCache) (ScrnInfoPtr pScrn,
+                                        XAACacheInfoPtr pCache);
+    void (*WriteColor8x8PatternToCache) (ScrnInfoPtr pScrn,
+                                         PixmapPtr pPix,
+                                         XAACacheInfoPtr pCache);
+
+    char *PixmapCachePrivate;
+
+    /* Miscellaneous */
+
+    GC ScratchGC;
+    int PreAllocSize;
+    unsigned char *PreAllocMem;
+
+    CharInfoPtr CharInfo[255];
+    NonTEGlyphInfo GlyphInfo[255];
+
+    unsigned int FullPlanemask; /* deprecated */
+
+    PixmapLinkPtr OffscreenPixmaps;
+    int maxOffPixWidth;
+    int maxOffPixHeight;
+
+    XAACacheInfoRec ScratchCacheInfoRec;
+
+    BoxPtr ClipBox;
+
+    Bool NeedToSync;
+
+    char *dgaSaves;
+
+    /* These can be supplied to override the defaults */
+
+    GetImageProcPtr GetImage;
+    GetSpansProcPtr GetSpans;
+    CopyWindowProcPtr CopyWindow;
+
+    unsigned int offscreenDepths;
+    Bool offscreenDepthsInitialized;
+
+    CARD32 FullPlanemasks[32];
+
+    Bool (*Composite) (CARD8 op,
+                       PicturePtr pSrc,
+                       PicturePtr pMask,
+                       PicturePtr pDst,
+                       INT16 xSrc,
+                       INT16 ySrc,
+                       INT16 xMask,
+                       INT16 yMask,
+                       INT16 xDst, INT16 yDst, CARD16 width, CARD16 height);
+
+    Bool (*Glyphs) (CARD8 op,
+                    PicturePtr pSrc,
+                    PicturePtr pDst,
+                    PictFormatPtr maskFormat,
+                    INT16 xSrc,
+                    INT16 ySrc,
+                    int nlist, GlyphListPtr list, GlyphPtr * glyphs);
+
+    /* The old SetupForCPUToScreenAlphaTexture function is no longer used because
+     * it doesn't pass in enough information to write a conforming
+     * implementation.  See SetupForCPUToScreenAlphaTexture2.
+     */
+    Bool (*SetupForCPUToScreenAlphaTexture) (ScrnInfoPtr pScrn,
+                                             int op,
+                                             CARD16 red,
+                                             CARD16 green,
+                                             CARD16 blue,
+                                             CARD16 alpha,
+                                             int alphaType,
+                                             CARD8 *alphaPtr,
+                                             int alphaPitch,
+                                             int width, int height, int flags);
+    void (*SubsequentCPUToScreenAlphaTexture) (ScrnInfoPtr pScrn,
+                                               int dstx,
+                                               int dsty,
+                                               int srcx,
+                                               int srcy, int width, int height);
+    int CPUToScreenAlphaTextureFlags;
+    CARD32 *CPUToScreenAlphaTextureFormats;
+
+    /* The old SetupForCPUToScreenTexture function is no longer used because
+     * it doesn't pass in enough information to write a conforming
+     * implementation.  See SetupForCPUToScreenTexture2.
+     */
+    Bool (*SetupForCPUToScreenTexture) (ScrnInfoPtr pScrn,
+                                        int op,
+                                        int texType,
+                                        CARD8 *texPtr,
+                                        int texPitch,
+                                        int width, int height, int flags);
+    void (*SubsequentCPUToScreenTexture) (ScrnInfoPtr pScrn,
+                                          int dstx,
+                                          int dsty,
+                                          int srcx,
+                                          int srcy, int width, int height);
+    int CPUToScreenTextureFlags;
+    CARD32 *CPUToScreenTextureFormats;
+
+    /* these were added for 4.3.0 */
+    BoxRec SolidLineLimits;
+    BoxRec DashedLineLimits;
+
+    /* These were added for X.Org 6.8.0 */
+    Bool (*SetupForCPUToScreenAlphaTexture2) (ScrnInfoPtr pScrn,
+                                              int op,
+                                              CARD16 red,
+                                              CARD16 green,
+                                              CARD16 blue,
+                                              CARD16 alpha,
+                                              CARD32 maskFormat,
+                                              CARD32 dstFormat,
+                                              CARD8 *alphaPtr,
+                                              int alphaPitch,
+                                              int width, int height, int flags);
+    CARD32 *CPUToScreenAlphaTextureDstFormats;
+
+    Bool (*SetupForCPUToScreenTexture2) (ScrnInfoPtr pScrn,
+                                         int op,
+                                         CARD32 srcFormat,
+                                         CARD32 dstFormat,
+                                         CARD8 *texPtr,
+                                         int texPitch,
+                                         int width, int height, int flags);
+    CARD32 *CPUToScreenTextureDstFormats;
+} XAAInfoRec, *XAAInfoRecPtr;
+
+#define SET_SYNC_FLAG(infoRec)	(infoRec)->NeedToSync = TRUE
+
+extern _X_EXPORT Bool
+ XAAInit(ScreenPtr pScreen, XAAInfoRecPtr infoRec);
+
+extern _X_EXPORT XAAInfoRecPtr XAACreateInfoRec(void);
+
+extern _X_EXPORT void
+ XAADestroyInfoRec(XAAInfoRecPtr infoRec);
+
+typedef void (*DepthChangeFuncPtr) (ScrnInfoPtr pScrn, int depth);
+
+extern _X_EXPORT Bool
+ XAAInitDualFramebufferOverlay(ScreenPtr pScreen, DepthChangeFuncPtr callback);
+
+#endif                          /* _XAA_H */
diff --git a/hw/xfree86/xaa/xaaBitBlt.c b/hw/xfree86/xaa/xaaBitBlt.c
new file mode 100644
index 000000000..f629a469a
--- /dev/null
+++ b/hw/xfree86/xaa/xaaBitBlt.c
@@ -0,0 +1,230 @@
+
+/* 
+   This is a lighter version of cfbBitBlt.  We calculate the boxes
+   when accelerating pixmap->screen and screen->screen copies. 
+   We also pass the GC to the doBitBlt function so that it has access
+   to the fg and bg so CopyPlane can use this. 
+*/
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include "mi.h"
+#include "pixmapstr.h"
+#include "gcstruct.h"
+#include "windowstr.h"
+#include "xaalocal.h"
+
+RegionPtr
+XAABitBlt(DrawablePtr pSrcDrawable,
+          DrawablePtr pDstDrawable,
+          GC * pGC,
+          int srcx, int srcy,
+          int width, int height,
+          int dstx, int dsty,
+          void (*doBitBlt) (DrawablePtr, DrawablePtr, GCPtr, RegionPtr,
+                            DDXPointPtr), unsigned long bitPlane)
+{
+
+    RegionPtr prgnSrcClip = NULL;       /* may be a new region, or just a copy */
+    RegionPtr prgnExposed;
+    Bool freeSrcClip = FALSE;
+    RegionRec rgnDst;
+    DDXPointPtr pptSrc, ppt;
+    DDXPointRec origDest;
+    BoxPtr pbox;
+    BoxRec fastBox;
+    int i, dx, dy, numRects;
+    xRectangle origSource;
+    int fastClip = 0;           /* for fast clipping with pixmap source */
+    int fastExpose = 0;         /* for fast exposures with pixmap source */
+
+    origSource.x = srcx;
+    origSource.y = srcy;
+    origSource.width = width;
+    origSource.height = height;
+    origDest.x = dstx;
+    origDest.y = dsty;
+
+    if (pSrcDrawable->pScreen->SourceValidate) {
+        (*pSrcDrawable->pScreen->SourceValidate) (pSrcDrawable, srcx, srcy,
+                                                  width, height,
+                                                  pGC->subWindowMode);
+    }
+
+    srcx += pSrcDrawable->x;
+    srcy += pSrcDrawable->y;
+
+    /* clip the source */
+    if (pSrcDrawable->type == DRAWABLE_PIXMAP) {
+        if ((pSrcDrawable == pDstDrawable) && (pGC->clientClipType == CT_NONE))
+            prgnSrcClip = pGC->pCompositeClip;
+        else
+            fastClip = 1;
+    }
+    else {                      /* Window */
+        if (pGC->subWindowMode == IncludeInferiors) {
+            if (!((WindowPtr) pSrcDrawable)->parent) {
+                /*
+                 * special case bitblt from root window in
+                 * IncludeInferiors mode; just like from a pixmap
+                 */
+                fastClip = 1;
+            }
+            else if ((pSrcDrawable == pDstDrawable) &&
+                     (pGC->clientClipType == CT_NONE)) {
+                prgnSrcClip = pGC->pCompositeClip;
+            }
+            else {
+                prgnSrcClip = NotClippedByChildren((WindowPtr) pSrcDrawable);
+                freeSrcClip = TRUE;
+            }
+        }
+        else {
+            prgnSrcClip = &((WindowPtr) pSrcDrawable)->clipList;
+        }
+    }
+
+    fastBox.x1 = srcx;
+    fastBox.y1 = srcy;
+    fastBox.x2 = srcx + width;
+    fastBox.y2 = srcy + height;
+
+    /* Don't create a source region if we are doing a fast clip */
+    if (fastClip) {
+        fastExpose = 1;
+        /*
+         * clip the source; if regions extend beyond the source size,
+         * make sure exposure events get sent
+         */
+        if (fastBox.x1 < pSrcDrawable->x) {
+            fastBox.x1 = pSrcDrawable->x;
+            fastExpose = 0;
+        }
+        if (fastBox.y1 < pSrcDrawable->y) {
+            fastBox.y1 = pSrcDrawable->y;
+            fastExpose = 0;
+        }
+        if (fastBox.x2 > pSrcDrawable->x + (int) pSrcDrawable->width) {
+            fastBox.x2 = pSrcDrawable->x + (int) pSrcDrawable->width;
+            fastExpose = 0;
+        }
+        if (fastBox.y2 > pSrcDrawable->y + (int) pSrcDrawable->height) {
+            fastBox.y2 = pSrcDrawable->y + (int) pSrcDrawable->height;
+            fastExpose = 0;
+        }
+    }
+    else {
+        RegionInit(&rgnDst, &fastBox, 1);
+        RegionIntersect(&rgnDst, &rgnDst, prgnSrcClip);
+    }
+
+    dstx += pDstDrawable->x;
+    dsty += pDstDrawable->y;
+
+    if (pDstDrawable->type == DRAWABLE_WINDOW) {
+        if (!((WindowPtr) pDstDrawable)->realized) {
+            if (!fastClip)
+                RegionUninit(&rgnDst);
+            if (freeSrcClip)
+                RegionDestroy(prgnSrcClip);
+            return NULL;
+        }
+    }
+
+    dx = srcx - dstx;
+    dy = srcy - dsty;
+
+    /* Translate and clip the dst to the destination composite clip */
+    if (fastClip) {
+        RegionPtr cclip;
+
+        /* Translate the region directly */
+        fastBox.x1 -= dx;
+        fastBox.x2 -= dx;
+        fastBox.y1 -= dy;
+        fastBox.y2 -= dy;
+
+        /* If the destination composite clip is one rectangle we can
+           do the clip directly.  Otherwise we have to create a full
+           blown region and call intersect */
+
+        cclip = pGC->pCompositeClip;
+        if (RegionNumRects(cclip) == 1) {
+            BoxPtr pBox = RegionRects(cclip);
+
+            if (fastBox.x1 < pBox->x1)
+                fastBox.x1 = pBox->x1;
+            if (fastBox.x2 > pBox->x2)
+                fastBox.x2 = pBox->x2;
+            if (fastBox.y1 < pBox->y1)
+                fastBox.y1 = pBox->y1;
+            if (fastBox.y2 > pBox->y2)
+                fastBox.y2 = pBox->y2;
+
+            /* Check to see if the region is empty */
+            if (fastBox.x1 >= fastBox.x2 || fastBox.y1 >= fastBox.y2) {
+                RegionNull(&rgnDst);
+            }
+            else {
+                RegionInit(&rgnDst, &fastBox, 1);
+            }
+        }
+        else {
+            /* We must turn off fastClip now, since we must create
+               a full blown region.  It is intersected with the
+               composite clip below. */
+            fastClip = 0;
+            RegionInit(&rgnDst, &fastBox, 1);
+        }
+    }
+    else {
+        RegionTranslate(&rgnDst, -dx, -dy);
+    }
+
+    if (!fastClip) {
+        RegionIntersect(&rgnDst, &rgnDst, pGC->pCompositeClip);
+    }
+
+    /* Do bit blitting */
+    numRects = RegionNumRects(&rgnDst);
+    if (numRects && width && height) {
+        if (!(pptSrc = (DDXPointPtr) malloc(numRects * sizeof(DDXPointRec)))) {
+            RegionUninit(&rgnDst);
+            if (freeSrcClip)
+                RegionDestroy(prgnSrcClip);
+            return NULL;
+        }
+        pbox = RegionRects(&rgnDst);
+        ppt = pptSrc;
+        for (i = numRects; --i >= 0; pbox++, ppt++) {
+            ppt->x = pbox->x1 + dx;
+            ppt->y = pbox->y1 + dy;
+        }
+
+        (*doBitBlt) (pSrcDrawable, pDstDrawable, pGC, &rgnDst, pptSrc);
+        free(pptSrc);
+    }
+
+    prgnExposed = NULL;
+    if (pGC->fExpose) {
+        /* Pixmap sources generate a NoExposed (we return NULL to do this) */
+        if (!fastExpose)
+            prgnExposed = miHandleExposures(pSrcDrawable, pDstDrawable, pGC,
+                                            origSource.x, origSource.y,
+                                            (int) origSource.width,
+                                            (int) origSource.height,
+                                            origDest.x, origDest.y);
+    }
+
+    RegionUninit(&rgnDst);
+    if (freeSrcClip)
+        RegionDestroy(prgnSrcClip);
+    return prgnExposed;
+}
diff --git a/hw/xfree86/xaa/xaaBitOrder.c b/hw/xfree86/xaa/xaaBitOrder.c
new file mode 100644
index 000000000..3d9b980e1
--- /dev/null
+++ b/hw/xfree86/xaa/xaaBitOrder.c
@@ -0,0 +1,16 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <X11/Xmd.h>
+#include "xaalocal.h"
+
+CARD32
+XAAReverseBitOrder(CARD32 v)
+{
+    return (((0x01010101 & v) << 7) | ((0x02020202 & v) << 5) |
+            ((0x04040404 & v) << 3) | ((0x08080808 & v) << 1) |
+            ((0x10101010 & v) >> 1) | ((0x20202020 & v) >> 3) |
+            ((0x40404040 & v) >> 5) | ((0x80808080 & v) >> 7));
+}
diff --git a/hw/xfree86/xaa/xaaBitmap.c b/hw/xfree86/xaa/xaaBitmap.c
new file mode 100644
index 000000000..45d5a09be
--- /dev/null
+++ b/hw/xfree86/xaa/xaaBitmap.c
@@ -0,0 +1,477 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "xaa.h"
+#include "xaalocal.h"
+#include "xaacexp.h"
+#include "xf86.h"
+
+/********** byte swapping ***************/
+
+#ifdef FIXEDBASE
+#define DEST(i)	*dest
+#define RETURN(i)	return(dest)
+#else
+#define DEST(i)	dest[i]
+#define RETURN(i)	return(dest + i)
+#endif
+
+#ifdef MSBFIRST
+#define SOURCE(i)	SWAP_BITS_IN_BYTES(src[i])
+#else
+#define SOURCE(i)	src[i]
+#endif
+
+typedef CARD32 *(*BitmapScanlineProcPtr) (CARD32 *, CARD32 *, int, int);
+
+#ifdef TRIPLE_BITS
+static CARD32 *
+BitmapScanline(CARD32 *src, CARD32 *base, int count, int skipleft)
+{
+    CARD32 bits;
+
+    while (count >= 3) {
+        bits = *src;
+        WRITE_BITS3(bits);
+        src++;
+        count -= 3;
+    }
+    if (count == 2) {
+        bits = *src;
+        WRITE_BITS2(bits);
+    }
+    else if (count == 1) {
+        bits = *src;
+        WRITE_BITS1(bits);
+    }
+
+    return base;
+}
+
+static CARD32 *
+BitmapScanline_Inverted(CARD32 *src, CARD32 *base, int count, int skipleft)
+{
+    CARD32 bits;
+
+    while (count >= 3) {
+        bits = ~(*src);
+        WRITE_BITS3(bits);
+        src++;
+        count -= 3;
+    }
+    if (count == 2) {
+        bits = ~(*src);
+        WRITE_BITS2(bits);
+    }
+    else if (count == 1) {
+        bits = ~(*src);
+        WRITE_BITS1(bits);
+    }
+
+    return base;
+}
+
+static CARD32 *
+BitmapScanline_Shifted(CARD32 *src, CARD32 *base, int count, int skipleft)
+{
+    CARD32 bits;
+
+    while (count >= 3) {
+        bits = SHIFT_R(*src, skipleft) | SHIFT_L(*(src + 1), (32 - skipleft));
+        WRITE_BITS3(bits);
+        src++;
+        count -= 3;
+    }
+    if (count == 2) {
+        bits = SHIFT_R(*src, skipleft) | SHIFT_L(*(src + 1), (32 - skipleft));
+        WRITE_BITS2(bits);
+    }
+    else if (count == 1) {
+        bits = SHIFT_R(*src, skipleft) | SHIFT_L(*(src + 1), (32 - skipleft));
+        WRITE_BITS1(bits);
+    }
+
+    return base;
+}
+
+static CARD32 *
+BitmapScanline_Shifted_Inverted(CARD32 *src, CARD32 *base,
+                                int count, int skipleft)
+{
+    CARD32 bits;
+
+    while (count >= 3) {
+        bits =
+            ~(SHIFT_R(*src, skipleft) | SHIFT_L(*(src + 1), (32 - skipleft)));
+        WRITE_BITS3(bits);
+        src++;
+        count -= 3;
+    }
+    if (count == 2) {
+        bits =
+            ~(SHIFT_R(*src, skipleft) | SHIFT_L(*(src + 1), (32 - skipleft)));
+        WRITE_BITS2(bits);
+    }
+    else if (count == 1) {
+        bits =
+            ~(SHIFT_R(*src, skipleft) | SHIFT_L(*(src + 1), (32 - skipleft)));
+        WRITE_BITS1(bits);
+    }
+
+    return base;
+}
+
+#define BitmapScanline_Shifted_Careful BitmapScanline_Shifted
+#define BitmapScanline_Shifted_Inverted_Careful BitmapScanline_Shifted_Inverted
+
+#else
+static CARD32 *
+BitmapScanline(CARD32 *src, CARD32 *dest, int count, int skipleft)
+{
+    while (count >= 4) {
+        DEST(0) = SOURCE(0);
+        DEST(1) = SOURCE(1);
+        DEST(2) = SOURCE(2);
+        DEST(3) = SOURCE(3);
+        count -= 4;
+        src += 4;
+#ifndef FIXEDBASE
+        dest += 4;
+#endif
+    }
+
+    if (!count)
+        return dest;
+    DEST(0) = SOURCE(0);
+    if (count == 1)
+        RETURN(1);
+    DEST(1) = SOURCE(1);
+    if (count == 2)
+        RETURN(2);
+    DEST(2) = SOURCE(2);
+    RETURN(3);
+}
+
+static CARD32 *
+BitmapScanline_Inverted(CARD32 *src, CARD32 *dest, int count, int skipleft)
+{
+    while (count >= 4) {
+        DEST(0) = ~SOURCE(0);
+        DEST(1) = ~SOURCE(1);
+        DEST(2) = ~SOURCE(2);
+        DEST(3) = ~SOURCE(3);
+        count -= 4;
+        src += 4;
+#ifndef FIXEDBASE
+        dest += 4;
+#endif
+    }
+
+    if (!count)
+        return dest;
+    DEST(0) = ~SOURCE(0);
+    if (count == 1)
+        RETURN(1);
+    DEST(1) = ~SOURCE(1);
+    if (count == 2)
+        RETURN(2);
+    DEST(2) = ~SOURCE(2);
+    RETURN(3);
+}
+
+static CARD32 *
+BitmapScanline_Shifted(CARD32 *bits, CARD32 *base, int count, int skipleft)
+{
+    while (count--) {
+        register CARD32 tmp = SHIFT_R(*bits, skipleft) |
+            SHIFT_L(*(bits + 1), (32 - skipleft));
+        WRITE_BITS(tmp);
+        bits++;
+    }
+    return base;
+}
+
+static CARD32 *
+BitmapScanline_Shifted_Inverted(CARD32 *bits, CARD32 *base,
+                                int count, int skipleft)
+{
+    while (count--) {
+        register CARD32 tmp = ~(SHIFT_R(*bits, skipleft) |
+                                SHIFT_L(*(bits + 1), (32 - skipleft)));
+        WRITE_BITS(tmp);
+        bits++;
+    }
+    return base;
+}
+
+static CARD32 *
+BitmapScanline_Shifted_Careful(CARD32 *bits, CARD32 *base,
+                               int count, int skipleft)
+{
+    register CARD32 tmp;
+
+    while (--count) {
+        tmp = SHIFT_R(*bits, skipleft) | SHIFT_L(*(bits + 1), (32 - skipleft));
+        WRITE_BITS(tmp);
+        bits++;
+    }
+    tmp = SHIFT_R(*bits, skipleft);
+    WRITE_BITS(tmp);
+
+    return base;
+}
+
+static CARD32 *
+BitmapScanline_Shifted_Inverted_Careful(CARD32 *bits, CARD32 *base,
+                                        int count, int skipleft)
+{
+    register CARD32 tmp;
+
+    while (--count) {
+        tmp =
+            ~(SHIFT_R(*bits, skipleft) | SHIFT_L(*(bits + 1), (32 - skipleft)));
+        WRITE_BITS(tmp);
+        bits++;
+    }
+    tmp = ~(SHIFT_R(*bits, skipleft));
+    WRITE_BITS(tmp);
+    return base;
+}
+
+#endif
+
+/*  
+    When the accelerator is TRANSPARENCY_ONLY, WriteBitmap can do
+    the fill in two passes, inverting the source on the second pass.  
+    For GXcopy we can fill the backing rectangle as a solid rect and
+    avoid the invert.
+*/
+
+void
+#ifdef TRIPLE_BITS
+ EXPNAME(XAAWriteBitmapColorExpand3) (
+#else
+ EXPNAME(XAAWriteBitmapColorExpand) (
+#endif
+                                        ScrnInfoPtr pScrn,
+                                        int x, int y, int w, int H,
+                                        unsigned char *src,
+                                        int srcwidth,
+                                        int skipleft,
+                                        int fg, int bg,
+                                        int rop, unsigned int planemask) {
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    CARD32 *base;
+    unsigned char *srcp = src;
+    int SecondPassColor = -1;
+    int shift = 0, dwords;
+    BitmapScanlineProcPtr firstFunc;
+    BitmapScanlineProcPtr secondFunc;
+    int flag;
+    int h = H;
+
+#ifdef TRIPLE_BITS
+    if ((bg != -1) &&
+        ((infoRec->CPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY) ||
+         ((infoRec->CPUToScreenColorExpandFillFlags & RGB_EQUAL) &&
+          (!CHECK_RGB_EQUAL(bg))))) {
+#else
+    if ((bg != -1) &&
+        (infoRec->CPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY)) {
+#endif
+        if ((rop == GXcopy) && infoRec->SetupForSolidFill) {
+            (*infoRec->SetupForSolidFill) (pScrn, bg, rop, planemask);
+            (*infoRec->SubsequentSolidFillRect) (pScrn, x, y, w, h);
+        }
+        else
+            SecondPassColor = bg;
+        bg = -1;
+    }
+
+#ifdef TRIPLE_BITS
+    if (skipleft) {
+#else
+    if (skipleft &&
+        (!(infoRec->CPUToScreenColorExpandFillFlags & LEFT_EDGE_CLIPPING) ||
+         (!(infoRec->
+            CPUToScreenColorExpandFillFlags & LEFT_EDGE_CLIPPING_NEGATIVE_X) &&
+          (skipleft > x)))) {
+#endif
+        if ((skipleft + ((w + 31) & ~31)) > ((skipleft + w + 31) & ~31)) {
+            /* don't read past the end */
+            firstFunc = BitmapScanline_Shifted_Careful;
+            secondFunc = BitmapScanline_Shifted_Inverted_Careful;
+        }
+        else {
+            firstFunc = BitmapScanline_Shifted;
+            secondFunc = BitmapScanline_Shifted_Inverted;
+        }
+        shift = skipleft;
+        skipleft = 0;
+    }
+    else {
+        firstFunc = BitmapScanline;
+        secondFunc = BitmapScanline_Inverted;
+        w += skipleft;
+        x -= skipleft;
+    }
+
+#ifdef TRIPLE_BITS
+    dwords = (3 * w + 31) >> 5;
+#else
+    dwords = (w + 31) >> 5;
+#endif
+
+ SECOND_PASS:
+
+    flag = (infoRec->CPUToScreenColorExpandFillFlags
+            & CPU_TRANSFER_PAD_QWORD) && ((dwords * h) & 0x01);
+    (*infoRec->SetupForCPUToScreenColorExpandFill) (pScrn, fg, bg, rop,
+                                                    planemask);
+    (*infoRec->SubsequentCPUToScreenColorExpandFill) (pScrn, x, y, w, h,
+                                                      skipleft);
+
+    base = (CARD32 *) infoRec->ColorExpandBase;
+
+#ifndef FIXEDBASE
+    if ((dwords * h) <= infoRec->ColorExpandRange)
+        while (h--) {
+            base = (*firstFunc) ((CARD32 *) srcp, base, dwords, shift);
+            srcp += srcwidth;
+        }
+    else
+#endif
+        while (h--) {
+            (*firstFunc) ((CARD32 *) srcp, base, dwords, shift);
+            srcp += srcwidth;
+        }
+
+    if (flag) {
+        base = (CARD32 *) infoRec->ColorExpandBase;
+        base[0] = 0x00000000;
+    }
+
+    if (SecondPassColor != -1) {
+        h = H;                  /* Reset height */
+        fg = SecondPassColor;
+        SecondPassColor = -1;
+        firstFunc = secondFunc;
+        srcp = src;
+        goto SECOND_PASS;
+    }
+
+    if (infoRec->CPUToScreenColorExpandFillFlags & SYNC_AFTER_COLOR_EXPAND)
+        (*infoRec->Sync) (pScrn);
+    else
+        SET_SYNC_FLAG(infoRec);
+}
+
+#ifndef FIXEDBASE
+
+void
+#ifdef TRIPLE_BITS
+ EXPNAME(XAAWriteBitmapScanlineColorExpand3) (
+#else
+ EXPNAME(XAAWriteBitmapScanlineColorExpand) (
+#endif
+                                                ScrnInfoPtr pScrn,
+                                                int x, int y, int w, int h,
+                                                unsigned char *src,
+                                                int srcwidth,
+                                                int skipleft,
+                                                int fg, int bg,
+                                                int rop,
+                                                unsigned int planemask) {
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    CARD32 *base;
+    unsigned char *srcp = src;
+    int SecondPassColor = -1;
+    int shift = 0, dwords, bufferNo;
+    BitmapScanlineProcPtr firstFunc;
+    BitmapScanlineProcPtr secondFunc;
+
+#ifdef TRIPLE_BITS
+    if ((bg != -1) &&
+        ((infoRec->ScanlineCPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY)
+         || ((infoRec->ScanlineCPUToScreenColorExpandFillFlags & RGB_EQUAL) &&
+             (!CHECK_RGB_EQUAL(bg))))) {
+#else
+    if ((bg != -1) &&
+        (infoRec->
+         ScanlineCPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY)) {
+#endif
+        if ((rop == GXcopy) && infoRec->SetupForSolidFill) {
+            (*infoRec->SetupForSolidFill) (pScrn, bg, rop, planemask);
+            (*infoRec->SubsequentSolidFillRect) (pScrn, x, y, w, h);
+        }
+        else
+            SecondPassColor = bg;
+        bg = -1;
+    }
+
+#ifdef TRIPLE_BITS
+    if (skipleft) {
+#else
+    if (skipleft &&
+        (!(infoRec->ScanlineCPUToScreenColorExpandFillFlags &
+           LEFT_EDGE_CLIPPING) ||
+         (!(infoRec->ScanlineCPUToScreenColorExpandFillFlags &
+            LEFT_EDGE_CLIPPING_NEGATIVE_X) && (skipleft > x)))) {
+#endif
+        if ((skipleft + ((w + 31) & ~31)) > ((skipleft + w + 31) & ~31)) {
+            /* don't read past the end */
+            firstFunc = BitmapScanline_Shifted_Careful;
+            secondFunc = BitmapScanline_Shifted_Inverted_Careful;
+        }
+        else {
+            firstFunc = BitmapScanline_Shifted;
+            secondFunc = BitmapScanline_Shifted_Inverted;
+        }
+        shift = skipleft;
+        skipleft = 0;
+    }
+    else {
+        firstFunc = BitmapScanline;
+        secondFunc = BitmapScanline_Inverted;
+        w += skipleft;
+        x -= skipleft;
+    }
+
+#ifdef TRIPLE_BITS
+    dwords = (3 * w + 31) >> 5;
+#else
+    dwords = (w + 31) >> 5;
+#endif
+
+ SECOND_PASS:
+
+    (*infoRec->SetupForScanlineCPUToScreenColorExpandFill) (pScrn, fg, bg, rop,
+                                                            planemask);
+    (*infoRec->SubsequentScanlineCPUToScreenColorExpandFill) (pScrn, x, y, w, h,
+                                                              skipleft);
+
+    bufferNo = 0;
+
+    while (h--) {
+        base = (CARD32 *) infoRec->ScanlineColorExpandBuffers[bufferNo];
+        (*firstFunc) ((CARD32 *) srcp, base, dwords, shift);
+        (*infoRec->SubsequentColorExpandScanline) (pScrn, bufferNo++);
+        srcp += srcwidth;
+        if (bufferNo >= infoRec->NumScanlineColorExpandBuffers)
+            bufferNo = 0;
+    }
+
+    if (SecondPassColor != -1) {
+        fg = SecondPassColor;
+        SecondPassColor = -1;
+        firstFunc = secondFunc;
+        srcp = src;
+        goto SECOND_PASS;
+    }
+
+    SET_SYNC_FLAG(infoRec);
+}
+
+#endif
diff --git a/hw/xfree86/xaa/xaaCpyArea.c b/hw/xfree86/xaa/xaaCpyArea.c
new file mode 100644
index 000000000..0b11b810e
--- /dev/null
+++ b/hw/xfree86/xaa/xaaCpyArea.c
@@ -0,0 +1,409 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include "xf86str.h"
+#include "xaa.h"
+#include "xaalocal.h"
+#include "migc.h"
+#include "gcstruct.h"
+#include "pixmapstr.h"
+
+/*
+  Written mostly by Harm Hanemaayer (H.Hanemaayer@inter.nl.net).
+ */
+
+RegionPtr
+XAACopyArea(DrawablePtr pSrcDrawable,
+            DrawablePtr pDstDrawable,
+            GC * pGC,
+            int srcx, int srcy, int width, int height, int dstx, int dsty)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+
+    if (pDstDrawable->type == DRAWABLE_WINDOW) {
+        if ((pSrcDrawable->type == DRAWABLE_WINDOW) ||
+            IS_OFFSCREEN_PIXMAP(pSrcDrawable)) {
+            if (infoRec->ScreenToScreenBitBlt &&
+                CHECK_ROP(pGC, infoRec->ScreenToScreenBitBltFlags) &&
+                CHECK_ROPSRC(pGC, infoRec->ScreenToScreenBitBltFlags) &&
+                CHECK_PLANEMASK(pGC, infoRec->ScreenToScreenBitBltFlags))
+                return (XAABitBlt(pSrcDrawable, pDstDrawable,
+                                  pGC, srcx, srcy, width, height, dstx, dsty,
+                                  XAADoBitBlt, 0L));
+        }
+        else {
+            if (infoRec->WritePixmap &&
+                ((pDstDrawable->bitsPerPixel == pSrcDrawable->bitsPerPixel) ||
+                 ((pDstDrawable->bitsPerPixel == 24) &&
+                  (pSrcDrawable->bitsPerPixel == 32) &&
+                  (infoRec->WritePixmapFlags & CONVERT_32BPP_TO_24BPP))) &&
+                CHECK_ROP(pGC, infoRec->WritePixmapFlags) &&
+                CHECK_ROPSRC(pGC, infoRec->WritePixmapFlags) &&
+                CHECK_PLANEMASK(pGC, infoRec->WritePixmapFlags) &&
+                CHECK_NO_GXCOPY(pGC, infoRec->WritePixmapFlags))
+                return (XAABitBlt(pSrcDrawable, pDstDrawable,
+                                  pGC, srcx, srcy, width, height, dstx, dsty,
+                                  XAADoImageWrite, 0L));
+        }
+    }
+    else if (IS_OFFSCREEN_PIXMAP(pDstDrawable)) {
+        if ((pSrcDrawable->type == DRAWABLE_WINDOW) ||
+            IS_OFFSCREEN_PIXMAP(pSrcDrawable)) {
+            if (infoRec->ScreenToScreenBitBlt &&
+                CHECK_ROP(pGC, infoRec->ScreenToScreenBitBltFlags) &&
+                CHECK_ROPSRC(pGC, infoRec->ScreenToScreenBitBltFlags) &&
+                CHECK_PLANEMASK(pGC, infoRec->ScreenToScreenBitBltFlags))
+                return (XAABitBlt(pSrcDrawable, pDstDrawable,
+                                  pGC, srcx, srcy, width, height, dstx, dsty,
+                                  XAADoBitBlt, 0L));
+        }
+    }
+
+    return (XAAFallbackOps.CopyArea(pSrcDrawable, pDstDrawable, pGC,
+                                    srcx, srcy, width, height, dstx, dsty));
+}
+
+void
+XAADoBitBlt(DrawablePtr pSrc,
+            DrawablePtr pDst, GC * pGC, RegionPtr prgnDst, DDXPointPtr pptSrc)
+{
+    int nbox, careful;
+    BoxPtr pbox, pboxTmp, pboxNext, pboxBase, pboxNew1, pboxNew2;
+    DDXPointPtr pptTmp, pptNew1, pptNew2;
+    int xdir, ydir;
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+
+    /* XXX we have to err on the side of safety when both are windows,
+     * because we don't know if IncludeInferiors is being used.
+     */
+    careful = ((pSrc == pDst) ||
+               ((pSrc->type == DRAWABLE_WINDOW) &&
+                (pDst->type == DRAWABLE_WINDOW)));
+
+    pbox = RegionRects(prgnDst);
+    nbox = RegionNumRects(prgnDst);
+
+    pboxNew1 = NULL;
+    pptNew1 = NULL;
+    pboxNew2 = NULL;
+    pptNew2 = NULL;
+    if (careful && (pptSrc->y < pbox->y1)) {
+        /* walk source botttom to top */
+        ydir = -1;
+
+        if (nbox > 1) {
+            /* keep ordering in each band, reverse order of bands */
+            pboxNew1 = (BoxPtr) malloc(sizeof(BoxRec) * nbox);
+            if (!pboxNew1)
+                return;
+            pptNew1 = (DDXPointPtr) malloc(sizeof(DDXPointRec) * nbox);
+            if (!pptNew1) {
+                free(pboxNew1);
+                return;
+            }
+            pboxBase = pboxNext = pbox + nbox - 1;
+            while (pboxBase >= pbox) {
+                while ((pboxNext >= pbox) && (pboxBase->y1 == pboxNext->y1))
+                    pboxNext--;
+                pboxTmp = pboxNext + 1;
+                pptTmp = pptSrc + (pboxTmp - pbox);
+                while (pboxTmp <= pboxBase) {
+                    *pboxNew1++ = *pboxTmp++;
+                    *pptNew1++ = *pptTmp++;
+                }
+                pboxBase = pboxNext;
+            }
+            pboxNew1 -= nbox;
+            pbox = pboxNew1;
+            pptNew1 -= nbox;
+            pptSrc = pptNew1;
+        }
+    }
+    else {
+        /* walk source top to bottom */
+        ydir = 1;
+    }
+
+    if (careful && (pptSrc->x < pbox->x1)) {
+        /* walk source right to left */
+        xdir = -1;
+
+        if (nbox > 1) {
+            /* reverse order of rects in each band */
+            pboxNew2 = (BoxPtr) malloc(sizeof(BoxRec) * nbox);
+            pptNew2 = (DDXPointPtr) malloc(sizeof(DDXPointRec) * nbox);
+            if (!pboxNew2 || !pptNew2) {
+                free(pptNew2);
+                free(pboxNew2);
+                if (pboxNew1) {
+                    free(pptNew1);
+                    free(pboxNew1);
+                }
+                return;
+            }
+            pboxBase = pboxNext = pbox;
+            while (pboxBase < pbox + nbox) {
+                while ((pboxNext < pbox + nbox) &&
+                       (pboxNext->y1 == pboxBase->y1))
+                    pboxNext++;
+                pboxTmp = pboxNext;
+                pptTmp = pptSrc + (pboxTmp - pbox);
+                while (pboxTmp != pboxBase) {
+                    *pboxNew2++ = *--pboxTmp;
+                    *pptNew2++ = *--pptTmp;
+                }
+                pboxBase = pboxNext;
+            }
+            pboxNew2 -= nbox;
+            pbox = pboxNew2;
+            pptNew2 -= nbox;
+            pptSrc = pptNew2;
+        }
+    }
+    else {
+        /* walk source left to right */
+        xdir = 1;
+    }
+
+    (*infoRec->ScreenToScreenBitBlt) (infoRec->pScrn, nbox, pptSrc, pbox,
+                                      xdir, ydir, pGC->alu, pGC->planemask);
+
+    if (pboxNew2) {
+        free(pptNew2);
+        free(pboxNew2);
+    }
+    if (pboxNew1) {
+        free(pptNew1);
+        free(pboxNew1);
+    }
+
+}
+
+void
+XAADoImageWrite(DrawablePtr pSrc,
+                DrawablePtr pDst,
+                GC * pGC, RegionPtr prgnDst, DDXPointPtr pptSrc)
+{
+    int srcwidth;
+    unsigned char *psrcBase;    /* start of image */
+    unsigned char *srcPntr;     /* index into the image */
+    BoxPtr pbox = RegionRects(prgnDst);
+    int nbox = RegionNumRects(prgnDst);
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    int Bpp = pSrc->bitsPerPixel >> 3;
+
+    psrcBase = (unsigned char *) ((PixmapPtr) pSrc)->devPrivate.ptr;
+    srcwidth = (int) ((PixmapPtr) pSrc)->devKind;
+
+    for (; nbox; pbox++, pptSrc++, nbox--) {
+        srcPntr = psrcBase + (pptSrc->y * srcwidth) + (pptSrc->x * Bpp);
+
+        (*infoRec->WritePixmap) (infoRec->pScrn, pbox->x1, pbox->y1,
+                                 pbox->x2 - pbox->x1, pbox->y2 - pbox->y1,
+                                 srcPntr, srcwidth, pGC->alu, pGC->planemask,
+                                 -1, pSrc->bitsPerPixel, pSrc->depth);
+    }
+}
+
+void
+XAADoImageRead(DrawablePtr pSrc,
+               DrawablePtr pDst,
+               GC * pGC, RegionPtr prgnDst, DDXPointPtr pptSrc)
+{
+    int dstwidth;
+    unsigned char *pdstBase;    /* start of image */
+    unsigned char *dstPntr;     /* index into the image */
+    BoxPtr pbox = RegionRects(prgnDst);
+    int nbox = RegionNumRects(prgnDst);
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    int Bpp = pSrc->bitsPerPixel >> 3;  /* wouldn't get here unless both
+                                           src and dst have same bpp */
+
+    pdstBase = (unsigned char *) ((PixmapPtr) pDst)->devPrivate.ptr;
+    dstwidth = (int) ((PixmapPtr) pDst)->devKind;
+
+    for (; nbox; pbox++, pptSrc++, nbox--) {
+        dstPntr = pdstBase + (pbox->y1 * dstwidth) + (pbox->x1 * Bpp);
+
+        (*infoRec->ReadPixmap) (infoRec->pScrn, pptSrc->x, pptSrc->y,
+                                pbox->x2 - pbox->x1, pbox->y2 - pbox->y1,
+                                dstPntr, dstwidth, pSrc->bitsPerPixel,
+                                pSrc->depth);
+    }
+}
+
+void
+XAAScreenToScreenBitBlt(ScrnInfoPtr pScrn,
+                        int nbox,
+                        DDXPointPtr pptSrc,
+                        BoxPtr pbox,
+                        int xdir, int ydir, int alu, unsigned int planemask)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int dirsetup;
+
+    if ((!(infoRec->CopyAreaFlags & ONLY_TWO_BITBLT_DIRECTIONS)
+         || (xdir == ydir)) &&
+        (!(infoRec->CopyAreaFlags & ONLY_LEFT_TO_RIGHT_BITBLT)
+         || (xdir == 1))) {
+        (*infoRec->SetupForScreenToScreenCopy) (pScrn,
+                                                xdir, ydir, alu, planemask, -1);
+        for (; nbox; pbox++, pptSrc++, nbox--)
+            (*infoRec->SubsequentScreenToScreenCopy) (pScrn, pptSrc->x,
+                                                      pptSrc->y, pbox->x1,
+                                                      pbox->y1,
+                                                      pbox->x2 - pbox->x1,
+                                                      pbox->y2 - pbox->y1);
+        SET_SYNC_FLAG(infoRec);
+        return;
+    }
+
+    if (infoRec->CopyAreaFlags & ONLY_LEFT_TO_RIGHT_BITBLT) {
+        /*
+         * This is the case of a chip that only supports xdir = 1,
+         * with ydir = 1 or ydir = -1, but we have xdir = -1.
+         */
+        (*infoRec->SetupForScreenToScreenCopy) (pScrn,
+                                                1, ydir, alu, planemask, -1);
+        for (; nbox; pbox++, pptSrc++, nbox--)
+            if (pptSrc->y != pbox->y1 || pptSrc->x >= pbox->x1)
+                /* No problem. Do a xdir = 1 blit instead. */
+                (*infoRec->SubsequentScreenToScreenCopy) (pScrn,
+                                                          pptSrc->x, pptSrc->y,
+                                                          pbox->x1, pbox->y1,
+                                                          pbox->x2 - pbox->x1,
+                                                          pbox->y2 - pbox->y1);
+            else {
+                /*
+                 * This is the difficult case. Needs striping into
+                 * non-overlapping horizontal chunks.
+                 */
+                int stripeWidth, w, fullStripes, extra, i;
+
+                stripeWidth = 16;
+                w = pbox->x2 - pbox->x1;
+                if (pbox->x1 - pptSrc->x < stripeWidth)
+                    stripeWidth = pbox->x1 - pptSrc->x;
+                fullStripes = w / stripeWidth;
+                extra = w % stripeWidth;
+
+                /* First, take care of the little bit on the far right */
+                if (extra)
+                    (*infoRec->SubsequentScreenToScreenCopy) (pScrn,
+                                                              pptSrc->x +
+                                                              fullStripes *
+                                                              stripeWidth,
+                                                              pptSrc->y,
+                                                              pbox->x1 +
+                                                              fullStripes *
+                                                              stripeWidth,
+                                                              pbox->y1, extra,
+                                                              pbox->y2 -
+                                                              pbox->y1);
+
+                /* Now, take care of the rest of the blit */
+                for (i = fullStripes - 1; i >= 0; i--)
+                    (*infoRec->SubsequentScreenToScreenCopy) (pScrn,
+                                                              pptSrc->x +
+                                                              i * stripeWidth,
+                                                              pptSrc->y,
+                                                              pbox->x1 +
+                                                              i * stripeWidth,
+                                                              pbox->y1,
+                                                              stripeWidth,
+                                                              pbox->y2 -
+                                                              pbox->y1);
+            }
+        SET_SYNC_FLAG(infoRec);
+        return;
+    }
+
+    /*
+     * Now the case of a chip that only supports xdir = ydir = 1 or
+     * xdir = ydir = -1, but we have xdir != ydir.
+     */
+    dirsetup = 0;               /* No direction set up yet. */
+    for (; nbox; pbox++, pptSrc++, nbox--) {
+        if (xdir == 1 && pptSrc->y != pbox->y1) {
+            /* Do a xdir = ydir = -1 blit instead. */
+            if (dirsetup != -1) {
+                (*infoRec->SetupForScreenToScreenCopy) (pScrn,
+                                                        -1, -1, alu, planemask,
+                                                        -1);
+                dirsetup = -1;
+            }
+            (*infoRec->SubsequentScreenToScreenCopy) (pScrn, pptSrc->x,
+                                                      pptSrc->y, pbox->x1,
+                                                      pbox->y1,
+                                                      pbox->x2 - pbox->x1,
+                                                      pbox->y2 - pbox->y1);
+        }
+        else if (xdir == -1 && pptSrc->y != pbox->y1) {
+            /* Do a xdir = ydir = 1 blit instead. */
+            if (dirsetup != 1) {
+                (*infoRec->SetupForScreenToScreenCopy) (pScrn,
+                                                        1, 1, alu, planemask,
+                                                        -1);
+                dirsetup = 1;
+            }
+            (*infoRec->SubsequentScreenToScreenCopy) (pScrn, pptSrc->x,
+                                                      pptSrc->y, pbox->x1,
+                                                      pbox->y1,
+                                                      pbox->x2 - pbox->x1,
+                                                      pbox->y2 - pbox->y1);
+        }
+        else if (xdir == 1) {
+            /*
+             * xdir = 1, ydir = -1.
+             * Perform line-by-line xdir = ydir = 1 blits, going up.
+             */
+            int i;
+
+            if (dirsetup != 1) {
+                (*infoRec->SetupForScreenToScreenCopy) (pScrn,
+                                                        1, 1, alu, planemask,
+                                                        -1);
+                dirsetup = 1;
+            }
+            for (i = pbox->y2 - pbox->y1 - 1; i >= 0; i--)
+                (*infoRec->SubsequentScreenToScreenCopy) (pScrn,
+                                                          pptSrc->x,
+                                                          pptSrc->y + i,
+                                                          pbox->x1,
+                                                          pbox->y1 + i,
+                                                          pbox->x2 - pbox->x1,
+                                                          1);
+        }
+        else {
+            /*
+             * xdir = -1, ydir = 1.
+             * Perform line-by-line xdir = ydir = -1 blits, going down.
+             */
+            int i;
+
+            if (dirsetup != -1) {
+                (*infoRec->SetupForScreenToScreenCopy) (pScrn,
+                                                        -1, -1, alu, planemask,
+                                                        -1);
+                dirsetup = -1;
+            }
+            for (i = 0; i < pbox->y2 - pbox->y1; i++)
+                (*infoRec->SubsequentScreenToScreenCopy) (pScrn,
+                                                          pptSrc->x,
+                                                          pptSrc->y + i,
+                                                          pbox->x1,
+                                                          pbox->y1 + i,
+                                                          pbox->x2 - pbox->x1,
+                                                          1);
+        }
+    }                           /* next box */
+    SET_SYNC_FLAG(infoRec);
+}
diff --git a/hw/xfree86/xaa/xaaCpyPlane.c b/hw/xfree86/xaa/xaaCpyPlane.c
new file mode 100644
index 000000000..b9197e41f
--- /dev/null
+++ b/hw/xfree86/xaa/xaaCpyPlane.c
@@ -0,0 +1,204 @@
+
+/*
+   A CopyPlane function that handles bitmap->screen copies and
+   sends anything else to the Fallback.
+
+   Also, a PushPixels for solid fill styles.
+
+   Written by Mark Vojkovich (markv@valinux.com)
+
+*/
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <string.h>
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+#include "servermd.h"
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include "mi.h"
+#include "pixmapstr.h"
+#include "xf86str.h"
+#include "xaa.h"
+#include "xaalocal.h"
+#include "xaawrap.h"
+
+static void XAACopyPlane1toNColorExpand(DrawablePtr pSrc, DrawablePtr pDst,
+                                        GCPtr pGC, RegionPtr rgnDst,
+                                        DDXPointPtr pptSrc);
+static void XAACopyPlaneNtoNColorExpand(DrawablePtr pSrc, DrawablePtr pDst,
+                                        GCPtr pGC, RegionPtr rgnDst,
+                                        DDXPointPtr pptSrc);
+
+static unsigned long TmpBitPlane;
+
+RegionPtr
+XAACopyPlaneColorExpansion(DrawablePtr pSrc,
+                           DrawablePtr pDst,
+                           GCPtr pGC,
+                           int srcx, int srcy,
+                           int width, int height,
+                           int dstx, int dsty, unsigned long bitPlane)
+{
+    if ((pSrc->type == DRAWABLE_PIXMAP) && !XAA_DEPTH_BUG(pGC)) {
+        if (pSrc->bitsPerPixel == 1) {
+            return (XAABitBlt(pSrc, pDst, pGC, srcx, srcy,
+                              width, height, dstx, dsty,
+                              XAACopyPlane1toNColorExpand, bitPlane));
+        }
+        else if (bitPlane < (1 << pDst->depth)) {
+            TmpBitPlane = bitPlane;
+            return (XAABitBlt(pSrc, pDst, pGC, srcx, srcy,
+                              width, height, dstx, dsty,
+                              XAACopyPlaneNtoNColorExpand, bitPlane));
+        }
+    }
+
+    return (XAAFallbackOps.CopyPlane(pSrc, pDst, pGC, srcx, srcy,
+                                     width, height, dstx, dsty, bitPlane));
+}
+
+static void
+XAACopyPlane1toNColorExpand(DrawablePtr pSrc,
+                            DrawablePtr pDst,
+                            GCPtr pGC, RegionPtr rgnDst, DDXPointPtr pptSrc)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    BoxPtr pbox = RegionRects(rgnDst);
+    int numrects = RegionNumRects(rgnDst);
+    unsigned char *src = ((PixmapPtr) pSrc)->devPrivate.ptr;
+    int srcwidth = ((PixmapPtr) pSrc)->devKind;
+
+    while (numrects--) {
+        (*infoRec->WriteBitmap) (infoRec->pScrn, pbox->x1, pbox->y1,
+                                 pbox->x2 - pbox->x1, pbox->y2 - pbox->y1,
+                                 src + (srcwidth * pptSrc->y) +
+                                 ((pptSrc->x >> 5) << 2), srcwidth,
+                                 pptSrc->x & 31, pGC->fgPixel, pGC->bgPixel,
+                                 pGC->alu, pGC->planemask);
+        pbox++;
+        pptSrc++;
+    }
+}
+
+static void
+XAACopyPlaneNtoNColorExpand(DrawablePtr pSrc,
+                            DrawablePtr pDst,
+                            GCPtr pGC, RegionPtr rgnDst, DDXPointPtr pptSrc)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    BoxPtr pbox = RegionRects(rgnDst);
+    int numrects = RegionNumRects(rgnDst);
+    unsigned char *src = ((PixmapPtr) pSrc)->devPrivate.ptr;
+    unsigned char *data, *srcPtr, *dataPtr;
+    int srcwidth = ((PixmapPtr) pSrc)->devKind;
+    int pitch, width, height, h, i, index, offset;
+    int Bpp = pSrc->bitsPerPixel >> 3;
+    unsigned long mask = TmpBitPlane;
+
+    if (TmpBitPlane < (1 << 8)) {
+        offset = 0;
+    }
+    else if (TmpBitPlane < (1 << 16)) {
+        offset = 1;
+        mask >>= 8;
+    }
+    else if (TmpBitPlane < (1 << 24)) {
+        offset = 2;
+        mask >>= 16;
+    }
+    else {
+        offset = 3;
+        mask >>= 24;
+    }
+
+    if (IS_OFFSCREEN_PIXMAP(pSrc))
+        SYNC_CHECK(pSrc);
+
+    while (numrects--) {
+        width = pbox->x2 - pbox->x1;
+        h = height = pbox->y2 - pbox->y1;
+        pitch = BitmapBytePad(width);
+
+        if (!(data = calloc(height, pitch)))
+            goto ALLOC_FAILED;
+
+        dataPtr = data;
+        srcPtr = ((pptSrc->y) * srcwidth) + src + ((pptSrc->x) * Bpp) + offset;
+
+        while (h--) {
+            for (i = index = 0; i < width; i++, index += Bpp) {
+                if (mask & srcPtr[index])
+                    dataPtr[i >> 3] |= (1 << (i & 7));
+            }
+            dataPtr += pitch;
+            srcPtr += srcwidth;
+        }
+
+        (*infoRec->WriteBitmap) (infoRec->pScrn,
+                                 pbox->x1, pbox->y1, width, height, data, pitch,
+                                 0, pGC->fgPixel, pGC->bgPixel, pGC->alu,
+                                 pGC->planemask);
+
+        free(data);
+
+ ALLOC_FAILED:
+
+        pbox++;
+        pptSrc++;
+    }
+}
+
+void
+XAAPushPixelsSolidColorExpansion(GCPtr pGC,
+                                 PixmapPtr pBitMap,
+                                 DrawablePtr pDraw,
+                                 int dx, int dy, int xOrg, int yOrg)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    int MaxBoxes = RegionNumRects(pGC->pCompositeClip);
+    BoxPtr pbox, pClipBoxes;
+    int nboxes, srcx, srcy;
+    xRectangle TheRect;
+    unsigned char *src = pBitMap->devPrivate.ptr;
+    int srcwidth = pBitMap->devKind;
+
+    if (!RegionNumRects(pGC->pCompositeClip))
+        return;
+
+    TheRect.x = xOrg;
+    TheRect.y = yOrg;
+    TheRect.width = dx;
+    TheRect.height = dy;
+
+    if (MaxBoxes > (infoRec->PreAllocSize / sizeof(BoxRec))) {
+        pClipBoxes = malloc(MaxBoxes * sizeof(BoxRec));
+        if (!pClipBoxes)
+            return;
+    }
+    else
+        pClipBoxes = (BoxPtr) infoRec->PreAllocMem;
+
+    nboxes = XAAGetRectClipBoxes(pGC, pClipBoxes, 1, &TheRect);
+    pbox = pClipBoxes;
+
+    while (nboxes--) {
+        srcx = pbox->x1 - xOrg;
+        srcy = pbox->y1 - yOrg;
+        (*infoRec->WriteBitmap) (infoRec->pScrn, pbox->x1, pbox->y1,
+                                 pbox->x2 - pbox->x1, pbox->y2 - pbox->y1,
+                                 src + (srcwidth * srcy) + ((srcx >> 5) << 2),
+                                 srcwidth, srcx & 31,
+                                 pGC->fgPixel, -1, pGC->alu, pGC->planemask);
+        pbox++;
+    }
+
+    if (pClipBoxes != (BoxPtr) infoRec->PreAllocMem)
+        free(pClipBoxes);
+}
diff --git a/hw/xfree86/xaa/xaaCpyWin.c b/hw/xfree86/xaa/xaaCpyWin.c
new file mode 100644
index 000000000..e851f4a37
--- /dev/null
+++ b/hw/xfree86/xaa/xaaCpyWin.c
@@ -0,0 +1,78 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include "windowstr.h"
+#include "xf86str.h"
+#include "xaa.h"
+#include "xaalocal.h"
+#include "gcstruct.h"
+#include "pixmapstr.h"
+#include "xaawrap.h"
+
+/*
+    Written by Harm Hanemaayer (H.Hanemaayer@inter.nl.net).
+*/
+
+void
+XAACopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
+{
+    DDXPointPtr pptSrc, ppt;
+    RegionRec rgnDst;
+    BoxPtr pbox;
+    int dx, dy, nbox;
+    WindowPtr pwinRoot;
+    ScreenPtr pScreen = pWin->drawable.pScreen;
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_DRAWABLE((&pWin->drawable));
+
+    if (!infoRec->pScrn->vtSema || !infoRec->ScreenToScreenBitBlt) {
+        XAA_SCREEN_PROLOGUE(pScreen, CopyWindow);
+        if (infoRec->pScrn->vtSema && infoRec->NeedToSync) {
+            (*infoRec->Sync) (infoRec->pScrn);
+            infoRec->NeedToSync = FALSE;
+        }
+        (*pScreen->CopyWindow) (pWin, ptOldOrg, prgnSrc);
+        XAA_SCREEN_EPILOGUE(pScreen, CopyWindow, XAACopyWindow);
+        return;
+    }
+
+    pwinRoot = pScreen->root;
+
+    RegionNull(&rgnDst);
+
+    dx = ptOldOrg.x - pWin->drawable.x;
+    dy = ptOldOrg.y - pWin->drawable.y;
+    RegionTranslate(prgnSrc, -dx, -dy);
+    RegionIntersect(&rgnDst, &pWin->borderClip, prgnSrc);
+
+    pbox = RegionRects(&rgnDst);
+    nbox = RegionNumRects(&rgnDst);
+    if (!nbox || !(pptSrc = (DDXPointPtr) malloc(nbox * sizeof(DDXPointRec)))) {
+        RegionUninit(&rgnDst);
+        return;
+    }
+    ppt = pptSrc;
+
+    while (nbox--) {
+        ppt->x = pbox->x1 + dx;
+        ppt->y = pbox->y1 + dy;
+        ppt++;
+        pbox++;
+    }
+
+    infoRec->ScratchGC.planemask = ~0L;
+    infoRec->ScratchGC.alu = GXcopy;
+
+    XAADoBitBlt((DrawablePtr) pwinRoot, (DrawablePtr) pwinRoot,
+                &(infoRec->ScratchGC), &rgnDst, pptSrc);
+
+    free(pptSrc);
+    RegionUninit(&rgnDst);
+}
diff --git a/hw/xfree86/xaa/xaaDashLine.c b/hw/xfree86/xaa/xaaDashLine.c
new file mode 100644
index 000000000..c7e52cd0b
--- /dev/null
+++ b/hw/xfree86/xaa/xaaDashLine.c
@@ -0,0 +1,353 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <stdlib.h>
+
+#include <X11/X.h>
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include "scrnintstr.h"
+#include "pixmapstr.h"
+#include "miline.h"
+#include "xf86str.h"
+#include "xaa.h"
+#include "xaalocal.h"
+
+void
+#ifdef POLYSEGMENT
+ XAAPolySegmentDashed(DrawablePtr pDrawable,
+                      GCPtr pGC, int nseg, xSegment * pSeg
+#else
+XAAPolyLinesDashed(DrawablePtr pDrawable, GCPtr pGC, int mode,  /* Origin or Previous */
+                   int npt,     /* number of points */
+                   DDXPointPtr pptInit
+#endif
+    )
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    XAAGCPtr pGCPriv = (XAAGCPtr) dixLookupPrivate(&pGC->devPrivates,
+                                                   XAAGetGCKey());
+    BoxPtr pboxInit = RegionRects(pGC->pCompositeClip);
+    int nboxInit = RegionNumRects(pGC->pCompositeClip);
+    unsigned int bias = miGetZeroLineBias(pDrawable->pScreen);
+    int xorg = pDrawable->x;
+    int yorg = pDrawable->y;
+    int nbox;
+    BoxPtr pbox;
+
+#ifndef POLYSEGMENT
+    DDXPointPtr ppt;
+#endif
+    unsigned int oc1, oc2;
+    int dmin, dmaj, e, octant;
+    int x1, x2, y1, y2, tmp, len, offset;
+    int PatternLength, PatternOffset;
+
+    if (!nboxInit)
+        return;
+
+    if (infoRec->DashedLineFlags & LINE_LIMIT_COORDS) {
+        int minValX = infoRec->DashedLineLimits.x1;
+        int maxValX = infoRec->DashedLineLimits.x2;
+        int minValY = infoRec->DashedLineLimits.y1;
+        int maxValY = infoRec->DashedLineLimits.y2;
+
+#ifdef POLYSEGMENT
+        int n = nseg;
+        xSegment *s = pSeg;
+
+        while (n--)
+#else
+        int n = npt;
+        int xorgtmp = xorg;
+        int yorgtmp = yorg;
+
+        ppt = pptInit;
+        x2 = ppt->x + xorgtmp;
+        y2 = ppt->y + yorgtmp;
+        while (--n)
+#endif
+        {
+#ifdef POLYSEGMENT
+            x1 = s->x1 + xorg;
+            y1 = s->y1 + yorg;
+            x2 = s->x2 + xorg;
+            y2 = s->y2 + yorg;
+            s++;
+#else
+            x1 = x2;
+            y1 = y2;
+            ++ppt;
+            if (mode == CoordModePrevious) {
+                xorgtmp = x1;
+                yorgtmp = y1;
+            }
+            x2 = ppt->x + xorgtmp;
+            y2 = ppt->y + yorgtmp;
+#endif
+            if (x1 > maxValX || x1 < minValX ||
+                x2 > maxValX || x2 < minValX ||
+                y1 > maxValY || y1 < minValY || y2 > maxValY || y2 < minValY) {
+#ifdef POLYSEGMENT
+                XAAFallbackOps.PolySegment(pDrawable, pGC, nseg, pSeg);
+#else
+                XAAFallbackOps.Polylines(pDrawable, pGC, mode, npt, pptInit);
+#endif
+                return;
+            }
+        }
+    }
+
+    PatternLength = pGCPriv->DashLength;
+    PatternOffset = pGC->dashOffset % PatternLength;
+
+    (*infoRec->SetupForDashedLine) (infoRec->pScrn, pGC->fgPixel,
+                                    (pGC->lineStyle ==
+                                     LineDoubleDash) ? pGC->bgPixel : -1,
+                                    pGC->alu, pGC->planemask, PatternLength,
+                                    pGCPriv->DashPattern);
+
+#ifdef POLYSEGMENT
+    while (nseg--)
+#else
+    ppt = pptInit;
+    x2 = ppt->x + xorg;
+    y2 = ppt->y + yorg;
+    while (--npt)
+#endif
+    {
+        nbox = nboxInit;
+        pbox = pboxInit;
+
+#ifdef POLYSEGMENT
+        x1 = pSeg->x1 + xorg;
+        y1 = pSeg->y1 + yorg;
+        x2 = pSeg->x2 + xorg;
+        y2 = pSeg->y2 + yorg;
+        pSeg++;
+#else
+        x1 = x2;
+        y1 = y2;
+        ++ppt;
+        if (mode == CoordModePrevious) {
+            xorg = x1;
+            yorg = y1;
+        }
+        x2 = ppt->x + xorg;
+        y2 = ppt->y + yorg;
+#endif
+
+        if (infoRec->SubsequentDashedBresenhamLine) {
+            if ((dmaj = x2 - x1) < 0) {
+                dmaj = -dmaj;
+                octant = XDECREASING;
+            }
+            else
+                octant = 0;
+
+            if ((dmin = y2 - y1) < 0) {
+                dmin = -dmin;
+                octant |= YDECREASING;
+            }
+
+            if (dmin >= dmaj) {
+                tmp = dmin;
+                dmin = dmaj;
+                dmaj = tmp;
+                octant |= YMAJOR;
+            }
+
+            e = -dmaj - ((bias >> octant) & 1);
+            len = dmaj;
+            dmin <<= 1;
+            dmaj <<= 1;
+        }
+        else {                  /* Muffle compiler */
+            dmin = dmaj = e = octant = len = 0;
+        }
+
+        while (nbox--) {
+            oc1 = oc2 = 0;
+            OUTCODES(oc1, x1, y1, pbox);
+            OUTCODES(oc2, x2, y2, pbox);
+            if (!(oc1 | oc2)) { /* uncliped */
+                if (infoRec->SubsequentDashedTwoPointLine) {
+                    (*infoRec->SubsequentDashedTwoPointLine) (infoRec->pScrn,
+                                                              x1, y1, x2, y2,
+#ifdef POLYSEGMENT
+                                                              (pGC->capStyle !=
+                                                               CapNotLast) ? 0 :
+#endif
+                                                              OMIT_LAST,
+                                                              PatternOffset);
+                }
+                else {
+                    (*infoRec->SubsequentDashedBresenhamLine) (infoRec->pScrn,
+                                                               x1, y1, dmaj,
+                                                               dmin, e,
+#ifdef POLYSEGMENT
+                                                               (pGC->capStyle !=
+                                                                CapNotLast)
+                                                               ? (len + 1) :
+#endif
+                                                               len, octant,
+                                                               PatternOffset);
+                }
+                break;
+            }
+            else if (oc1 & oc2) {       /* completely clipped */
+                pbox++;
+            }
+            else if (infoRec->ClippingFlags & HARDWARE_CLIP_DASHED_LINE) {
+                (*infoRec->SetClippingRectangle) (infoRec->pScrn,
+                                                  pbox->x1, pbox->y1,
+                                                  pbox->x2 - 1, pbox->y2 - 1);
+
+                if (infoRec->SubsequentDashedBresenhamLine) {
+                    (*infoRec->SubsequentDashedBresenhamLine) (infoRec->pScrn,
+                                                               x1, y1, dmaj,
+                                                               dmin, e,
+#ifdef POLYSEGMENT
+                                                               (pGC->capStyle !=
+                                                                CapNotLast)
+                                                               ? (len + 1) :
+#endif
+                                                               len, octant,
+                                                               PatternOffset);
+                }
+                else {
+                    (*infoRec->SubsequentDashedTwoPointLine) (infoRec->pScrn,
+                                                              x1, y1, x2, y2,
+#ifdef POLYSEGMENT
+                                                              (pGC->capStyle !=
+                                                               CapNotLast) ? 0 :
+#endif
+                                                              OMIT_LAST,
+                                                              PatternOffset);
+                }
+                (*infoRec->DisableClipping) (infoRec->pScrn);
+                pbox++;
+            }
+            else {
+                int new_x1 = x1, new_y1 = y1, new_x2 = x2, new_y2 = y2;
+                int clip1 = 0, clip2 = 0;
+                int err, adx, ady;
+
+                if (octant & YMAJOR) {
+                    ady = dmaj >> 1;
+                    adx = dmin >> 1;
+                }
+                else {
+                    ady = dmin >> 1;
+                    adx = dmaj >> 1;
+                }
+
+                if (miZeroClipLine(pbox->x1, pbox->y1,
+                                   pbox->x2 - 1, pbox->y2 - 1,
+                                   &new_x1, &new_y1, &new_x2, &new_y2,
+                                   adx, ady, &clip1, &clip2,
+                                   octant, bias, oc1, oc2) == -1) {
+                    pbox++;
+                    continue;
+                }
+
+                if (octant & YMAJOR)
+                    len = abs(new_y2 - new_y1);
+                else
+                    len = abs(new_x2 - new_x1);
+#ifdef POLYSEGMENT
+                if (clip2 != 0 || pGC->capStyle != CapNotLast)
+                    len++;
+#else
+                len += (clip2 != 0);
+#endif
+                if (len) {
+                    int abserr, clipdx, clipdy;
+
+                    /* unwind bresenham error term to first point */
+                    if (clip1) {
+                        clipdx = abs(new_x1 - x1);
+                        clipdy = abs(new_y1 - y1);
+
+                        if (octant & YMAJOR)
+                            err = e + clipdy * dmin - clipdx * dmaj;
+                        else
+                            err = e + clipdx * dmin - clipdy * dmaj;
+                    }
+                    else
+                        err = e;
+
+#define range infoRec->DashedBresenhamLineErrorTermBits
+                    abserr = abs(err);
+                    while ((abserr & range) || (dmaj & range) || (dmin & range)) {
+                        dmin >>= 1;
+                        dmaj >>= 1;
+                        abserr >>= 1;
+                        err /= 2;
+                    }
+
+                    if (octant & YMAJOR)
+                        offset = abs(new_y1 - y1);
+                    else
+                        offset = abs(new_x1 - x1);
+
+                    offset += PatternOffset;
+                    offset %= PatternLength;
+
+                    (*infoRec->SubsequentDashedBresenhamLine) (infoRec->pScrn,
+                                                               new_x1, new_y1,
+                                                               dmaj, dmin, err,
+                                                               len, octant,
+                                                               offset);
+                }
+                pbox++;
+            }
+        }                       /* while (nbox--) */
+#ifndef POLYSEGMENT
+        len = abs(y2 - y1);
+        tmp = abs(x2 - x1);
+        PatternOffset += (len > tmp) ? len : tmp;
+        PatternOffset %= PatternLength;
+#endif
+    }                           /* while (nline--) */
+
+#ifndef POLYSEGMENT
+    /* paint the last point if the end style isn't CapNotLast.
+       (Assume that a projecting, butt, or round cap that is one
+       pixel wide is the same as the single pixel of the endpoint.)
+     */
+
+    if ((pGC->capStyle != CapNotLast) &&
+        ((ppt->x + xorg != pptInit->x + pDrawable->x) ||
+         (ppt->y + yorg != pptInit->y + pDrawable->y) ||
+         (ppt == pptInit + 1))) {
+        nbox = nboxInit;
+        pbox = pboxInit;
+        while (nbox--) {
+            if ((x2 >= pbox->x1) && (y2 >= pbox->y1) &&
+                (x2 < pbox->x2) && (y2 < pbox->y2)) {
+                if (infoRec->SubsequentDashedTwoPointLine) {
+                    (*infoRec->SubsequentDashedTwoPointLine) (infoRec->pScrn,
+                                                              x2, y2, x2, y2, 0,
+                                                              PatternOffset);
+                }
+                else {
+                    (*infoRec->SubsequentDashedBresenhamLine) (infoRec->pScrn,
+                                                               x2, y2, 2, 0, -1,
+                                                               1, 0,
+                                                               PatternOffset);
+                }
+                break;
+            }
+            else
+                pbox++;
+        }
+    }
+#endif
+
+    SET_SYNC_FLAG(infoRec);
+}
diff --git a/hw/xfree86/xaa/xaaFallback.c b/hw/xfree86/xaa/xaaFallback.c
new file mode 100644
index 000000000..3265b278a
--- /dev/null
+++ b/hw/xfree86/xaa/xaaFallback.c
@@ -0,0 +1,281 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include "xf86str.h"
+#include "xaa.h"
+#include "xaalocal.h"
+#include "gcstruct.h"
+#include "pixmapstr.h"
+#include "xaawrap.h"
+
+static void
+XAAFillSpansFallback(DrawablePtr pDraw,
+                     GC * pGC,
+                     int nInit,
+                     DDXPointPtr pptInit, int *pwidthInit, int fSorted)
+{
+    XAA_GC_OP_PROLOGUE_WITH_RETURN(pGC);
+    SYNC_CHECK(pGC);
+    (*pGC->ops->FillSpans) (pDraw, pGC, nInit, pptInit, pwidthInit, fSorted);
+    XAA_GC_OP_EPILOGUE(pGC);
+}
+
+static void
+XAASetSpansFallback(DrawablePtr pDraw,
+                    GCPtr pGC,
+                    char *pcharsrc,
+                    register DDXPointPtr ppt,
+                    int *pwidth, int nspans, int fSorted)
+{
+    XAA_GC_OP_PROLOGUE_WITH_RETURN(pGC);
+    SYNC_CHECK(pGC);
+    (*pGC->ops->SetSpans) (pDraw, pGC, pcharsrc, ppt, pwidth, nspans, fSorted);
+    XAA_GC_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAPutImageFallback(DrawablePtr pDraw,
+                    GCPtr pGC,
+                    int depth,
+                    int x, int y, int w, int h,
+                    int leftPad, int format, char *pImage)
+{
+    XAA_GC_OP_PROLOGUE_WITH_RETURN(pGC);
+    SYNC_CHECK(pGC);
+    (*pGC->ops->PutImage) (pDraw, pGC, depth, x, y, w, h,
+                           leftPad, format, pImage);
+    XAA_GC_OP_EPILOGUE(pGC);
+}
+
+static RegionPtr
+XAACopyAreaFallback(DrawablePtr pSrc,
+                    DrawablePtr pDst,
+                    GC * pGC,
+                    int srcx, int srcy,
+                    int width, int height, int dstx, int dsty)
+{
+    RegionPtr ret;
+
+    XAA_GC_OP_PROLOGUE(pGC);
+    if ((pSrc->type == DRAWABLE_WINDOW) || (pDst->type == DRAWABLE_WINDOW) ||
+        IS_OFFSCREEN_PIXMAP(pSrc) || IS_OFFSCREEN_PIXMAP(pDst)) {
+        SYNC_CHECK(pGC);
+    }
+    ret = (*pGC->ops->CopyArea) (pSrc, pDst,
+                                 pGC, srcx, srcy, width, height, dstx, dsty);
+    XAA_GC_OP_EPILOGUE(pGC);
+    return ret;
+}
+
+static RegionPtr
+XAACopyPlaneFallback(DrawablePtr pSrc,
+                     DrawablePtr pDst,
+                     GCPtr pGC,
+                     int srcx, int srcy,
+                     int width, int height,
+                     int dstx, int dsty, unsigned long bitPlane)
+{
+    RegionPtr ret;
+
+    XAA_GC_OP_PROLOGUE(pGC);
+    if ((pSrc->type == DRAWABLE_WINDOW) || (pDst->type == DRAWABLE_WINDOW) ||
+        IS_OFFSCREEN_PIXMAP(pSrc) || IS_OFFSCREEN_PIXMAP(pDst)) {
+        SYNC_CHECK(pGC);
+    }
+    ret = (*pGC->ops->CopyPlane) (pSrc, pDst,
+                                  pGC, srcx, srcy, width, height, dstx, dsty,
+                                  bitPlane);
+    XAA_GC_OP_EPILOGUE(pGC);
+    return ret;
+}
+
+static void
+XAAPolyPointFallback(DrawablePtr pDraw,
+                     GCPtr pGC, int mode, int npt, xPoint * pptInit)
+{
+    XAA_GC_OP_PROLOGUE_WITH_RETURN(pGC);
+    SYNC_CHECK(pGC);
+    (*pGC->ops->PolyPoint) (pDraw, pGC, mode, npt, pptInit);
+    XAA_GC_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAPolylinesFallback(DrawablePtr pDraw,
+                     GCPtr pGC, int mode, int npt, DDXPointPtr pptInit)
+{
+    XAA_GC_OP_PROLOGUE_WITH_RETURN(pGC);
+    SYNC_CHECK(pGC);
+    (*pGC->ops->Polylines) (pDraw, pGC, mode, npt, pptInit);
+    XAA_GC_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAPolySegmentFallback(DrawablePtr pDraw, GCPtr pGC, int nseg, xSegment * pSeg)
+{
+    XAA_GC_OP_PROLOGUE_WITH_RETURN(pGC);
+    SYNC_CHECK(pGC);
+    (*pGC->ops->PolySegment) (pDraw, pGC, nseg, pSeg);
+    XAA_GC_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAPolyRectangleFallback(DrawablePtr pDraw,
+                         GCPtr pGC, int nRectsInit, xRectangle *pRectsInit)
+{
+    XAA_GC_OP_PROLOGUE_WITH_RETURN(pGC);
+    SYNC_CHECK(pGC);
+    (*pGC->ops->PolyRectangle) (pDraw, pGC, nRectsInit, pRectsInit);
+    XAA_GC_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAPolyArcFallback(DrawablePtr pDraw, GCPtr pGC, int narcs, xArc * parcs)
+{
+    XAA_GC_OP_PROLOGUE_WITH_RETURN(pGC);
+    SYNC_CHECK(pGC);
+    (*pGC->ops->PolyArc) (pDraw, pGC, narcs, parcs);
+    XAA_GC_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAFillPolygonFallback(DrawablePtr pDraw,
+                       GCPtr pGC,
+                       int shape, int mode, int count, DDXPointPtr ptsIn)
+{
+    XAA_GC_OP_PROLOGUE_WITH_RETURN(pGC);
+    SYNC_CHECK(pGC);
+    (*pGC->ops->FillPolygon) (pDraw, pGC, shape, mode, count, ptsIn);
+    XAA_GC_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAPolyFillRectFallback(DrawablePtr pDraw,
+                        GCPtr pGC, int nrectFill, xRectangle *prectInit)
+{
+    XAA_GC_OP_PROLOGUE_WITH_RETURN(pGC);
+    SYNC_CHECK(pGC);
+    (*pGC->ops->PolyFillRect) (pDraw, pGC, nrectFill, prectInit);
+    XAA_GC_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAPolyFillArcFallback(DrawablePtr pDraw, GCPtr pGC, int narcs, xArc * parcs)
+{
+    XAA_GC_OP_PROLOGUE_WITH_RETURN(pGC);
+    SYNC_CHECK(pGC);
+    (*pGC->ops->PolyFillArc) (pDraw, pGC, narcs, parcs);
+    XAA_GC_OP_EPILOGUE(pGC);
+}
+
+static int
+XAAPolyText8Fallback(DrawablePtr pDraw,
+                     GCPtr pGC, int x, int y, int count, char *chars)
+{
+    int ret;
+
+    XAA_GC_OP_PROLOGUE(pGC);
+    SYNC_CHECK(pGC);
+    ret = (*pGC->ops->PolyText8) (pDraw, pGC, x, y, count, chars);
+    XAA_GC_OP_EPILOGUE(pGC);
+    return ret;
+}
+
+static int
+XAAPolyText16Fallback(DrawablePtr pDraw,
+                      GCPtr pGC, int x, int y, int count, unsigned short *chars)
+{
+    int ret;
+
+    XAA_GC_OP_PROLOGUE(pGC);
+    SYNC_CHECK(pGC);
+    ret = (*pGC->ops->PolyText16) (pDraw, pGC, x, y, count, chars);
+    XAA_GC_OP_EPILOGUE(pGC);
+    return ret;
+}
+
+static void
+XAAImageText8Fallback(DrawablePtr pDraw,
+                      GCPtr pGC, int x, int y, int count, char *chars)
+{
+    XAA_GC_OP_PROLOGUE_WITH_RETURN(pGC);
+    SYNC_CHECK(pGC);
+    (*pGC->ops->ImageText8) (pDraw, pGC, x, y, count, chars);
+    XAA_GC_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAImageText16Fallback(DrawablePtr pDraw,
+                       GCPtr pGC,
+                       int x, int y, int count, unsigned short *chars)
+{
+    XAA_GC_OP_PROLOGUE_WITH_RETURN(pGC);
+    SYNC_CHECK(pGC);
+    (*pGC->ops->ImageText16) (pDraw, pGC, x, y, count, chars);
+    XAA_GC_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAImageGlyphBltFallback(DrawablePtr pDraw,
+                         GCPtr pGC,
+                         int xInit, int yInit,
+                         unsigned int nglyph,
+                         CharInfoPtr * ppci, void *pglyphBase)
+{
+    XAA_GC_OP_PROLOGUE_WITH_RETURN(pGC);
+    SYNC_CHECK(pGC);
+    (*pGC->ops->ImageGlyphBlt) (pDraw, pGC, xInit, yInit, nglyph, ppci,
+                                pglyphBase);
+    XAA_GC_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAPolyGlyphBltFallback(DrawablePtr pDraw,
+                        GCPtr pGC,
+                        int xInit, int yInit,
+                        unsigned int nglyph,
+                        CharInfoPtr * ppci, void *pglyphBase)
+{
+    XAA_GC_OP_PROLOGUE_WITH_RETURN(pGC);
+    SYNC_CHECK(pGC);
+    (*pGC->ops->PolyGlyphBlt) (pDraw, pGC, xInit, yInit, nglyph, ppci,
+                               pglyphBase);
+    XAA_GC_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAPushPixelsFallback(GCPtr pGC,
+                      PixmapPtr pBitMap,
+                      DrawablePtr pDraw, int dx, int dy, int xOrg, int yOrg)
+{
+    XAA_GC_OP_PROLOGUE_WITH_RETURN(pGC);
+    SYNC_CHECK(pGC);
+    (*pGC->ops->PushPixels) (pGC, pBitMap, pDraw, dx, dy, xOrg, yOrg);
+    XAA_GC_OP_EPILOGUE(pGC);
+}
+
+GCOps XAAFallbackOps = {
+    XAAFillSpansFallback, XAASetSpansFallback,
+    XAAPutImageFallback, XAACopyAreaFallback,
+    XAACopyPlaneFallback, XAAPolyPointFallback,
+    XAAPolylinesFallback, XAAPolySegmentFallback,
+    XAAPolyRectangleFallback, XAAPolyArcFallback,
+    XAAFillPolygonFallback, XAAPolyFillRectFallback,
+    XAAPolyFillArcFallback, XAAPolyText8Fallback,
+    XAAPolyText16Fallback, XAAImageText8Fallback,
+    XAAImageText16Fallback, XAAImageGlyphBltFallback,
+    XAAPolyGlyphBltFallback, XAAPushPixelsFallback,
+};
+
+GCOps *
+XAAGetFallbackOps(void)
+{
+    return &XAAFallbackOps;
+}
diff --git a/hw/xfree86/xaa/xaaFillArc.c b/hw/xfree86/xaa/xaaFillArc.c
new file mode 100644
index 000000000..fb7e7201f
--- /dev/null
+++ b/hw/xfree86/xaa/xaaFillArc.c
@@ -0,0 +1,202 @@
+/*
+ * Copyright 1996  The XFree86 Project
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL 
+ * HARM HANEMAAYER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF 
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
+ * SOFTWARE.
+ * 
+ * Written by Harm Hanemaayer (H.Hanemaayer@inter.nl.net).
+ */
+
+/*
+ * Filled solid arcs, based on cfbfillarc.c.
+ *
+ * Fill arc using calls to low-level span fill. Because the math for
+ * each span can be done concurrently with the drawing of the span
+ * with a graphics coprocessor operation, this is faster than just
+ * using miPolyFillArc, which first calculates all the spans and then
+ * calls FillSpans.
+ *
+ * Clipped arcs are dispatched to FillSpans.
+ */
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <limits.h>
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include "pixmapstr.h"
+#include "xf86str.h"
+#include "xaa.h"
+#include "xaalocal.h"
+#include "mifillarc.h"
+#include "mi.h"
+
+/*
+ * This is based on the integer-math versions from mi. Perhaps on a
+ * Pentium, the floating-point (double)-math version is faster.
+ */
+
+static void
+XAAFillEllipseSolid(DrawablePtr pDraw, GCPtr pGC, xArc * arc)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    register int x, y, e;
+    int yk, xk, ym, xm, dx, dy, xorg, yorg;
+    int slw;
+    miFillArcRec info;
+
+    (*infoRec->SetupForSolidFill) (infoRec->pScrn, pGC->fgPixel, pGC->alu,
+                                   pGC->planemask);
+
+    miFillArcSetup(arc, &info);
+    MIFILLARCSETUP();
+    if (pGC->miTranslate) {
+        xorg += pDraw->x;
+        yorg += pDraw->y;
+    }
+    while (y > 0) {
+        MIFILLARCSTEP(slw);
+        if (slw > 0) {
+            (*infoRec->SubsequentSolidFillRect) (infoRec->pScrn, xorg - x,
+                                                 yorg - y, slw, 1);
+            if (miFillArcLower(slw))
+                (*infoRec->SubsequentSolidFillRect) (infoRec->pScrn,
+                                                     xorg - x, yorg + y + dy,
+                                                     slw, 1);
+        }
+    }
+
+    SET_SYNC_FLAG(infoRec);
+}
+
+#define ADDSPAN(l,r) \
+    if (r >= l) \
+	(*infoRec->SubsequentSolidFillRect)( \
+	    infoRec->pScrn, l, ya, r - l + 1, 1);
+
+#define ADDSLICESPANS(flip) \
+    if (!flip) \
+    { \
+	ADDSPAN(xl, xr); \
+    } \
+    else \
+    { \
+	xc = xorg - x; \
+	ADDSPAN(xc, xr); \
+	xc += slw - 1; \
+	ADDSPAN(xl, xc); \
+    }
+
+static void
+XAAFillArcSliceSolid(DrawablePtr pDraw, GCPtr pGC, xArc * arc)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    int yk, xk, ym, xm, dx, dy, xorg, yorg, slw;
+    register int x, y, e;
+    miFillArcRec info;
+    miArcSliceRec slice;
+    int ya, xl, xr, xc;
+
+    (*infoRec->SetupForSolidFill) (infoRec->pScrn, pGC->fgPixel, pGC->alu,
+                                   pGC->planemask);
+
+    miFillArcSetup(arc, &info);
+    miFillArcSliceSetup(arc, &slice, pGC);
+    MIFILLARCSETUP();
+    slw = arc->height;
+    if (slice.flip_top || slice.flip_bot)
+        slw += (arc->height >> 1) + 1;
+    if (pGC->miTranslate) {
+        xorg += pDraw->x;
+        yorg += pDraw->y;
+        slice.edge1.x += pDraw->x;
+        slice.edge2.x += pDraw->x;
+    }
+    while (y > 0) {
+        MIFILLARCSTEP(slw);
+        MIARCSLICESTEP(slice.edge1);
+        MIARCSLICESTEP(slice.edge2);
+        if (miFillSliceUpper(slice)) {
+            ya = yorg - y;
+            MIARCSLICEUPPER(xl, xr, slice, slw);
+
+            ADDSLICESPANS(slice.flip_top);
+        }
+        if (miFillSliceLower(slice)) {
+            ya = yorg + y + dy;
+            MIARCSLICELOWER(xl, xr, slice, slw);
+            ADDSLICESPANS(slice.flip_bot);
+        }
+    }
+
+    SET_SYNC_FLAG(infoRec);
+}
+
+void
+XAAPolyFillArcSolid(DrawablePtr pDraw, GCPtr pGC, int narcs, xArc * parcs)
+{
+    register xArc *arc;
+    register int i;
+    int x2, y2;
+    BoxRec box;
+    RegionPtr cclip;
+
+    cclip = pGC->pCompositeClip;
+
+    if (!RegionNumRects(cclip))
+        return;
+
+    for (arc = parcs, i = narcs; --i >= 0; arc++) {
+        if (miFillArcEmpty(arc))
+            continue;
+        if (miCanFillArc(arc)) {
+            box.x1 = arc->x + pDraw->x;
+            box.y1 = arc->y + pDraw->y;
+            /*
+             * Because box.x2 and box.y2 get truncated to 16 bits, and the
+             * RECT_IN_REGION test treats the resulting number as a signed
+             * integer, the RECT_IN_REGION test alone can go the wrong way.
+             * This can result in a server crash because the rendering
+             * routines in this file deal directly with cpu addresses
+             * of pixels to be stored, and do not clip or otherwise check
+             * that all such addresses are within their respective pixmaps.
+             * So we only allow the RECT_IN_REGION test to be used for
+             * values that can be expressed correctly in a signed short.
+             */
+            x2 = box.x1 + (int) arc->width + 1;
+            box.x2 = x2;
+            y2 = box.y1 + (int) arc->height + 1;
+            box.y2 = y2;
+            if ((x2 <= SHRT_MAX) && (y2 <= SHRT_MAX) &&
+                (RegionContainsRect(cclip, &box) == rgnIN)) {
+                if ((arc->angle2 >= FULLCIRCLE) || (arc->angle2 <= -FULLCIRCLE))
+                    XAAFillEllipseSolid(pDraw, pGC, arc);
+                else
+                    XAAFillArcSliceSolid(pDraw, pGC, arc);
+                continue;
+            }
+        }
+        miPolyFillArc(pDraw, pGC, 1, arc);
+    }
+}
diff --git a/hw/xfree86/xaa/xaaFillPoly.c b/hw/xfree86/xaa/xaaFillPoly.c
new file mode 100644
index 000000000..0cdedf57e
--- /dev/null
+++ b/hw/xfree86/xaa/xaaFillPoly.c
@@ -0,0 +1,991 @@
+
+/*
+ * Copyright 1996  The XFree86 Project
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a 
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation 
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
+ * and/or sell copies of the Software, and to permit persons to whom the 
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL 
+ * HARM HANEMAAYER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF 
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
+ * SOFTWARE.
+ * 
+ */
+
+/*
+ * Written by Mark Vojkovich.  Loosly based on an original version
+ * written by Harm Hanemaayer (H.Hanemaayer@inter.nl.net) which
+ * only did solid rectangles and didn't have trapezoid support.
+ *
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include "pixmapstr.h"
+#include "xf86str.h"
+#include "mi.h"
+#include "micoord.h"
+
+#include "xaa.h"
+#include "xaalocal.h"
+
+#define POLY_USE_MI		0
+#define POLY_FULLY_CLIPPED	1
+#define POLY_IS_EASY		2
+
+#define Setup(c,x,vertex,dx,dy,e,sign,step,DX) {\
+    x = intToX(vertex); \
+    if ((dy = intToY(c) - y)) { \
+    	DX = dx = intToX(c) - x; \
+	step = 0; \
+    	if (dx >= 0) \
+    	{ \
+	    e = 0; \
+	    sign = 1; \
+	    if (dx >= dy) {\
+	    	step = dx / dy; \
+	    	dx %= dy; \
+	    } \
+    	} \
+    	else \
+    	{ \
+	    e = 1 - dy; \
+	    sign = -1; \
+	    dx = -dx; \
+	    if (dx >= dy) { \
+		step = - (dx / dy); \
+		dx %= dy; \
+	    } \
+    	} \
+    } \
+    x += origin; \
+    vertex = c; \
+}
+
+#define Step(x,dx,dy,e,sign,step) {\
+    x += step; \
+    if ((e += dx) > 0) \
+    { \
+	x += sign; \
+	e -= dy; \
+    } \
+}
+
+#define FixError(x, dx, dy, e, sign, step, h)	{	\
+	   e += (h) * dx;				\
+	   x += (h) * step;				\
+	   if(e > 0) {					\
+		x += e * sign/dy;			\
+		e %= dy;				\
+	   	if(e) {					\
+		   x += sign;				\
+		   e -= dy;				\
+		}					\
+	   } 	 					\
+}
+
+/*
+   XAAIsEasyPoly -
+
+   Checks CoordModeOrigin one rect polygons to see if we need
+   to use Mi.
+   Returns: POLY_USE_MI, POLY_FULLY_CLIPPED or POLY_IS_EASY
+	as well as the pointer to the "top" point and the y
+	extents.
+*/
+
+int
+XAAIsEasyPolygon(DDXPointPtr ptsIn, int count, BoxPtr extents, int origin, DDXPointPtr * topPoint,      /* return */
+                 int *topY, int *bottomY,       /* return */
+                 int shape)
+{
+    int c = 0, vertex1, vertex2;
+
+    *topY = 32767;
+    *bottomY = 0;
+
+    origin -= (origin & 0x8000) << 1;
+    vertex1 = extents->x1 - origin;
+    vertex2 = extents->x2 - origin /* - 0x00010001 */ ;
+    /* I think this was an error in cfb ^ */
+
+    if (shape == Convex) {
+        while (count--) {
+            c = *((int *) ptsIn);
+            if (((c - vertex1) | (vertex2 - c)) & 0x80008000)
+                return POLY_USE_MI;
+
+            c = intToY(c);
+            if (c < *topY) {
+                *topY = c;
+                *topPoint = ptsIn;
+            }
+            ptsIn++;
+            if (c > *bottomY)
+                *bottomY = c;
+        }
+    }
+    else {
+        int yFlip = 0;
+        int dx2, dx1, x1, x2;
+
+        x2 = x1 = -1;
+        dx2 = dx1 = 1;
+
+        while (count--) {
+            c = *((int *) ptsIn);
+            if (((c - vertex1) | (vertex2 - c)) & 0x80008000)
+                return POLY_USE_MI;
+            c = intToY(c);
+            if (c < *topY) {
+                *topY = c;
+                *topPoint = ptsIn;
+            }
+            ptsIn++;
+            if (c > *bottomY)
+                *bottomY = c;
+            if (c == x1)
+                continue;
+            if (dx1 > 0) {
+                if (x2 < 0)
+                    x2 = c;
+                else
+                    dx2 = dx1 = (c - x1) >> 31;
+            }
+            else if ((c - x1) >> 31 != dx1) {
+                dx1 = ~dx1;
+                yFlip++;
+            }
+            x1 = c;
+        }
+        x1 = (x2 - c) >> 31;
+        if (x1 != dx1)
+            yFlip++;
+        if (x1 != dx2)
+            yFlip++;
+        if (yFlip != 2) {
+            if (*topY == *bottomY)
+                return POLY_FULLY_CLIPPED;
+            else
+                return POLY_USE_MI;
+        }
+    }
+    if (*topY == *bottomY)
+        return POLY_FULLY_CLIPPED;
+
+    return POLY_IS_EASY;
+}
+
+void
+XAAFillPolygonSolid(DrawablePtr pDraw,
+                    GCPtr pGC,
+                    int shape, int mode, int count, DDXPointPtr ptsIn)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    int origin, vertex1, vertex2;
+    int *vertex1p, *vertex2p, *endp;
+    int x1 = 0, x2 = 0;
+    int dx1 = 0, dx2 = 0, dy1 = 0, dy2 = 0;
+    int DX1 = 0, DX2 = 0, e1 = 0, e2 = 0;
+    int step1 = 0, step2 = 0, sign1 = 0, sign2 = 0;
+    int c, y, maxy, h, yoffset;
+    DDXPointPtr topPoint;
+
+    if (!RegionNumRects(pGC->pCompositeClip))
+        return;
+
+    if (mode == CoordModePrevious) {
+        register DDXPointPtr ppt = ptsIn + 1;
+
+        for (origin = 1; origin < count; origin++, ppt++) {
+            ppt->x += (ppt - 1)->x;
+            ppt->y += (ppt - 1)->y;
+        }
+        mode = CoordModeOrigin;
+    }
+
+    if (RegionNumRects(pGC->pCompositeClip) != 1) {
+        miFillPolygon(pDraw, pGC, shape, mode, count, ptsIn);
+        return;
+    }
+
+    origin = coordToInt(pDraw->x, pDraw->y);
+
+    switch (XAAIsEasyPolygon(ptsIn, count, &pGC->pCompositeClip->extents,
+                             origin, &topPoint, &y, &maxy, shape)) {
+    case POLY_USE_MI:
+        miFillPolygon(pDraw, pGC, shape, mode, count, ptsIn);
+    case POLY_FULLY_CLIPPED:
+        return;
+    }
+
+    endp = (int *) ptsIn + count;
+    vertex2p = vertex1p = (int *) topPoint;
+    origin = pDraw->x;
+    yoffset = pDraw->y;
+    vertex2 = vertex1 = *vertex2p++;
+    if (vertex2p == endp)
+        vertex2p = (int *) ptsIn;
+
+    (*infoRec->SetupForSolidFill) (infoRec->pScrn, pGC->fgPixel, pGC->alu,
+                                   pGC->planemask);
+
+    while (1) {
+        if (y == intToY(vertex1)) {
+            do {
+                if (vertex1p == (int *) ptsIn)
+                    vertex1p = endp;
+                c = *--vertex1p;
+                Setup(c, x1, vertex1, dx1, dy1, e1, sign1, step1, DX1)
+            } while (y >= intToY(vertex1));
+            h = dy1;
+        }
+        else {
+            Step(x1, dx1, dy1, e1, sign1, step1)
+                h = intToY(vertex1) - y;
+        }
+        if (y == intToY(vertex2)) {
+            do {
+                c = *vertex2p++;
+                if (vertex2p == endp)
+                    vertex2p = (int *) ptsIn;
+                Setup(c, x2, vertex2, dx2, dy2, e2, sign2, step2, DX2)
+            } while (y >= intToY(vertex2));
+            if (dy2 < h)
+                h = dy2;
+        }
+        else {
+            Step(x2, dx2, dy2, e2, sign2, step2)
+                if ((c = (intToY(vertex2) - y)) < h)
+                h = c;
+        }
+
+        /* fill spans for this segment */
+        if (DX1 | DX2) {
+            if (infoRec->SubsequentSolidFillTrap && (h > 6)) {
+                if (x1 == x2) {
+                    while (x1 == x2) {
+                        y++;
+                        if (!--h)
+                            break;
+                        Step(x1, dx1, dy1, e1, sign1, step1)
+                            Step(x2, dx2, dy2, e2, sign2, step2)
+                    }
+                    if (y == maxy)
+                        break;
+                    if (!h)
+                        continue;
+                }
+
+                if (x1 < x2)
+                    (*infoRec->SubsequentSolidFillTrap) (infoRec->pScrn,
+                                                         y + yoffset, h,
+                                                         x1, DX1, dy1, e1,
+                                                         x2 - 1, DX2, dy2, e2);
+                else
+                    (*infoRec->SubsequentSolidFillTrap) (infoRec->pScrn,
+                                                         y + yoffset, h,
+                                                         x2, DX2, dy2, e2,
+                                                         x1 - 1, DX1, dy1, e1);
+                y += h;
+                if (--h) {
+                    FixError(x1, dx1, dy1, e1, sign1, step1, h);
+                    FixError(x2, dx2, dy2, e2, sign2, step2, h);
+                    h = 0;
+                }
+            }
+            else {
+                while (1) {
+                    if (x2 > x1)
+                        (*infoRec->SubsequentSolidFillRect) (infoRec->pScrn,
+                                                             x1, y + yoffset,
+                                                             x2 - x1, 1);
+                    else if (x1 > x2)
+                        (*infoRec->SubsequentSolidFillRect) (infoRec->pScrn,
+                                                             x2, y + yoffset,
+                                                             x1 - x2, 1);
+                    y++;
+                    if (!--h)
+                        break;
+                    Step(x1, dx1, dy1, e1, sign1, step1)
+                        Step(x2, dx2, dy2, e2, sign2, step2)
+                }
+            }
+        }
+        else {
+            if (x2 > x1)
+                (*infoRec->SubsequentSolidFillRect) (infoRec->pScrn,
+                                                     x1, y + yoffset, x2 - x1,
+                                                     h);
+            else if (x1 > x2)
+                (*infoRec->SubsequentSolidFillRect) (infoRec->pScrn,
+                                                     x2, y + yoffset, x1 - x2,
+                                                     h);
+
+            y += h;
+            h = 0;
+        }
+        if (y == maxy)
+            break;
+    }
+    SET_SYNC_FLAG(infoRec);
+}
+
+void
+XAAFillPolygonHelper(ScrnInfoPtr pScrn,
+                     DDXPointPtr ptsIn,
+                     int count,
+                     DDXPointPtr topPoint,
+                     int y,
+                     int maxy,
+                     int origin,
+                     RectFuncPtr RectFunc,
+                     TrapFuncPtr TrapFunc,
+                     int xorg, int yorg, XAACacheInfoPtr pCache)
+{
+    int *vertex1p, *vertex2p, *endp;
+    int vertex1, vertex2;
+    int x1 = 0, x2 = 0;
+    int dx1 = 0, dx2 = 0, dy1 = 0, dy2 = 0;
+    int DX1 = 0, DX2 = 0, e1 = 0, e2 = 0;
+    int step1 = 0, step2 = 0, sign1 = 0, sign2 = 0;
+    int c, h, yoffset;
+
+    endp = (int *) ptsIn + count;
+    vertex2p = vertex1p = (int *) topPoint;
+    yoffset = intToY(origin);
+    origin = intToX(origin);
+    vertex2 = vertex1 = *vertex2p++;
+    if (vertex2p == endp)
+        vertex2p = (int *) ptsIn;
+
+    while (1) {
+        if (y == intToY(vertex1)) {
+            do {
+                if (vertex1p == (int *) ptsIn)
+                    vertex1p = endp;
+                c = *--vertex1p;
+                Setup(c, x1, vertex1, dx1, dy1, e1, sign1, step1, DX1)
+            } while (y >= intToY(vertex1));
+            h = dy1;
+        }
+        else {
+            Step(x1, dx1, dy1, e1, sign1, step1)
+                h = intToY(vertex1) - y;
+        }
+        if (y == intToY(vertex2)) {
+            do {
+                c = *vertex2p++;
+                if (vertex2p == endp)
+                    vertex2p = (int *) ptsIn;
+                Setup(c, x2, vertex2, dx2, dy2, e2, sign2, step2, DX2)
+            } while (y >= intToY(vertex2));
+            if (dy2 < h)
+                h = dy2;
+        }
+        else {
+            Step(x2, dx2, dy2, e2, sign2, step2)
+                if ((c = (intToY(vertex2) - y)) < h)
+                h = c;
+        }
+
+        /* fill spans for this segment */
+        if (DX1 | DX2) {
+            if (TrapFunc && (h > 6)) {
+                if (x1 == x2) {
+                    while (x1 == x2) {
+                        y++;
+                        if (!--h)
+                            break;
+                        Step(x1, dx1, dy1, e1, sign1, step1)
+                            Step(x2, dx2, dy2, e2, sign2, step2)
+                    }
+                    if (y == maxy)
+                        break;
+                    if (!h)
+                        continue;
+                }
+
+                if (x1 < x2)
+                    (*TrapFunc) (pScrn, y + yoffset, h,
+                                 x1, DX1, dy1, e1,
+                                 x2 - 1, DX2, dy2, e2, xorg, yorg, pCache);
+                else
+                    (*TrapFunc) (pScrn, y + yoffset, h,
+                                 x2, DX2, dy2, e2,
+                                 x1 - 1, DX1, dy1, e1, xorg, yorg, pCache);
+                y += h;
+                if (--h) {
+                    FixError(x1, dx1, dy1, e1, sign1, step1, h);
+                    FixError(x2, dx2, dy2, e2, sign2, step2, h);
+                    h = 0;
+                }
+            }
+            else {
+                while (1) {
+                    if (x2 > x1)
+                        (*RectFunc) (pScrn,
+                                     x1, y + yoffset, x2 - x1, 1, xorg, yorg,
+                                     pCache);
+                    else if (x1 > x2)
+                        (*RectFunc) (pScrn,
+                                     x2, y + yoffset, x1 - x2, 1, xorg, yorg,
+                                     pCache);
+                    y++;
+                    if (!--h)
+                        break;
+                    Step(x1, dx1, dy1, e1, sign1, step1)
+                        Step(x2, dx2, dy2, e2, sign2, step2)
+                }
+            }
+        }
+        else {
+            if (x2 > x1)
+                (*RectFunc) (pScrn,
+                             x1, y + yoffset, x2 - x1, h, xorg, yorg, pCache);
+            else if (x1 > x2)
+                (*RectFunc) (pScrn,
+                             x2, y + yoffset, x1 - x2, h, xorg, yorg, pCache);
+
+            y += h;
+            h = 0;
+        }
+        if (y == maxy)
+            break;
+    }
+}
+
+        /*****************\
+	|  Solid Helpers  |
+	\*****************/
+
+static void
+SolidTrapHelper(ScrnInfoPtr pScrn,
+                int y, int h,
+                int x1, int dx1, int dy1, int e1,
+                int x2, int dx2, int dy2, int e2,
+                int xorg, int yorg, XAACacheInfoPtr pCache)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+
+    (*infoRec->SubsequentSolidFillTrap) (pScrn,
+                                         y, h, x1, dx1, dy1, e1, x2, dx2, dy2,
+                                         e2);
+}
+
+static void
+SolidRectHelper(ScrnInfoPtr pScrn,
+                int x, int y, int w, int h,
+                int xorg, int yorg, XAACacheInfoPtr pCache)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+
+    (*infoRec->SubsequentSolidFillRect) (pScrn, x, y, w, h);
+}
+
+        /*********************\
+	|  Mono 8x8 Patterns  |
+	\*********************/
+
+static void
+Mono8x8PatternTrapHelper_ScreenOrigin(ScrnInfoPtr pScrn,
+                                      int y, int h,
+                                      int x1, int dx1, int dy1, int e1,
+                                      int x2, int dx2, int dy2, int e2,
+                                      int xorg, int yorg,
+                                      XAACacheInfoPtr pCache)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+
+    (*infoRec->SubsequentMono8x8PatternFillTrap) (pScrn, xorg, yorg,
+                                                  y, h, x1, dx1, dy1, e1, x2,
+                                                  dx2, dy2, e2);
+}
+
+static void
+Mono8x8PatternRectHelper_ScreenOrigin(ScrnInfoPtr pScrn,
+                                      int x, int y, int w, int h,
+                                      int xorg, int yorg,
+                                      XAACacheInfoPtr pCache)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+
+    (*infoRec->SubsequentMono8x8PatternFillRect) (pScrn, xorg, yorg,
+                                                  x, y, w, h);
+}
+
+static void
+Mono8x8PatternRectHelper(ScrnInfoPtr pScrn,
+                         int x, int y, int w, int h,
+                         int xorg, int yorg, XAACacheInfoPtr pCache)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+
+    xorg = (x - xorg) & 0x07;
+    yorg = (y - yorg) & 0x07;
+
+    if (!(infoRec->Mono8x8PatternFillFlags &
+          HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
+        if (infoRec->Mono8x8PatternFillFlags & HARDWARE_PATTERN_PROGRAMMED_BITS) {
+            int patx = pCache->pat0;
+            int paty = pCache->pat1;
+
+            XAARotateMonoPattern(&patx, &paty, xorg, yorg,
+                                 (infoRec->Mono8x8PatternFillFlags &
+                                  BIT_ORDER_IN_BYTE_MSBFIRST));
+            xorg = patx;
+            yorg = paty;
+        }
+        else {
+            int slot = (yorg << 3) + xorg;
+
+            xorg = pCache->x + pCache->offsets[slot].x;
+            yorg = pCache->y + pCache->offsets[slot].y;
+        }
+    }
+
+    (*infoRec->SubsequentMono8x8PatternFillRect) (pScrn, xorg, yorg,
+                                                  x, y, w, h);
+}
+
+        /****************\
+	|  Cache Expand  |
+	\****************/
+
+static void
+CacheExpandRectHelper(ScrnInfoPtr pScrn,
+                      int X, int Y, int Width, int Height,
+                      int xorg, int yorg, XAACacheInfoPtr pCache)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int x, phaseY, phaseX, skipleft, w, blit_w, blit_h;
+    int cacheWidth;
+
+    cacheWidth = (pCache->w * pScrn->bitsPerPixel) /
+        infoRec->CacheColorExpandDensity;
+
+    phaseY = (Y - yorg) % pCache->orig_h;
+    if (phaseY < 0)
+        phaseY += pCache->orig_h;
+    phaseX = (X - xorg) % pCache->orig_w;
+    if (phaseX < 0)
+        phaseX += pCache->orig_w;
+
+    while (1) {
+        w = Width;
+        skipleft = phaseX;
+        x = X;
+        blit_h = pCache->h - phaseY;
+        if (blit_h > Height)
+            blit_h = Height;
+
+        while (1) {
+            blit_w = cacheWidth - skipleft;
+            if (blit_w > w)
+                blit_w = w;
+            (*infoRec->SubsequentScreenToScreenColorExpandFill) (pScrn, x, Y,
+                                                                 blit_w, blit_h,
+                                                                 pCache->x,
+                                                                 pCache->y +
+                                                                 phaseY,
+                                                                 skipleft);
+            w -= blit_w;
+            if (!w)
+                break;
+            x += blit_w;
+            skipleft = (skipleft + blit_w) % pCache->orig_w;
+        }
+        Height -= blit_h;
+        if (!Height)
+            break;
+        Y += blit_h;
+        phaseY = (phaseY + blit_h) % pCache->orig_h;
+    }
+}
+
+        /**************\
+	|  Cache Blit  |
+	\**************/
+
+static void
+CacheBltRectHelper(ScrnInfoPtr pScrn,
+                   int X, int Y, int Width, int Height,
+                   int xorg, int yorg, XAACacheInfoPtr pCache)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int x, phaseY, phaseX, skipleft, w, blit_w, blit_h;
+
+    phaseY = (Y - yorg) % pCache->orig_h;
+    if (phaseY < 0)
+        phaseY += pCache->orig_h;
+    phaseX = (X - xorg) % pCache->orig_w;
+    if (phaseX < 0)
+        phaseX += pCache->orig_w;
+
+    while (1) {
+        w = Width;
+        skipleft = phaseX;
+        x = X;
+        blit_h = pCache->h - phaseY;
+        if (blit_h > Height)
+            blit_h = Height;
+
+        while (1) {
+            blit_w = pCache->w - skipleft;
+            if (blit_w > w)
+                blit_w = w;
+            (*infoRec->SubsequentScreenToScreenCopy) (pScrn,
+                                                      pCache->x + skipleft,
+                                                      pCache->y + phaseY, x, Y,
+                                                      blit_w, blit_h);
+            w -= blit_w;
+            if (!w)
+                break;
+            x += blit_w;
+            skipleft = (skipleft + blit_w) % pCache->orig_w;
+        }
+        Height -= blit_h;
+        if (!Height)
+            break;
+        Y += blit_h;
+        phaseY = (phaseY + blit_h) % pCache->orig_h;
+    }
+}
+
+        /**********************\
+	|   Stippled Polygons  |
+	\**********************/
+
+void
+XAAFillPolygonStippled(DrawablePtr pDraw,
+                       GCPtr pGC,
+                       int shape, int mode, int count, DDXPointPtr ptsIn)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->stipple);
+    int origin, type, patx, paty, fg, bg;
+    int y, maxy, xorg, yorg;
+    DDXPointPtr topPoint;
+    XAACacheInfoPtr pCache = NULL;
+    RectFuncPtr RectFunc = NULL;
+    TrapFuncPtr TrapFunc = NULL;
+
+    if (!RegionNumRects(pGC->pCompositeClip))
+        return;
+
+    if (mode == CoordModePrevious) {
+        register DDXPointPtr ppt = ptsIn + 1;
+
+        for (origin = 1; origin < count; origin++, ppt++) {
+            ppt->x += (ppt - 1)->x;
+            ppt->y += (ppt - 1)->y;
+        }
+        mode = CoordModeOrigin;
+    }
+
+    if (RegionNumRects(pGC->pCompositeClip) != 1) {
+        miFillPolygon(pDraw, pGC, shape, mode, count, ptsIn);
+        return;
+    }
+
+    if (pGC->fillStyle == FillStippled) {
+        type = (*infoRec->StippledFillChooser) (pGC);
+        fg = pGC->fgPixel;
+        bg = -1;
+    }
+    else {
+        type = (*infoRec->OpaqueStippledFillChooser) (pGC);
+        fg = pGC->fgPixel;
+        bg = pGC->bgPixel;
+    }
+
+    if (!type) {
+        (*XAAFallbackOps.FillPolygon) (pDraw, pGC, shape, mode, count, ptsIn);
+        return;
+    }
+
+    if ((type == DO_COLOR_EXPAND) || (type == DO_COLOR_8x8)) {
+        miFillPolygon(pDraw, pGC, shape, mode, count, ptsIn);
+        return;
+    }
+
+    origin = pDraw->x;
+
+    switch (XAAIsEasyPolygon(ptsIn, count, &pGC->pCompositeClip->extents,
+                             origin, &topPoint, &y, &maxy, shape)) {
+    case POLY_USE_MI:
+        miFillPolygon(pDraw, pGC, shape, mode, count, ptsIn);
+    case POLY_FULLY_CLIPPED:
+        return;
+    }
+
+    xorg = (pDraw->x + pGC->patOrg.x);
+    yorg = (pDraw->y + pGC->patOrg.y);
+
+    if ((fg == bg) && (bg != -1) && infoRec->SetupForSolidFill) {
+
+        (*infoRec->SetupForSolidFill) (infoRec->pScrn, fg,
+                                       pGC->alu, pGC->planemask);
+
+        RectFunc = SolidRectHelper;
+        TrapFunc = infoRec->SubsequentSolidFillTrap ? SolidTrapHelper : NULL;
+    }
+    else
+        switch (type) {
+        case DO_MONO_8x8:
+            patx = pPriv->pattern0;
+            paty = pPriv->pattern1;
+            if (infoRec->Mono8x8PatternFillFlags &
+                HARDWARE_PATTERN_SCREEN_ORIGIN) {
+                xorg = (-xorg) & 0x07;
+                yorg = (-yorg) & 0x07;
+                if (infoRec->Mono8x8PatternFillFlags &
+                    HARDWARE_PATTERN_PROGRAMMED_BITS) {
+                    if (!(infoRec->Mono8x8PatternFillFlags &
+                          HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
+                        XAARotateMonoPattern(&patx, &paty, xorg, yorg,
+                                             (infoRec->Mono8x8PatternFillFlags &
+                                              BIT_ORDER_IN_BYTE_MSBFIRST));
+                        xorg = patx;
+                        yorg = paty;
+                    }
+                }
+                else {
+                    XAACacheInfoPtr pCache =
+                        (*infoRec->CacheMono8x8Pattern) (infoRec->pScrn, patx,
+                                                         paty);
+                    patx = pCache->x;
+                    paty = pCache->y;
+                    if (!(infoRec->Mono8x8PatternFillFlags &
+                          HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
+                        int slot = (yorg << 3) + xorg;
+
+                        patx += pCache->offsets[slot].x;
+                        paty += pCache->offsets[slot].y;
+                        xorg = patx;
+                        yorg = paty;
+                    }
+                }
+                RectFunc = Mono8x8PatternRectHelper_ScreenOrigin;
+                if (infoRec->SubsequentMono8x8PatternFillTrap)
+                    TrapFunc = Mono8x8PatternTrapHelper_ScreenOrigin;
+            }
+            else {              /* !HARDWARE_PATTERN_SCREEN_ORIGIN */
+                if (!(infoRec->Mono8x8PatternFillFlags &
+                      HARDWARE_PATTERN_PROGRAMMED_BITS)) {
+                    pCache =
+                        (*infoRec->CacheMono8x8Pattern) (infoRec->pScrn, patx,
+                                                         paty);
+                    patx = pCache->x;
+                    paty = pCache->y;
+                }
+                else {
+                    pCache = &(infoRec->ScratchCacheInfoRec);
+                    pCache->pat0 = patx;
+                    pCache->pat1 = paty;
+                }
+                RectFunc = Mono8x8PatternRectHelper;
+            }
+
+            (*infoRec->SetupForMono8x8PatternFill) (infoRec->pScrn,
+                                                    patx, paty, fg, bg,
+                                                    pGC->alu, pGC->planemask);
+            break;
+        case DO_CACHE_EXPAND:
+            pCache =
+                (*infoRec->CacheMonoStipple) (infoRec->pScrn, pGC->stipple);
+
+            (*infoRec->SetupForScreenToScreenColorExpandFill) (infoRec->pScrn,
+                                                               fg, bg, pGC->alu,
+                                                               pGC->planemask);
+
+            RectFunc = CacheExpandRectHelper;
+            break;
+        case DO_CACHE_BLT:
+            pCache = (*infoRec->CacheStipple) (infoRec->pScrn, pGC->stipple,
+                                               fg, bg);
+            (*infoRec->SetupForScreenToScreenCopy) (infoRec->pScrn, 1, 1,
+                                                    pGC->alu, pGC->planemask,
+                                                    pCache->trans_color);
+
+            RectFunc = CacheBltRectHelper;
+            break;
+        default:
+            return;
+        }
+
+    XAAFillPolygonHelper(infoRec->pScrn, ptsIn, count, topPoint,
+                         y, maxy, origin, RectFunc, TrapFunc, xorg, yorg,
+                         pCache);
+
+    SET_SYNC_FLAG(infoRec);
+}
+
+        /*******************\
+	|   Tiled Polygons  |
+	\*******************/
+
+void
+XAAFillPolygonTiled(DrawablePtr pDraw,
+                    GCPtr pGC,
+                    int shape, int mode, int count, DDXPointPtr ptsIn)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);
+    int origin, type, patx, paty;
+    int y, maxy, xorg, yorg;
+    DDXPointPtr topPoint;
+    XAACacheInfoPtr pCache = NULL;
+    RectFuncPtr RectFunc = NULL;
+    TrapFuncPtr TrapFunc = NULL;
+
+    if (!RegionNumRects(pGC->pCompositeClip))
+        return;
+
+    if (mode == CoordModePrevious) {
+        register DDXPointPtr ppt = ptsIn + 1;
+
+        for (origin = 1; origin < count; origin++, ppt++) {
+            ppt->x += (ppt - 1)->x;
+            ppt->y += (ppt - 1)->y;
+        }
+        mode = CoordModeOrigin;
+    }
+
+    if (RegionNumRects(pGC->pCompositeClip) != 1) {
+        miFillPolygon(pDraw, pGC, shape, mode, count, ptsIn);
+        return;
+    }
+
+    type = (*infoRec->TiledFillChooser) (pGC);
+
+    if (!type || (type == DO_IMAGE_WRITE)) {
+        (*XAAFallbackOps.FillPolygon) (pDraw, pGC, shape, mode, count, ptsIn);
+        return;
+    }
+
+    if (type == DO_COLOR_8x8) {
+        miFillPolygon(pDraw, pGC, shape, mode, count, ptsIn);
+        return;
+    }
+
+    origin = pDraw->x;
+
+    switch (XAAIsEasyPolygon(ptsIn, count, &pGC->pCompositeClip->extents,
+                             origin, &topPoint, &y, &maxy, shape)) {
+    case POLY_USE_MI:
+        miFillPolygon(pDraw, pGC, shape, mode, count, ptsIn);
+    case POLY_FULLY_CLIPPED:
+        return;
+    }
+
+    xorg = (pDraw->x + pGC->patOrg.x);
+    yorg = (pDraw->y + pGC->patOrg.y);
+
+    switch (type) {
+    case DO_MONO_8x8:
+        patx = pPriv->pattern0;
+        paty = pPriv->pattern1;
+        if (infoRec->Mono8x8PatternFillFlags & HARDWARE_PATTERN_SCREEN_ORIGIN) {
+            xorg = (-xorg) & 0x07;
+            yorg = (-yorg) & 0x07;
+            if (infoRec->Mono8x8PatternFillFlags &
+                HARDWARE_PATTERN_PROGRAMMED_BITS) {
+                if (!(infoRec->Mono8x8PatternFillFlags &
+                      HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
+                    XAARotateMonoPattern(&patx, &paty, xorg, yorg,
+                                         (infoRec->Mono8x8PatternFillFlags &
+                                          BIT_ORDER_IN_BYTE_MSBFIRST));
+                    xorg = patx;
+                    yorg = paty;
+                }
+            }
+            else {
+                XAACacheInfoPtr pCache =
+                    (*infoRec->CacheMono8x8Pattern) (infoRec->pScrn, patx,
+                                                     paty);
+                patx = pCache->x;
+                paty = pCache->y;
+                if (!(infoRec->Mono8x8PatternFillFlags &
+                      HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
+                    int slot = (yorg << 3) + xorg;
+
+                    patx += pCache->offsets[slot].x;
+                    paty += pCache->offsets[slot].y;
+                    xorg = patx;
+                    yorg = paty;
+                }
+            }
+            RectFunc = Mono8x8PatternRectHelper_ScreenOrigin;
+            if (infoRec->SubsequentMono8x8PatternFillTrap)
+                TrapFunc = Mono8x8PatternTrapHelper_ScreenOrigin;
+        }
+        else {                  /* !HARDWARE_PATTERN_SCREEN_ORIGIN */
+            if (!(infoRec->Mono8x8PatternFillFlags &
+                  HARDWARE_PATTERN_PROGRAMMED_BITS)) {
+                pCache =
+                    (*infoRec->CacheMono8x8Pattern) (infoRec->pScrn, patx,
+                                                     paty);
+                patx = pCache->x;
+                paty = pCache->y;
+            }
+            else {
+                pCache = &(infoRec->ScratchCacheInfoRec);
+                pCache->pat0 = patx;
+                pCache->pat1 = paty;
+            }
+            RectFunc = Mono8x8PatternRectHelper;
+        }
+
+        (*infoRec->SetupForMono8x8PatternFill) (infoRec->pScrn,
+                                                patx, paty, pPriv->fg,
+                                                pPriv->bg, pGC->alu,
+                                                pGC->planemask);
+        break;
+    case DO_CACHE_BLT:
+        pCache = (*infoRec->CacheTile) (infoRec->pScrn, pGC->tile.pixmap);
+        (*infoRec->SetupForScreenToScreenCopy) (infoRec->pScrn, 1, 1,
+                                                pGC->alu, pGC->planemask, -1);
+
+        RectFunc = CacheBltRectHelper;
+        break;
+    case DO_PIXMAP_COPY:
+        pCache = &(infoRec->ScratchCacheInfoRec);
+        pCache->x = pPriv->offscreenArea->box.x1;
+        pCache->y = pPriv->offscreenArea->box.y1;
+        pCache->w = pCache->orig_w = pPriv->offscreenArea->box.x2 - pCache->x;
+        pCache->h = pCache->orig_h = pPriv->offscreenArea->box.y2 - pCache->y;
+
+        (*infoRec->SetupForScreenToScreenCopy) (infoRec->pScrn, 1, 1,
+                                                pGC->alu, pGC->planemask, -1);
+
+        RectFunc = CacheBltRectHelper;
+        break;
+    default:
+        return;
+    }
+
+    XAAFillPolygonHelper(infoRec->pScrn, ptsIn, count, topPoint,
+                         y, maxy, origin, RectFunc, TrapFunc, xorg, yorg,
+                         pCache);
+
+    SET_SYNC_FLAG(infoRec);
+}
diff --git a/hw/xfree86/xaa/xaaFillRect.c b/hw/xfree86/xaa/xaaFillRect.c
new file mode 100644
index 000000000..ec0fb9df7
--- /dev/null
+++ b/hw/xfree86/xaa/xaaFillRect.c
@@ -0,0 +1,1101 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include "pixmapstr.h"
+#include "xf86str.h"
+#include "xaa.h"
+#include "xaalocal.h"
+
+static void XAARenderSolidRects(GCPtr, int, BoxPtr, int, int);
+static void XAARenderColor8x8Rects(GCPtr, int, BoxPtr, int, int);
+static void XAARenderMono8x8Rects(GCPtr, int, BoxPtr, int, int);
+static void XAARenderColorExpandRects(GCPtr, int, BoxPtr, int, int);
+static void XAARenderCacheExpandRects(GCPtr, int, BoxPtr, int, int);
+static void XAARenderCacheBltRects(GCPtr, int, BoxPtr, int, int);
+static void XAARenderImageWriteRects(GCPtr, int, BoxPtr, int, int);
+static void XAARenderPixmapCopyRects(GCPtr, int, BoxPtr, int, int);
+
+void
+XAAPolyFillRect(DrawablePtr pDraw, GCPtr pGC, int nrectFill,    /* number of rectangles to fill */
+                xRectangle *prectInit   /* Pointer to first rectangle to fill */
+    )
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    int xorg = pDraw->x;
+    int yorg = pDraw->y;
+    int type = 0;
+    ClipAndRenderRectsFunc function;
+
+    if ((nrectFill <= 0) || !pGC->planemask)
+        return;
+
+    if (!RegionNumRects(pGC->pCompositeClip))
+        return;
+
+    switch (pGC->fillStyle) {
+    case FillSolid:
+        type = DO_SOLID;
+        break;
+    case FillStippled:
+        type = (*infoRec->StippledFillChooser) (pGC);
+        break;
+    case FillOpaqueStippled:
+        if ((pGC->fgPixel == pGC->bgPixel) && infoRec->FillSolidRects &&
+            CHECK_PLANEMASK(pGC, infoRec->FillSolidRectsFlags) &&
+            CHECK_ROP(pGC, infoRec->FillSolidRectsFlags) &&
+            CHECK_ROPSRC(pGC, infoRec->FillSolidRectsFlags) &&
+            CHECK_FG(pGC, infoRec->FillSolidRectsFlags))
+            type = DO_SOLID;
+        else
+            type = (*infoRec->OpaqueStippledFillChooser) (pGC);
+        break;
+    case FillTiled:
+        type = (*infoRec->TiledFillChooser) (pGC);
+        break;
+    }
+
+    switch (type) {
+    case DO_SOLID:
+        function = XAARenderSolidRects;
+        break;
+    case DO_COLOR_8x8:
+        function = XAARenderColor8x8Rects;
+        break;
+    case DO_MONO_8x8:
+        function = XAARenderMono8x8Rects;
+        break;
+    case DO_CACHE_BLT:
+        function = XAARenderCacheBltRects;
+        break;
+    case DO_COLOR_EXPAND:
+        function = XAARenderColorExpandRects;
+        break;
+    case DO_CACHE_EXPAND:
+        function = XAARenderCacheExpandRects;
+        break;
+    case DO_IMAGE_WRITE:
+        function = XAARenderImageWriteRects;
+        break;
+    case DO_PIXMAP_COPY:
+        function = XAARenderPixmapCopyRects;
+        break;
+    default:
+        (*XAAFallbackOps.PolyFillRect) (pDraw, pGC, nrectFill, prectInit);
+        return;
+    }
+
+    if (xorg | yorg) {
+        int n = nrectFill;
+        xRectangle *prect = prectInit;
+
+        while (n--) {
+            prect->x += xorg;
+            prect->y += yorg;
+            prect++;
+        }
+    }
+
+    XAAClipAndRenderRects(pGC, function, nrectFill, prectInit, xorg, yorg);
+}
+
+        /*********************\
+	|     Solid Rects     |
+	\*********************/
+
+static void
+XAARenderSolidRects(GCPtr pGC,
+                    int nboxes, BoxPtr pClipBoxes, int xorg, int yorg)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+
+    (*infoRec->FillSolidRects) (infoRec->pScrn,
+                                pGC->fgPixel, pGC->alu, pGC->planemask, nboxes,
+                                pClipBoxes);
+}
+
+        /************************\
+	|     Mono 8x8 Rects     |
+	\************************/
+
+static void
+XAARenderMono8x8Rects(GCPtr pGC,
+                      int nboxes, BoxPtr pClipBoxes, int xorg, int yorg)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    XAAPixmapPtr pPriv;
+    int fg, bg;
+
+    switch (pGC->fillStyle) {
+    case FillStippled:
+        pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->stipple);
+        fg = pGC->fgPixel;
+        bg = -1;
+        break;
+    case FillOpaqueStippled:
+        pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->stipple);
+        fg = pGC->fgPixel;
+        bg = pGC->bgPixel;
+        break;
+    case FillTiled:
+        pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);
+        fg = pPriv->fg;
+        bg = pPriv->bg;
+        break;
+    default:                   /* Muffle compiler */
+        pPriv = NULL;           /* Kaboom */
+        fg = -1;
+        bg = -1;
+        break;
+    }
+
+    (*infoRec->FillMono8x8PatternRects) (infoRec->pScrn,
+                                         fg, bg, pGC->alu, pGC->planemask,
+                                         nboxes, pClipBoxes, pPriv->pattern0,
+                                         pPriv->pattern1,
+                                         (xorg + pGC->patOrg.x),
+                                         (yorg + pGC->patOrg.y));
+}
+
+        /*************************\
+	|     Color 8x8 Rects     |
+	\*************************/
+
+static void
+XAARenderColor8x8Rects(GCPtr pGC,
+                       int nboxes, BoxPtr pClipBoxes, int xorg, int yorg)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    XAACacheInfoPtr pCache;
+    PixmapPtr pPix;
+    int fg, bg;
+
+    switch (pGC->fillStyle) {
+    case FillStippled:
+        pPix = pGC->stipple;
+        fg = pGC->fgPixel;
+        bg = -1;
+        break;
+    case FillOpaqueStippled:
+        pPix = pGC->stipple;
+        fg = pGC->fgPixel;
+        bg = pGC->bgPixel;
+        break;
+    case FillTiled:
+        pPix = pGC->tile.pixmap;
+        fg = -1;
+        bg = -1;
+        break;
+    default:                   /* Muffle compiler */
+        pPix = NULL;
+        fg = -1;
+        bg = -1;
+        break;
+    }
+
+    pCache = (*infoRec->CacheColor8x8Pattern) (infoRec->pScrn, pPix, fg, bg);
+    (*infoRec->FillColor8x8PatternRects) (infoRec->pScrn,
+                                          pGC->alu, pGC->planemask, nboxes,
+                                          pClipBoxes, (xorg + pGC->patOrg.x),
+                                          (yorg + pGC->patOrg.y), pCache);
+}
+
+        /****************************\
+	|     Color Expand Rects     |
+	\****************************/
+
+static void
+XAARenderColorExpandRects(GCPtr pGC,
+                          int nboxes, BoxPtr pClipBoxes, int xorg, int yorg)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    int fg, bg;
+
+    switch (pGC->fillStyle) {
+    case FillStippled:
+        fg = pGC->fgPixel;
+        bg = -1;
+        break;
+    case FillOpaqueStippled:
+        fg = pGC->fgPixel;
+        bg = pGC->bgPixel;
+        break;
+    default:                   /* Muffle compiler */
+        fg = -1;
+        bg = -1;
+        break;
+    }
+
+    (*infoRec->FillColorExpandRects) (infoRec->pScrn, fg, bg,
+                                      pGC->alu, pGC->planemask, nboxes,
+                                      pClipBoxes, (xorg + pGC->patOrg.x),
+                                      (yorg + pGC->patOrg.y), pGC->stipple);
+}
+
+        /*************************\
+	|     Cache Blt Rects     |
+	\*************************/
+
+static void
+XAARenderCacheBltRects(GCPtr pGC,
+                       int nboxes, BoxPtr pClipBoxes, int xorg, int yorg)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    XAACacheInfoPtr pCache;
+
+    switch (pGC->fillStyle) {
+    case FillStippled:
+        pCache = (*infoRec->CacheStipple) (infoRec->pScrn, pGC->stipple,
+                                           pGC->fgPixel, -1);
+        break;
+    case FillOpaqueStippled:
+        pCache = (*infoRec->CacheStipple) (infoRec->pScrn, pGC->stipple,
+                                           pGC->fgPixel, pGC->bgPixel);
+        break;
+    case FillTiled:
+        pCache = (*infoRec->CacheTile) (infoRec->pScrn, pGC->tile.pixmap);
+        break;
+    default:                   /* Muffle compiler */
+        pCache = NULL;
+        break;
+    }
+
+    (*infoRec->FillCacheBltRects) (infoRec->pScrn, pGC->alu,
+                                   pGC->planemask, nboxes, pClipBoxes,
+                                   (xorg + pGC->patOrg.x),
+                                   (yorg + pGC->patOrg.y), pCache);
+}
+
+        /****************************\
+	|     Cache Expand Rects     |
+	\****************************/
+
+static void
+XAARenderCacheExpandRects(GCPtr pGC,
+                          int nboxes, BoxPtr pClipBoxes, int xorg, int yorg)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    int fg, bg;
+
+    switch (pGC->fillStyle) {
+    case FillStippled:
+        fg = pGC->fgPixel;
+        bg = -1;
+        break;
+    case FillOpaqueStippled:
+        fg = pGC->fgPixel;
+        bg = pGC->bgPixel;
+        break;
+    default:                   /* Muffle compiler */
+        fg = -1;
+        bg = -1;
+        break;
+    }
+
+    (*infoRec->FillCacheExpandRects) (infoRec->pScrn, fg, bg,
+                                      pGC->alu, pGC->planemask, nboxes,
+                                      pClipBoxes, (xorg + pGC->patOrg.x),
+                                      (yorg + pGC->patOrg.y), pGC->stipple);
+}
+
+        /***************************\
+	|     Image Write Rects     |
+	\***************************/
+
+static void
+XAARenderImageWriteRects(GCPtr pGC,
+                         int nboxes, BoxPtr pClipBoxes, int xorg, int yorg)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+
+    (*infoRec->FillImageWriteRects) (infoRec->pScrn, pGC->alu,
+                                     pGC->planemask, nboxes, pClipBoxes,
+                                     (xorg + pGC->patOrg.x),
+                                     (yorg + pGC->patOrg.y), pGC->tile.pixmap);
+}
+
+        /***************************\
+	|     Pixmap Copy Rects     |
+	\***************************/
+
+static void
+XAARenderPixmapCopyRects(GCPtr pGC,
+                         int nboxes, BoxPtr pClipBoxes, int xorg, int yorg)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    XAACacheInfoPtr pCache = &(infoRec->ScratchCacheInfoRec);
+    XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);
+
+    pCache->x = pPriv->offscreenArea->box.x1;
+    pCache->y = pPriv->offscreenArea->box.y1;
+    pCache->w = pCache->orig_w = pPriv->offscreenArea->box.x2 - pCache->x;
+    pCache->h = pCache->orig_h = pPriv->offscreenArea->box.y2 - pCache->y;
+    pCache->trans_color = -1;
+
+    (*infoRec->FillCacheBltRects) (infoRec->pScrn, pGC->alu,
+                                   pGC->planemask, nboxes, pClipBoxes,
+                                   (xorg + pGC->patOrg.x),
+                                   (yorg + pGC->patOrg.y), pCache);
+}
+
+        /************\
+	|   Solid    |
+	\************/
+
+void
+XAAFillSolidRects(ScrnInfoPtr pScrn, int fg, int rop, unsigned int planemask, int nBox, /* number of rectangles to fill */
+                  BoxPtr pBox   /* Pointer to first rectangle to fill */
+    )
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+
+    (*infoRec->SetupForSolidFill) (pScrn, fg, rop, planemask);
+    while (nBox--) {
+        (*infoRec->SubsequentSolidFillRect) (pScrn, pBox->x1, pBox->y1,
+                                             pBox->x2 - pBox->x1,
+                                             pBox->y2 - pBox->y1);
+        pBox++;
+    }
+    SET_SYNC_FLAG(infoRec);
+}
+
+        /*********************\
+	|  8x8 Mono Patterns  |
+	\*********************/
+
+void
+XAAFillMono8x8PatternRectsScreenOrigin(ScrnInfoPtr pScrn,
+                                       int fg, int bg, int rop,
+                                       unsigned int planemask,
+                                       int nBox,
+                                       BoxPtr pBox,
+                                       int pattern0, int pattern1,
+                                       int xorigin, int yorigin)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int patx = pattern0, paty = pattern1;
+    int xorg = (-xorigin) & 0x07;
+    int yorg = (-yorigin) & 0x07;
+
+    if (infoRec->Mono8x8PatternFillFlags & HARDWARE_PATTERN_PROGRAMMED_BITS) {
+        if (!(infoRec->Mono8x8PatternFillFlags &
+              HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
+            XAARotateMonoPattern(&patx, &paty, xorg, yorg,
+                                 (infoRec->Mono8x8PatternFillFlags &
+                                  BIT_ORDER_IN_BYTE_MSBFIRST));
+            xorg = patx;
+            yorg = paty;
+        }
+    }
+    else {
+        XAACacheInfoPtr pCache =
+            (*infoRec->CacheMono8x8Pattern) (pScrn, pattern0, pattern1);
+        patx = pCache->x;
+        paty = pCache->y;
+        if (!(infoRec->Mono8x8PatternFillFlags &
+              HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
+            int slot = (yorg << 3) + xorg;
+
+            patx += pCache->offsets[slot].x;
+            paty += pCache->offsets[slot].y;
+            xorg = patx;
+            yorg = paty;
+        }
+    }
+
+    (*infoRec->SetupForMono8x8PatternFill) (pScrn, patx, paty,
+                                            fg, bg, rop, planemask);
+
+    while (nBox--) {
+        (*infoRec->SubsequentMono8x8PatternFillRect) (pScrn,
+                                                      xorg, yorg, pBox->x1,
+                                                      pBox->y1,
+                                                      pBox->x2 - pBox->x1,
+                                                      pBox->y2 - pBox->y1);
+        pBox++;
+    }
+    SET_SYNC_FLAG(infoRec);
+}
+
+void
+XAAFillMono8x8PatternRects(ScrnInfoPtr pScrn,
+                           int fg, int bg, int rop,
+                           unsigned int planemask,
+                           int nBox,
+                           BoxPtr pBox,
+                           int pattern0, int pattern1, int xorigin, int yorigin)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int patx = pattern0, paty = pattern1;
+    int xorg, yorg;
+    XAACacheInfoPtr pCache = NULL;
+
+    if (!(infoRec->Mono8x8PatternFillFlags & HARDWARE_PATTERN_PROGRAMMED_BITS)) {
+        pCache = (*infoRec->CacheMono8x8Pattern) (pScrn, pattern0, pattern1);
+        patx = pCache->x;
+        paty = pCache->y;
+    }
+
+    (*infoRec->SetupForMono8x8PatternFill) (pScrn, patx, paty,
+                                            fg, bg, rop, planemask);
+
+    while (nBox--) {
+        xorg = (pBox->x1 - xorigin) & 0x07;
+        yorg = (pBox->y1 - yorigin) & 0x07;
+
+        if (!(infoRec->Mono8x8PatternFillFlags &
+              HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
+            if (infoRec->Mono8x8PatternFillFlags &
+                HARDWARE_PATTERN_PROGRAMMED_BITS) {
+                patx = pattern0;
+                paty = pattern1;
+                XAARotateMonoPattern(&patx, &paty, xorg, yorg,
+                                     (infoRec->Mono8x8PatternFillFlags &
+                                      BIT_ORDER_IN_BYTE_MSBFIRST));
+                xorg = patx;
+                yorg = paty;
+            }
+            else {
+                int slot = (yorg << 3) + xorg;
+
+                xorg = patx + pCache->offsets[slot].x;
+                yorg = paty + pCache->offsets[slot].y;
+            }
+        }
+
+        (*infoRec->SubsequentMono8x8PatternFillRect) (pScrn,
+                                                      xorg, yorg, pBox->x1,
+                                                      pBox->y1,
+                                                      pBox->x2 - pBox->x1,
+                                                      pBox->y2 - pBox->y1);
+        pBox++;
+    }
+
+    SET_SYNC_FLAG(infoRec);
+}
+
+        /**********************\
+	|  8x8 Color Patterns  |
+	\**********************/
+
+void
+XAAFillColor8x8PatternRectsScreenOrigin(ScrnInfoPtr pScrn,
+                                        int rop,
+                                        unsigned int planemask,
+                                        int nBox,
+                                        BoxPtr pBox,
+                                        int xorigin, int yorigin,
+                                        XAACacheInfoPtr pCache)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int patx = pCache->x, paty = pCache->y;
+    int xorg = (-xorigin) & 0x07;
+    int yorg = (-yorigin) & 0x07;
+
+    if (!(infoRec->Color8x8PatternFillFlags &
+          HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
+        int slot = (yorg << 3) + xorg;
+
+        paty += pCache->offsets[slot].y;
+        patx += pCache->offsets[slot].x;
+        xorg = patx;
+        yorg = paty;
+    }
+
+    (*infoRec->SetupForColor8x8PatternFill) (pScrn, patx, paty,
+                                             rop, planemask,
+                                             pCache->trans_color);
+
+    while (nBox--) {
+        (*infoRec->SubsequentColor8x8PatternFillRect) (pScrn,
+                                                       xorg, yorg, pBox->x1,
+                                                       pBox->y1,
+                                                       pBox->x2 - pBox->x1,
+                                                       pBox->y2 - pBox->y1);
+        pBox++;
+    }
+    SET_SYNC_FLAG(infoRec);
+}
+
+void
+XAAFillColor8x8PatternRects(ScrnInfoPtr pScrn,
+                            int rop,
+                            unsigned int planemask,
+                            int nBox,
+                            BoxPtr pBox,
+                            int xorigin, int yorigin, XAACacheInfoPtr pCache)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int xorg, yorg;
+
+    (*infoRec->SetupForColor8x8PatternFill) (pScrn, pCache->x, pCache->y,
+                                             rop, planemask,
+                                             pCache->trans_color);
+
+    while (nBox--) {
+        xorg = (pBox->x1 - xorigin) & 0x07;
+        yorg = (pBox->y1 - yorigin) & 0x07;
+
+        if (!(infoRec->Color8x8PatternFillFlags &
+              HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
+            int slot = (yorg << 3) + xorg;
+
+            yorg = pCache->y + pCache->offsets[slot].y;
+            xorg = pCache->x + pCache->offsets[slot].x;
+        }
+
+        (*infoRec->SubsequentColor8x8PatternFillRect) (pScrn,
+                                                       xorg, yorg, pBox->x1,
+                                                       pBox->y1,
+                                                       pBox->x2 - pBox->x1,
+                                                       pBox->y2 - pBox->y1);
+        pBox++;
+    }
+
+    SET_SYNC_FLAG(infoRec);
+}
+
+        /***************\
+	|  Cache Blits  |
+	\***************/
+
+void
+XAAFillCacheBltRects(ScrnInfoPtr pScrn,
+                     int rop,
+                     unsigned int planemask,
+                     int nBox,
+                     BoxPtr pBox, int xorg, int yorg, XAACacheInfoPtr pCache)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int x, y, phaseY, phaseX, skipleft, height, width, w, blit_w, blit_h;
+
+    (*infoRec->SetupForScreenToScreenCopy) (pScrn, 1, 1, rop, planemask,
+                                            pCache->trans_color);
+
+    while (nBox--) {
+        y = pBox->y1;
+        phaseY = (y - yorg) % pCache->orig_h;
+        if (phaseY < 0)
+            phaseY += pCache->orig_h;
+        phaseX = (pBox->x1 - xorg) % pCache->orig_w;
+        if (phaseX < 0)
+            phaseX += pCache->orig_w;
+        height = pBox->y2 - y;
+        width = pBox->x2 - pBox->x1;
+
+#if 0
+        if (rop == GXcopy) {
+            while (1) {
+                w = width;
+                skipleft = phaseX;
+                x = pBox->x1;
+                blit_h = pCache->h - phaseY;
+                if (blit_h > height)
+                    blit_h = height;
+
+                while (1) {
+                    blit_w = pCache->w - skipleft;
+                    if (blit_w > w)
+                        blit_w = w;
+                    (*infoRec->SubsequentScreenToScreenCopy) (pScrn,
+                                                              pCache->x +
+                                                              skipleft,
+                                                              pCache->y +
+                                                              phaseY, x, y,
+                                                              blit_w, blit_h);
+                    w -= blit_w;
+                    if (!w)
+                        break;
+                    x += blit_w;
+                    skipleft = (skipleft + blit_w) % pCache->orig_w;
+                    if (blit_w >= pCache->orig_w)
+                        break;
+                }
+
+                /* Expand horizontally */
+                if (w) {
+                    skipleft -= phaseX;
+                    if (skipleft < 0)
+                        skipleft += pCache->orig_w;
+                    blit_w = x - pBox->x1 - skipleft;
+                    while (w) {
+                        if (blit_w > w)
+                            blit_w = w;
+                        (*infoRec->SubsequentScreenToScreenCopy) (pScrn,
+                                                                  pBox->x1 +
+                                                                  skipleft, y,
+                                                                  x, y, blit_w,
+                                                                  blit_h);
+                        w -= blit_w;
+                        x += blit_w;
+                        blit_w <<= 1;
+                    }
+                }
+
+                height -= blit_h;
+                if (!height)
+                    break;
+                y += blit_h;
+                phaseY = (phaseY + blit_h) % pCache->orig_h;
+                if (blit_h >= pCache->orig_h)
+                    break;
+            }
+
+            /* Expand vertically */
+            if (height) {
+                blit_w = pBox->x2 - pBox->x1;
+                phaseY -= (pBox->y1 - yorg) % pCache->orig_h;
+                if (phaseY < 0)
+                    phaseY += pCache->orig_h;
+                blit_h = y - pBox->y1 - phaseY;
+                while (height) {
+                    if (blit_h > height)
+                        blit_h = height;
+                    (*infoRec->SubsequentScreenToScreenCopy) (pScrn, pBox->x1,
+                                                              pBox->y1 + phaseY,
+                                                              pBox->x1, y,
+                                                              blit_w, blit_h);
+                    height -= blit_h;
+                    y += blit_h;
+                    blit_h <<= 1;
+                }
+            }
+        }
+        else
+#endif
+        {
+            while (1) {
+                w = width;
+                skipleft = phaseX;
+                x = pBox->x1;
+                blit_h = pCache->h - phaseY;
+                if (blit_h > height)
+                    blit_h = height;
+
+                while (1) {
+                    blit_w = pCache->w - skipleft;
+                    if (blit_w > w)
+                        blit_w = w;
+                    (*infoRec->SubsequentScreenToScreenCopy) (pScrn,
+                                                              pCache->x +
+                                                              skipleft,
+                                                              pCache->y +
+                                                              phaseY, x, y,
+                                                              blit_w, blit_h);
+                    w -= blit_w;
+                    if (!w)
+                        break;
+                    x += blit_w;
+                    skipleft = (skipleft + blit_w) % pCache->orig_w;
+                }
+                height -= blit_h;
+                if (!height)
+                    break;
+                y += blit_h;
+                phaseY = (phaseY + blit_h) % pCache->orig_h;
+            }
+        }
+        pBox++;
+    }
+
+    SET_SYNC_FLAG(infoRec);
+}
+
+        /*******************\
+	|  Cache Expansion  |
+	\*******************/
+
+void
+XAAFillCacheExpandRects(ScrnInfoPtr pScrn,
+                        int fg, int bg, int rop,
+                        unsigned int planemask,
+                        int nBox,
+                        BoxPtr pBox, int xorg, int yorg, PixmapPtr pPix)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int x, y, phaseY, phaseX, skipleft, height, width, w, blit_w, blit_h;
+    int cacheWidth;
+    XAACacheInfoPtr pCache;
+
+    pCache = (*infoRec->CacheMonoStipple) (pScrn, pPix);
+
+    cacheWidth = (pCache->w * pScrn->bitsPerPixel) /
+        infoRec->CacheColorExpandDensity;
+
+    (*infoRec->SetupForScreenToScreenColorExpandFill) (pScrn, fg, bg, rop,
+                                                       planemask);
+
+    while (nBox--) {
+        y = pBox->y1;
+        phaseY = (y - yorg) % pCache->orig_h;
+        if (phaseY < 0)
+            phaseY += pCache->orig_h;
+        phaseX = (pBox->x1 - xorg) % pCache->orig_w;
+        if (phaseX < 0)
+            phaseX += pCache->orig_w;
+        height = pBox->y2 - y;
+        width = pBox->x2 - pBox->x1;
+
+        while (1) {
+            w = width;
+            skipleft = phaseX;
+            x = pBox->x1;
+            blit_h = pCache->h - phaseY;
+            if (blit_h > height)
+                blit_h = height;
+
+            while (1) {
+                blit_w = cacheWidth - skipleft;
+                if (blit_w > w)
+                    blit_w = w;
+                (*infoRec->SubsequentScreenToScreenColorExpandFill) (pScrn, x,
+                                                                     y, blit_w,
+                                                                     blit_h,
+                                                                     pCache->x,
+                                                                     pCache->y +
+                                                                     phaseY,
+                                                                     skipleft);
+                w -= blit_w;
+                if (!w)
+                    break;
+                x += blit_w;
+                skipleft = (skipleft + blit_w) % pCache->orig_w;
+            }
+            height -= blit_h;
+            if (!height)
+                break;
+            y += blit_h;
+            phaseY = (phaseY + blit_h) % pCache->orig_h;
+        }
+        pBox++;
+    }
+
+    SET_SYNC_FLAG(infoRec);
+}
+
+        /******************\
+	|   Image Writes   |
+	\******************/
+
+/*  This requires all LEFT_EDGE clipping.  You get too many problems
+    with reading past the edge of the pattern otherwise */
+
+static void
+WriteColumn(ScrnInfoPtr pScrn,
+            unsigned char *pSrc,
+            int x, int y, int w, int h,
+            int xoff, int yoff, int pHeight, int srcwidth, int Bpp)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    unsigned char *src;
+    Bool PlusOne = FALSE;
+    int skipleft, dwords;
+
+    pSrc += (Bpp * xoff);
+
+    if ((skipleft = (long) pSrc & 0x03L)) {
+        if (Bpp == 3)
+            skipleft = 4 - skipleft;
+        else
+            skipleft /= Bpp;
+
+        x -= skipleft;
+        w += skipleft;
+
+        if (Bpp == 3)
+            pSrc -= 3 * skipleft;
+        else                    /* is this Alpha friendly ? */
+            pSrc = (unsigned char *) ((long) pSrc & ~0x03L);
+    }
+
+    src = pSrc + (yoff * srcwidth);
+
+    dwords = bytes_to_int32(w * Bpp);
+
+    if ((infoRec->ImageWriteFlags & CPU_TRANSFER_PAD_QWORD) &&
+        ((dwords * h) & 0x01)) {
+        PlusOne = TRUE;
+    }
+
+    (*infoRec->SubsequentImageWriteRect) (pScrn, x, y, w, h, skipleft);
+
+    if (dwords > infoRec->ImageWriteRange) {
+        while (h--) {
+            XAAMoveDWORDS_FixedBase((CARD32 *) infoRec->ImageWriteBase,
+                                    (CARD32 *) src, dwords);
+            src += srcwidth;
+            yoff++;
+            if (yoff >= pHeight) {
+                yoff = 0;
+                src = pSrc;
+            }
+        }
+    }
+    else {
+        if (srcwidth == (dwords << 2)) {
+            int maxLines = infoRec->ImageWriteRange / dwords;
+            int step;
+
+            while (h) {
+                step = pHeight - yoff;
+                if (step > maxLines)
+                    step = maxLines;
+                if (step > h)
+                    step = h;
+
+                XAAMoveDWORDS((CARD32 *) infoRec->ImageWriteBase,
+                              (CARD32 *) src, dwords * step);
+
+                src += (srcwidth * step);
+                yoff += step;
+                if (yoff >= pHeight) {
+                    yoff = 0;
+                    src = pSrc;
+                }
+                h -= step;
+            }
+        }
+        else {
+            while (h--) {
+                XAAMoveDWORDS((CARD32 *) infoRec->ImageWriteBase,
+                              (CARD32 *) src, dwords);
+                src += srcwidth;
+                yoff++;
+                if (yoff >= pHeight) {
+                    yoff = 0;
+                    src = pSrc;
+                }
+            }
+        }
+    }
+
+    if (PlusOne) {
+        CARD32 *base = (CARD32 *) infoRec->ImageWriteBase;
+
+        *base = 0x00000000;
+    }
+}
+
+void
+XAAFillImageWriteRects(ScrnInfoPtr pScrn,
+                       int rop,
+                       unsigned int planemask,
+                       int nBox,
+                       BoxPtr pBox, int xorg, int yorg, PixmapPtr pPix)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int x, phaseY, phaseX, height, width, blit_w;
+    int pHeight = pPix->drawable.height;
+    int pWidth = pPix->drawable.width;
+    int Bpp = pPix->drawable.bitsPerPixel >> 3;
+    int srcwidth = pPix->devKind;
+
+    (*infoRec->SetupForImageWrite) (pScrn, rop, planemask, -1,
+                                    pPix->drawable.bitsPerPixel,
+                                    pPix->drawable.depth);
+
+    while (nBox--) {
+        x = pBox->x1;
+        phaseY = (pBox->y1 - yorg) % pHeight;
+        if (phaseY < 0)
+            phaseY += pHeight;
+        phaseX = (x - xorg) % pWidth;
+        if (phaseX < 0)
+            phaseX += pWidth;
+        height = pBox->y2 - pBox->y1;
+        width = pBox->x2 - x;
+
+        while (1) {
+            blit_w = pWidth - phaseX;
+            if (blit_w > width)
+                blit_w = width;
+
+            WriteColumn(pScrn, pPix->devPrivate.ptr, x, pBox->y1,
+                        blit_w, height, phaseX, phaseY, pHeight, srcwidth, Bpp);
+
+            width -= blit_w;
+            if (!width)
+                break;
+            x += blit_w;
+            phaseX = (phaseX + blit_w) % pWidth;
+        }
+        pBox++;
+    }
+
+    if (infoRec->ImageWriteFlags & SYNC_AFTER_IMAGE_WRITE)
+        (*infoRec->Sync) (pScrn);
+    else
+        SET_SYNC_FLAG(infoRec);
+}
+
+        /*************\
+	|  Utilities  |
+	\*************/
+
+void
+XAAClipAndRenderRects(GCPtr pGC,
+                      ClipAndRenderRectsFunc BoxFunc,
+                      int nrectFill, xRectangle *prect, int xorg, int yorg)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    int Right, Bottom, MaxBoxes;
+    BoxPtr pextent, pboxClipped, pboxClippedBase;
+
+    MaxBoxes = infoRec->PreAllocSize / sizeof(BoxRec);
+    pboxClippedBase = (BoxPtr) infoRec->PreAllocMem;
+    pboxClipped = pboxClippedBase;
+
+    if (RegionNumRects(pGC->pCompositeClip) == 1) {
+        pextent = RegionRects(pGC->pCompositeClip);
+        while (nrectFill--) {
+            pboxClipped->x1 = max(pextent->x1, prect->x);
+            pboxClipped->y1 = max(pextent->y1, prect->y);
+
+            Right = (int) prect->x + (int) prect->width;
+            pboxClipped->x2 = min(pextent->x2, Right);
+
+            Bottom = (int) prect->y + (int) prect->height;
+            pboxClipped->y2 = min(pextent->y2, Bottom);
+
+            prect++;
+            if ((pboxClipped->x1 < pboxClipped->x2) &&
+                (pboxClipped->y1 < pboxClipped->y2)) {
+                pboxClipped++;
+                if (pboxClipped >= (pboxClippedBase + MaxBoxes)) {
+                    (*BoxFunc) (pGC, MaxBoxes, pboxClippedBase, xorg, yorg);
+                    pboxClipped = pboxClippedBase;
+                }
+            }
+        }
+    }
+    else {
+        pextent = RegionExtents(pGC->pCompositeClip);
+        while (nrectFill--) {
+            int n;
+            BoxRec box, *pbox;
+
+            box.x1 = max(pextent->x1, prect->x);
+            box.y1 = max(pextent->y1, prect->y);
+
+            Right = (int) prect->x + (int) prect->width;
+            box.x2 = min(pextent->x2, Right);
+
+            Bottom = (int) prect->y + (int) prect->height;
+            box.y2 = min(pextent->y2, Bottom);
+
+            prect++;
+
+            if ((box.x1 >= box.x2) || (box.y1 >= box.y2))
+                continue;
+
+            n = RegionNumRects(pGC->pCompositeClip);
+            pbox = RegionRects(pGC->pCompositeClip);
+
+            /* clip the rectangle to each box in the clip region
+               this is logically equivalent to calling Intersect()
+             */
+            while (n--) {
+                pboxClipped->x1 = max(box.x1, pbox->x1);
+                pboxClipped->y1 = max(box.y1, pbox->y1);
+                pboxClipped->x2 = min(box.x2, pbox->x2);
+                pboxClipped->y2 = min(box.y2, pbox->y2);
+                pbox++;
+
+                /* see if clipping left anything */
+                if (pboxClipped->x1 < pboxClipped->x2 &&
+                    pboxClipped->y1 < pboxClipped->y2) {
+                    pboxClipped++;
+                    if (pboxClipped >= (pboxClippedBase + MaxBoxes)) {
+                        (*BoxFunc) (pGC, MaxBoxes, pboxClippedBase, xorg, yorg);
+                        pboxClipped = pboxClippedBase;
+                    }
+                }
+            }
+        }
+    }
+
+    if (pboxClipped != pboxClippedBase)
+        (*BoxFunc) (pGC, pboxClipped - pboxClippedBase, pboxClippedBase,
+                    xorg, yorg);
+}
+
+int
+XAAGetRectClipBoxes(GCPtr pGC,
+                    BoxPtr pboxClippedBase,
+                    int nrectFill, xRectangle *prectInit)
+{
+    int Right, Bottom;
+    BoxPtr pextent, pboxClipped = pboxClippedBase;
+    xRectangle *prect = prectInit;
+    RegionPtr prgnClip = pGC->pCompositeClip;
+
+    if (RegionNumRects(prgnClip) == 1) {
+        pextent = RegionRects(prgnClip);
+        while (nrectFill--) {
+            pboxClipped->x1 = max(pextent->x1, prect->x);
+            pboxClipped->y1 = max(pextent->y1, prect->y);
+
+            Right = (int) prect->x + (int) prect->width;
+            pboxClipped->x2 = min(pextent->x2, Right);
+
+            Bottom = (int) prect->y + (int) prect->height;
+            pboxClipped->y2 = min(pextent->y2, Bottom);
+
+            prect++;
+            if ((pboxClipped->x1 < pboxClipped->x2) &&
+                (pboxClipped->y1 < pboxClipped->y2)) {
+                pboxClipped++;
+            }
+        }
+    }
+    else {
+        pextent = RegionExtents(prgnClip);
+        while (nrectFill--) {
+            int n;
+            BoxRec box, *pbox;
+
+            box.x1 = max(pextent->x1, prect->x);
+            box.y1 = max(pextent->y1, prect->y);
+
+            Right = (int) prect->x + (int) prect->width;
+            box.x2 = min(pextent->x2, Right);
+
+            Bottom = (int) prect->y + (int) prect->height;
+            box.y2 = min(pextent->y2, Bottom);
+
+            prect++;
+
+            if ((box.x1 >= box.x2) || (box.y1 >= box.y2))
+                continue;
+
+            n = RegionNumRects(prgnClip);
+            pbox = RegionRects(prgnClip);
+
+            /* clip the rectangle to each box in the clip region
+               this is logically equivalent to calling Intersect()
+             */
+            while (n--) {
+                pboxClipped->x1 = max(box.x1, pbox->x1);
+                pboxClipped->y1 = max(box.y1, pbox->y1);
+                pboxClipped->x2 = min(box.x2, pbox->x2);
+                pboxClipped->y2 = min(box.y2, pbox->y2);
+                pbox++;
+
+                /* see if clipping left anything */
+                if (pboxClipped->x1 < pboxClipped->x2 &&
+                    pboxClipped->y1 < pboxClipped->y2) {
+                    pboxClipped++;
+                }
+            }
+        }
+    }
+
+    return pboxClipped - pboxClippedBase;
+}
diff --git a/hw/xfree86/xaa/xaaGC.c b/hw/xfree86/xaa/xaaGC.c
new file mode 100644
index 000000000..93cebd90d
--- /dev/null
+++ b/hw/xfree86/xaa/xaaGC.c
@@ -0,0 +1,564 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <string.h>
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include "xf86str.h"
+#include "xaa.h"
+#include "xaalocal.h"
+#include "migc.h"
+#include "gcstruct.h"
+#include "pixmapstr.h"
+#include "xaawrap.h"
+
+static void XAAValidateGC(GCPtr pGC, unsigned long changes, DrawablePtr pDraw);
+static void XAAChangeGC(GCPtr pGC, unsigned long mask);
+static void XAACopyGC(GCPtr pGCSrc, unsigned long mask, GCPtr pGCDst);
+static void XAADestroyGC(GCPtr pGC);
+static void XAAChangeClip(GCPtr pGC, int type, void *pvalue, int nrects);
+static void XAADestroyClip(GCPtr pGC);
+static void XAACopyClip(GCPtr pgcDst, GCPtr pgcSrc);
+
+GCFuncs XAAGCFuncs = {
+    XAAValidateGC, XAAChangeGC, XAACopyGC, XAADestroyGC,
+    XAAChangeClip, XAADestroyClip, XAACopyClip
+};
+
+extern GCOps XAAPixmapOps;
+
+Bool
+XAACreateGC(GCPtr pGC)
+{
+    ScreenPtr pScreen = pGC->pScreen;
+    XAAGCPtr pGCPriv = (XAAGCPtr) dixLookupPrivate(&pGC->devPrivates,
+                                                   XAAGetGCKey());
+    Bool ret;
+
+    XAA_SCREEN_PROLOGUE(pScreen, CreateGC);
+
+    if ((ret = (*pScreen->CreateGC) (pGC))) {
+        pGCPriv->wrapOps = NULL;
+        pGCPriv->wrapFuncs = pGC->funcs;
+        pGCPriv->XAAOps = &XAAFallbackOps;
+        pGC->funcs = &XAAGCFuncs;
+    }
+
+    XAA_SCREEN_EPILOGUE(pScreen, CreateGC, XAACreateGC);
+
+    return ret;
+}
+
+static void
+XAAValidateGC(GCPtr pGC, unsigned long changes, DrawablePtr pDraw)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+
+    XAA_GC_FUNC_PROLOGUE(pGC);
+
+    (*pGC->funcs->ValidateGC) (pGC, changes, pDraw);
+
+    if ((changes & GCPlaneMask) &&
+        ((pGC->planemask & infoRec->FullPlanemasks[pGC->depth - 1]) ==
+         infoRec->FullPlanemasks[pGC->depth - 1])) {
+        pGC->planemask = ~0;
+    }
+
+    if (pGC->depth != 32) {
+        /* 0xffffffff is reserved for transparency */
+        if (pGC->bgPixel == 0xffffffff)
+            pGC->bgPixel = 0x7fffffff;
+        if (pGC->fgPixel == 0xffffffff)
+            pGC->fgPixel = 0x7fffffff;
+    }
+
+    if ((pDraw->type == DRAWABLE_PIXMAP) && !IS_OFFSCREEN_PIXMAP(pDraw)) {
+        pGCPriv->flags = OPS_ARE_PIXMAP;
+        pGCPriv->changes |= changes;
+
+        /* make sure we're not using videomemory pixmaps to render
+           onto system memory drawables */
+
+        if ((pGC->fillStyle == FillTiled) &&
+            IS_OFFSCREEN_PIXMAP(pGC->tile.pixmap) &&
+            !OFFSCREEN_PIXMAP_LOCKED(pGC->tile.pixmap)) {
+
+            XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);
+            FBAreaPtr area = pPriv->offscreenArea;
+
+            XAARemoveAreaCallback(area);        /* clobbers pPriv->offscreenArea */
+            xf86FreeOffscreenArea(area);
+        }
+    }
+    else if (!infoRec->pScrn->vtSema && (pDraw->type == DRAWABLE_WINDOW)) {
+        pGCPriv->flags = 0;
+        pGCPriv->changes |= changes;
+    }
+    else {
+        if (!(pGCPriv->flags & OPS_ARE_ACCEL)) {
+            changes |= pGCPriv->changes;
+            pGCPriv->changes = 0;
+        }
+        pGCPriv->flags = OPS_ARE_ACCEL;
+
+#if 1
+        /* Ugh.  If we can't use the blitter on offscreen pixmaps used
+           as tiles, then we need to move them out as cfb can't handle
+           tiles with non-zero origins */
+
+        if ((pGC->fillStyle == FillTiled) &&
+            IS_OFFSCREEN_PIXMAP(pGC->tile.pixmap) &&
+            (DO_PIXMAP_COPY != (*infoRec->TiledFillChooser) (pGC))) {
+
+            XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);
+            FBAreaPtr area = pPriv->offscreenArea;
+
+            XAARemoveAreaCallback(area);        /* clobbers pPriv->offscreenArea */
+            xf86FreeOffscreenArea(area);
+        }
+#endif
+    }
+
+    XAA_GC_FUNC_EPILOGUE(pGC);
+
+    if (!(pGCPriv->flags & OPS_ARE_ACCEL))
+        return;
+
+    if ((changes & GCTile) && !pGC->tileIsPixel && pGC->tile.pixmap) {
+        XAAPixmapPtr pixPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);
+
+        if (pixPriv->flags & DIRTY) {
+            pixPriv->flags &= ~(DIRTY | REDUCIBILITY_MASK);
+            pGC->tile.pixmap->drawable.serialNumber = NEXT_SERIAL_NUMBER;
+        }
+    }
+    if ((changes & GCStipple) && pGC->stipple) {
+        XAAPixmapPtr pixPriv = XAA_GET_PIXMAP_PRIVATE(pGC->stipple);
+
+        if (pixPriv->flags & DIRTY) {
+            pixPriv->flags &= ~(DIRTY | REDUCIBILITY_MASK);
+            pGC->stipple->drawable.serialNumber = NEXT_SERIAL_NUMBER;
+        }
+    }
+
+    /* If our Ops are still the default ones we need to allocate new ones */
+    if (pGC->ops == &XAAFallbackOps) {
+        if (!(pGCPriv->XAAOps = malloc(sizeof(GCOps)))) {
+            pGCPriv->XAAOps = &XAAFallbackOps;
+            return;
+        }
+        /* make a modifiable copy of the default ops */
+        memcpy(pGCPriv->XAAOps, &XAAFallbackOps, sizeof(GCOps));
+        pGC->ops = pGCPriv->XAAOps;
+        changes = ~0;
+    }
+
+    if (!changes)
+        return;
+
+    if ((changes & GCDashList) && infoRec->ComputeDash)
+        infoRec->ComputeDash(pGC);
+
+    if (changes & infoRec->FillSpansMask)
+        (*infoRec->ValidateFillSpans) (pGC, changes, pDraw);
+
+    if (changes & infoRec->SetSpansMask)
+        (*infoRec->ValidateSetSpans) (pGC, changes, pDraw);
+
+    if (changes & infoRec->PutImageMask)
+        (*infoRec->ValidatePutImage) (pGC, changes, pDraw);
+
+    if (changes & infoRec->CopyAreaMask)
+        (*infoRec->ValidateCopyArea) (pGC, changes, pDraw);
+
+    if (changes & infoRec->CopyPlaneMask)
+        (*infoRec->ValidateCopyPlane) (pGC, changes, pDraw);
+
+    if (changes & infoRec->PolyPointMask)
+        (*infoRec->ValidatePolyPoint) (pGC, changes, pDraw);
+
+    if (changes & infoRec->PolylinesMask)
+        (*infoRec->ValidatePolylines) (pGC, changes, pDraw);
+
+    if (changes & infoRec->PolySegmentMask)
+        (*infoRec->ValidatePolySegment) (pGC, changes, pDraw);
+
+    if (changes & infoRec->PolyRectangleMask)
+        (*infoRec->ValidatePolyRectangle) (pGC, changes, pDraw);
+
+    if (changes & infoRec->PolyArcMask)
+        (*infoRec->ValidatePolyArc) (pGC, changes, pDraw);
+
+    if (changes & infoRec->FillPolygonMask)
+        (*infoRec->ValidateFillPolygon) (pGC, changes, pDraw);
+
+    if (changes & infoRec->PolyFillRectMask)
+        (*infoRec->ValidatePolyFillRect) (pGC, changes, pDraw);
+
+    if (changes & infoRec->PolyFillArcMask)
+        (*infoRec->ValidatePolyFillArc) (pGC, changes, pDraw);
+
+    if (changes & infoRec->PolyGlyphBltMask)
+        (*infoRec->ValidatePolyGlyphBlt) (pGC, changes, pDraw);
+
+    if (changes & infoRec->ImageGlyphBltMask)
+        (*infoRec->ValidateImageGlyphBlt) (pGC, changes, pDraw);
+
+    if (changes & infoRec->PolyText8Mask)
+        (*infoRec->ValidatePolyText8) (pGC, changes, pDraw);
+
+    if (changes & infoRec->PolyText16Mask)
+        (*infoRec->ValidatePolyText16) (pGC, changes, pDraw);
+
+    if (changes & infoRec->ImageText8Mask)
+        (*infoRec->ValidateImageText8) (pGC, changes, pDraw);
+
+    if (changes & infoRec->ImageText16Mask)
+        (*infoRec->ValidateImageText16) (pGC, changes, pDraw);
+
+    if (changes & infoRec->PushPixelsMask)
+        (*infoRec->ValidatePushPixels) (pGC, changes, pDraw);
+}
+
+static void
+XAADestroyGC(GCPtr pGC)
+{
+    XAA_GC_FUNC_PROLOGUE(pGC);
+
+    if (pGCPriv->XAAOps != &XAAFallbackOps)
+        free(pGCPriv->XAAOps);
+
+    free(pGCPriv->DashPattern);
+    pGCPriv->flags = 0;
+
+    (*pGC->funcs->DestroyGC) (pGC);
+    XAA_GC_FUNC_EPILOGUE(pGC);
+}
+
+static void
+XAAChangeGC(GCPtr pGC, unsigned long mask)
+{
+    XAA_GC_FUNC_PROLOGUE(pGC);
+    (*pGC->funcs->ChangeGC) (pGC, mask);
+    XAA_GC_FUNC_EPILOGUE(pGC);
+
+    /* we have to assume that shared memory pixmaps are dirty 
+       because we can't wrap all operations on them */
+
+    if ((mask & GCTile) && !pGC->tileIsPixel &&
+        PIXMAP_IS_SHARED(pGC->tile.pixmap)) {
+        XAAPixmapPtr pPixPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);
+
+        pPixPriv->flags |= DIRTY;
+    }
+
+    if ((mask & GCStipple) && PIXMAP_IS_SHARED(pGC->stipple)) {
+        XAAPixmapPtr pPixPriv = XAA_GET_PIXMAP_PRIVATE(pGC->stipple);
+
+        pPixPriv->flags |= DIRTY;
+    }
+}
+
+static void
+XAACopyGC(GCPtr pGCSrc, unsigned long mask, GCPtr pGCDst)
+{
+    XAA_GC_FUNC_PROLOGUE(pGCDst);
+    (*pGCDst->funcs->CopyGC) (pGCSrc, mask, pGCDst);
+    XAA_GC_FUNC_EPILOGUE(pGCDst);
+}
+
+static void
+XAAChangeClip(GCPtr pGC, int type, void *pvalue, int nrects)
+{
+    XAA_GC_FUNC_PROLOGUE(pGC);
+    (*pGC->funcs->ChangeClip) (pGC, type, pvalue, nrects);
+    XAA_GC_FUNC_EPILOGUE(pGC);
+}
+
+static void
+XAACopyClip(GCPtr pgcDst, GCPtr pgcSrc)
+{
+    XAA_GC_FUNC_PROLOGUE(pgcDst);
+    (*pgcDst->funcs->CopyClip) (pgcDst, pgcSrc);
+    XAA_GC_FUNC_EPILOGUE(pgcDst);
+}
+
+static void
+XAADestroyClip(GCPtr pGC)
+{
+    XAA_GC_FUNC_PROLOGUE(pGC);
+    (*pGC->funcs->DestroyClip) (pGC);
+    XAA_GC_FUNC_EPILOGUE(pGC);
+}
+
+/**** Pixmap Wrappers ****/
+
+static void
+XAAFillSpansPixmap(DrawablePtr pDraw,
+                   GC * pGC,
+                   int nInit, DDXPointPtr pptInit, int *pwidthInit, int fSorted)
+{
+    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
+    (*pGC->ops->FillSpans) (pDraw, pGC, nInit, pptInit, pwidthInit, fSorted);
+    XAA_PIXMAP_OP_EPILOGUE(pGC);
+}
+
+static void
+XAASetSpansPixmap(DrawablePtr pDraw,
+                  GCPtr pGC,
+                  char *pcharsrc,
+                  register DDXPointPtr ppt,
+                  int *pwidth, int nspans, int fSorted)
+{
+    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
+    (*pGC->ops->SetSpans) (pDraw, pGC, pcharsrc, ppt, pwidth, nspans, fSorted);
+    XAA_PIXMAP_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAPutImagePixmap(DrawablePtr pDraw,
+                  GCPtr pGC,
+                  int depth,
+                  int x, int y, int w, int h,
+                  int leftPad, int format, char *pImage)
+{
+    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
+    (*pGC->ops->PutImage) (pDraw, pGC, depth, x, y, w, h,
+                           leftPad, format, pImage);
+    XAA_PIXMAP_OP_EPILOGUE(pGC);
+}
+
+static RegionPtr
+XAACopyAreaPixmap(DrawablePtr pSrc,
+                  DrawablePtr pDst,
+                  GC * pGC,
+                  int srcx, int srcy, int width, int height, int dstx, int dsty)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    RegionPtr ret;
+
+    if (infoRec->pScrn->vtSema &&
+        ((pSrc->type == DRAWABLE_WINDOW) || IS_OFFSCREEN_PIXMAP(pSrc))) {
+        if (infoRec->ReadPixmap && (pGC->alu == GXcopy) &&
+            (pSrc->bitsPerPixel == pDst->bitsPerPixel) &&
+            ((pGC->planemask & infoRec->FullPlanemasks[pSrc->depth - 1])
+             == infoRec->FullPlanemasks[pSrc->depth - 1])) {
+            XAAPixmapPtr pixPriv = XAA_GET_PIXMAP_PRIVATE((PixmapPtr) (pDst));
+
+            pixPriv->flags |= DIRTY;
+
+            return (XAABitBlt(pSrc, pDst, pGC,
+                              srcx, srcy, width, height, dstx, dsty,
+                              XAADoImageRead, 0L));
+        }
+        else if (infoRec->NeedToSync) {
+            (*infoRec->Sync) (infoRec->pScrn);
+            infoRec->NeedToSync = FALSE;
+        }
+    }
+
+    {
+        XAA_PIXMAP_OP_PROLOGUE(pGC, pDst);
+        ret = (*pGC->ops->CopyArea) (pSrc, pDst,
+                                     pGC, srcx, srcy, width, height, dstx,
+                                     dsty);
+        XAA_PIXMAP_OP_EPILOGUE(pGC);
+    }
+    return ret;
+}
+
+static RegionPtr
+XAACopyPlanePixmap(DrawablePtr pSrc,
+                   DrawablePtr pDst,
+                   GCPtr pGC,
+                   int srcx, int srcy,
+                   int width, int height,
+                   int dstx, int dsty, unsigned long bitPlane)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    RegionPtr ret;
+
+    XAA_PIXMAP_OP_PROLOGUE(pGC, pDst);
+
+    if (infoRec->pScrn->vtSema &&
+        ((pSrc->type == DRAWABLE_WINDOW) || IS_OFFSCREEN_PIXMAP(pSrc))) {
+        if (infoRec->NeedToSync) {
+            (*infoRec->Sync) (infoRec->pScrn);
+            infoRec->NeedToSync = FALSE;
+        }
+    }
+
+    ret = (*pGC->ops->CopyPlane) (pSrc, pDst,
+                                  pGC, srcx, srcy, width, height, dstx, dsty,
+                                  bitPlane);
+    XAA_PIXMAP_OP_EPILOGUE(pGC);
+    return ret;
+}
+
+static void
+XAAPolyPointPixmap(DrawablePtr pDraw,
+                   GCPtr pGC, int mode, int npt, xPoint * pptInit)
+{
+    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
+    (*pGC->ops->PolyPoint) (pDraw, pGC, mode, npt, pptInit);
+    XAA_PIXMAP_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAPolylinesPixmap(DrawablePtr pDraw,
+                   GCPtr pGC, int mode, int npt, DDXPointPtr pptInit)
+{
+    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
+    (*pGC->ops->Polylines) (pDraw, pGC, mode, npt, pptInit);
+    XAA_PIXMAP_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAPolySegmentPixmap(DrawablePtr pDraw, GCPtr pGC, int nseg, xSegment * pSeg)
+{
+    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
+    (*pGC->ops->PolySegment) (pDraw, pGC, nseg, pSeg);
+    XAA_PIXMAP_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAPolyRectanglePixmap(DrawablePtr pDraw,
+                       GCPtr pGC, int nRectsInit, xRectangle *pRectsInit)
+{
+    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
+    (*pGC->ops->PolyRectangle) (pDraw, pGC, nRectsInit, pRectsInit);
+    XAA_PIXMAP_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAPolyArcPixmap(DrawablePtr pDraw, GCPtr pGC, int narcs, xArc * parcs)
+{
+    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
+    (*pGC->ops->PolyArc) (pDraw, pGC, narcs, parcs);
+    XAA_PIXMAP_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAFillPolygonPixmap(DrawablePtr pDraw,
+                     GCPtr pGC,
+                     int shape, int mode, int count, DDXPointPtr ptsIn)
+{
+    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
+    (*pGC->ops->FillPolygon) (pDraw, pGC, shape, mode, count, ptsIn);
+    XAA_PIXMAP_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAPolyFillRectPixmap(DrawablePtr pDraw,
+                      GCPtr pGC, int nrectFill, xRectangle *prectInit)
+{
+    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
+    (*pGC->ops->PolyFillRect) (pDraw, pGC, nrectFill, prectInit);
+    XAA_PIXMAP_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAPolyFillArcPixmap(DrawablePtr pDraw, GCPtr pGC, int narcs, xArc * parcs)
+{
+    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
+    (*pGC->ops->PolyFillArc) (pDraw, pGC, narcs, parcs);
+    XAA_PIXMAP_OP_EPILOGUE(pGC);
+}
+
+static int
+XAAPolyText8Pixmap(DrawablePtr pDraw,
+                   GCPtr pGC, int x, int y, int count, char *chars)
+{
+    int ret;
+
+    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
+    ret = (*pGC->ops->PolyText8) (pDraw, pGC, x, y, count, chars);
+    XAA_PIXMAP_OP_EPILOGUE(pGC);
+    return ret;
+}
+
+static int
+XAAPolyText16Pixmap(DrawablePtr pDraw,
+                    GCPtr pGC, int x, int y, int count, unsigned short *chars)
+{
+    int ret;
+
+    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
+    ret = (*pGC->ops->PolyText16) (pDraw, pGC, x, y, count, chars);
+    XAA_PIXMAP_OP_EPILOGUE(pGC);
+    return ret;
+}
+
+static void
+XAAImageText8Pixmap(DrawablePtr pDraw,
+                    GCPtr pGC, int x, int y, int count, char *chars)
+{
+    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
+    (*pGC->ops->ImageText8) (pDraw, pGC, x, y, count, chars);
+    XAA_PIXMAP_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAImageText16Pixmap(DrawablePtr pDraw,
+                     GCPtr pGC, int x, int y, int count, unsigned short *chars)
+{
+    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
+    (*pGC->ops->ImageText16) (pDraw, pGC, x, y, count, chars);
+    XAA_PIXMAP_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAImageGlyphBltPixmap(DrawablePtr pDraw,
+                       GCPtr pGC,
+                       int xInit, int yInit,
+                       unsigned int nglyph,
+                       CharInfoPtr * ppci, void *pglyphBase)
+{
+    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
+    (*pGC->ops->ImageGlyphBlt) (pDraw, pGC, xInit, yInit, nglyph,
+                                ppci, pglyphBase);
+    XAA_PIXMAP_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAPolyGlyphBltPixmap(DrawablePtr pDraw,
+                      GCPtr pGC,
+                      int xInit, int yInit,
+                      unsigned int nglyph,
+                      CharInfoPtr * ppci, void *pglyphBase)
+{
+    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
+    (*pGC->ops->PolyGlyphBlt) (pDraw, pGC, xInit, yInit, nglyph,
+                               ppci, pglyphBase);
+    XAA_PIXMAP_OP_EPILOGUE(pGC);
+}
+
+static void
+XAAPushPixelsPixmap(GCPtr pGC,
+                    PixmapPtr pBitMap,
+                    DrawablePtr pDraw, int dx, int dy, int xOrg, int yOrg)
+{
+    XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw);
+    (*pGC->ops->PushPixels) (pGC, pBitMap, pDraw, dx, dy, xOrg, yOrg);
+    XAA_PIXMAP_OP_EPILOGUE(pGC);
+}
+
+GCOps XAAPixmapOps = {
+    XAAFillSpansPixmap, XAASetSpansPixmap,
+    XAAPutImagePixmap, XAACopyAreaPixmap,
+    XAACopyPlanePixmap, XAAPolyPointPixmap,
+    XAAPolylinesPixmap, XAAPolySegmentPixmap,
+    XAAPolyRectanglePixmap, XAAPolyArcPixmap,
+    XAAFillPolygonPixmap, XAAPolyFillRectPixmap,
+    XAAPolyFillArcPixmap, XAAPolyText8Pixmap,
+    XAAPolyText16Pixmap, XAAImageText8Pixmap,
+    XAAImageText16Pixmap, XAAImageGlyphBltPixmap,
+    XAAPolyGlyphBltPixmap, XAAPushPixelsPixmap,
+};
diff --git a/hw/xfree86/xaa/xaaGCmisc.c b/hw/xfree86/xaa/xaaGCmisc.c
new file mode 100644
index 000000000..ca69aae74
--- /dev/null
+++ b/hw/xfree86/xaa/xaaGCmisc.c
@@ -0,0 +1,412 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include <X11/fonts/fontstruct.h>
+#include "dixfontstr.h"
+#include "xf86str.h"
+#include "xaa.h"
+#include "xaalocal.h"
+#include "migc.h"
+#include "mi.h"
+#include "gcstruct.h"
+#include "pixmapstr.h"
+
+void
+XAAValidateCopyArea(GCPtr pGC, unsigned long changes, DrawablePtr pDraw)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+
+    if (infoRec->CopyArea &&
+        CHECK_PLANEMASK(pGC, infoRec->CopyAreaFlags) &&
+        CHECK_ROP(pGC, infoRec->CopyAreaFlags) &&
+        CHECK_ROPSRC(pGC, infoRec->CopyAreaFlags)
+        )
+        pGC->ops->CopyArea = infoRec->CopyArea;
+    else
+        pGC->ops->CopyArea = XAAFallbackOps.CopyArea;
+}
+
+void
+XAAValidatePutImage(GCPtr pGC, unsigned long changes, DrawablePtr pDraw)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+
+    if (infoRec->PutImage &&
+        CHECK_PLANEMASK(pGC, infoRec->PutImageFlags) &&
+        CHECK_ROP(pGC, infoRec->PutImageFlags) &&
+        CHECK_ROPSRC(pGC, infoRec->PutImageFlags) &&
+        CHECK_COLORS(pGC, infoRec->PutImageFlags)
+        )
+        pGC->ops->PutImage = infoRec->PutImage;
+    else
+        pGC->ops->PutImage = XAAFallbackOps.PutImage;
+}
+
+void
+XAAValidateCopyPlane(GCPtr pGC, unsigned long changes, DrawablePtr pDraw)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+
+    if (infoRec->CopyPlane &&
+        CHECK_PLANEMASK(pGC, infoRec->CopyPlaneFlags) &&
+        CHECK_ROP(pGC, infoRec->CopyPlaneFlags) &&
+        CHECK_ROPSRC(pGC, infoRec->CopyPlaneFlags) &&
+        CHECK_COLORS(pGC, infoRec->CopyPlaneFlags)
+        )
+        pGC->ops->CopyPlane = infoRec->CopyPlane;
+    else
+        pGC->ops->CopyPlane = XAAFallbackOps.CopyPlane;
+}
+
+void
+XAAValidatePushPixels(GCPtr pGC, unsigned long changes, DrawablePtr pDraw)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+
+    if (infoRec->PushPixelsSolid &&
+        (pGC->fillStyle == FillSolid) &&
+        CHECK_PLANEMASK(pGC, infoRec->PushPixelsFlags) &&
+        CHECK_ROP(pGC, infoRec->PushPixelsFlags) &&
+        CHECK_ROPSRC(pGC, infoRec->PushPixelsFlags) &&
+        CHECK_FG(pGC, infoRec->PushPixelsFlags) &&
+        (!(infoRec->PushPixelsFlags & TRANSPARENCY_GXCOPY_ONLY) ||
+         (pGC->alu == GXcopy))
+        )
+        pGC->ops->PushPixels = infoRec->PushPixelsSolid;
+    else
+        pGC->ops->PushPixels = XAAFallbackOps.PushPixels;
+
+}
+
+/* We make the assumption that the FillSpans, PolyFillRect, FillPolygon
+   and PolyFillArc functions are linked in a way that they all have 
+   the same rop/color/planemask restrictions. If the driver provides 
+   a GC level replacement for these, it will need to supply a new 
+   Validate functions if it breaks this assumption */
+
+void
+XAAValidateFillSpans(GCPtr pGC, unsigned long changes, DrawablePtr pDraw)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+
+    if (pGC->fillStyle != FillTiled)
+        changes &= ~GCTile;
+    if ((pGC->fillStyle == FillTiled) || (pGC->fillStyle == FillSolid))
+        changes &= ~GCStipple;
+    if (!changes)
+        return;
+
+    pGC->ops->FillSpans = XAAFallbackOps.FillSpans;
+    pGC->ops->PolyFillRect = XAAFallbackOps.PolyFillRect;
+    pGC->ops->FillPolygon = XAAFallbackOps.FillPolygon;
+    pGC->ops->PolyFillArc = XAAFallbackOps.PolyFillArc;
+
+    switch (pGC->fillStyle) {
+    case FillSolid:
+        if (infoRec->FillSpansSolid &&
+            CHECK_PLANEMASK(pGC, infoRec->FillSpansSolidFlags) &&
+            CHECK_ROP(pGC, infoRec->FillSpansSolidFlags) &&
+            CHECK_ROPSRC(pGC, infoRec->FillSpansSolidFlags) &&
+            CHECK_FG(pGC, infoRec->FillSpansSolidFlags)
+            ) {
+            pGC->ops->FillSpans = infoRec->FillSpansSolid;
+            pGC->ops->PolyFillRect = infoRec->PolyFillRectSolid;
+            pGC->ops->FillPolygon = infoRec->FillPolygonSolid;
+            pGC->ops->PolyFillArc = infoRec->PolyFillArcSolid;
+        }
+        break;
+        /* The [Stippled/OpaqueStippled/Tiled]FillChooser 
+           functions do the validating */
+    case FillStippled:
+        if (infoRec->FillSpansStippled) {
+            pGC->ops->FillSpans = infoRec->FillSpansStippled;
+            pGC->ops->PolyFillRect = infoRec->PolyFillRectStippled;
+            if (infoRec->FillPolygonStippled)
+                pGC->ops->FillPolygon = infoRec->FillPolygonStippled;
+            else
+                pGC->ops->FillPolygon = miFillPolygon;
+            pGC->ops->PolyFillArc = miPolyFillArc;
+        }
+        break;
+    case FillOpaqueStippled:
+        if (infoRec->FillSpansOpaqueStippled) {
+            pGC->ops->FillSpans = infoRec->FillSpansOpaqueStippled;
+            pGC->ops->PolyFillRect = infoRec->PolyFillRectOpaqueStippled;
+            if (infoRec->FillPolygonOpaqueStippled)
+                pGC->ops->FillPolygon = infoRec->FillPolygonOpaqueStippled;
+            else
+                pGC->ops->FillPolygon = miFillPolygon;
+            pGC->ops->PolyFillArc = miPolyFillArc;
+        }
+        break;
+    case FillTiled:
+        if (infoRec->FillSpansTiled) {
+            pGC->ops->FillSpans = infoRec->FillSpansTiled;
+            pGC->ops->PolyFillRect = infoRec->PolyFillRectTiled;
+            if (infoRec->FillPolygonTiled)
+                pGC->ops->FillPolygon = infoRec->FillPolygonTiled;
+            else
+                pGC->ops->FillPolygon = miFillPolygon;
+            pGC->ops->PolyFillArc = miPolyFillArc;
+        }
+        break;
+    default:
+        return;
+    }
+}
+
+/* We make the assumption that these Text8/16 and GlyphBlt functions
+   are linked in a way that they all have the same rop/color/planemask
+   restrictions. If the driver provides a GC level replacement for
+   these, it will need to supply a new Validate functions if it breaks
+   this assumption */
+
+void
+XAAValidatePolyGlyphBlt(GCPtr pGC, unsigned long changes, DrawablePtr pDraw)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    Bool BigFont = FALSE;
+
+    pGC->ops->PolyText8 = XAAFallbackOps.PolyText8;
+    pGC->ops->PolyText16 = XAAFallbackOps.PolyText16;
+    pGC->ops->PolyGlyphBlt = XAAFallbackOps.PolyGlyphBlt;
+
+    if (!pGC->font)
+        return;
+    if (pGC->fillStyle != FillSolid)
+        return;
+
+    if ((FONTMAXBOUNDS(pGC->font, rightSideBearing) -
+         FONTMINBOUNDS(pGC->font, leftSideBearing) > 32))
+        BigFont = TRUE;
+
+    /* no funny business */
+    if ((FONTMINBOUNDS(pGC->font, characterWidth) <= 0) ||
+        ((FONTASCENT(pGC->font) + FONTDESCENT(pGC->font)) <= 0))
+        return;
+
+    /* Check for TE Fonts */
+    if (!TERMINALFONT(pGC->font) || BigFont) {
+        if (infoRec->PolyGlyphBltNonTE &&
+            CHECK_PLANEMASK(pGC, infoRec->PolyGlyphBltNonTEFlags) &&
+            CHECK_ROP(pGC, infoRec->PolyGlyphBltNonTEFlags) &&
+            CHECK_ROPSRC(pGC, infoRec->PolyGlyphBltNonTEFlags) &&
+            CHECK_FG(pGC, infoRec->PolyGlyphBltNonTEFlags) &&
+            (!(infoRec->PolyGlyphBltNonTEFlags & TRANSPARENCY_GXCOPY_ONLY) ||
+             (pGC->alu == GXcopy))
+            ) {
+            pGC->ops->PolyText8 = infoRec->PolyText8NonTE;
+            pGC->ops->PolyText16 = infoRec->PolyText16NonTE;
+            pGC->ops->PolyGlyphBlt = infoRec->PolyGlyphBltNonTE;
+        }
+    }
+    else {
+        if (infoRec->PolyGlyphBltTE &&
+            CHECK_PLANEMASK(pGC, infoRec->PolyGlyphBltTEFlags) &&
+            CHECK_ROP(pGC, infoRec->PolyGlyphBltTEFlags) &&
+            CHECK_ROPSRC(pGC, infoRec->PolyGlyphBltNonTEFlags) &&
+            CHECK_FG(pGC, infoRec->PolyGlyphBltTEFlags) &&
+            (!(infoRec->PolyGlyphBltTEFlags & TRANSPARENCY_GXCOPY_ONLY) ||
+             (pGC->alu == GXcopy))
+            ) {
+            pGC->ops->PolyText8 = infoRec->PolyText8TE;
+            pGC->ops->PolyText16 = infoRec->PolyText16TE;
+            pGC->ops->PolyGlyphBlt = infoRec->PolyGlyphBltTE;
+        }
+    }
+}
+
+void
+XAAValidateImageGlyphBlt(GCPtr pGC, unsigned long changes, DrawablePtr pDraw)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    Bool BigFont = FALSE;
+
+    pGC->ops->ImageText8 = XAAFallbackOps.ImageText8;
+    pGC->ops->ImageText16 = XAAFallbackOps.ImageText16;
+    pGC->ops->ImageGlyphBlt = XAAFallbackOps.ImageGlyphBlt;
+
+    if (!pGC->font)
+        return;
+
+    if ((FONTMAXBOUNDS(pGC->font, rightSideBearing) -
+         FONTMINBOUNDS(pGC->font, leftSideBearing) > 32))
+        BigFont = TRUE;
+
+    /* no funny business */
+    if ((FONTMINBOUNDS(pGC->font, characterWidth) <= 0) ||
+        ((FONTASCENT(pGC->font) + FONTDESCENT(pGC->font)) <= 0))
+        return;
+
+    /* Check for TE Fonts */
+    if (!TERMINALFONT(pGC->font) || BigFont || (pGC->depth == 32)) {
+        if (infoRec->ImageGlyphBltNonTE &&
+            CHECK_PLANEMASK(pGC, infoRec->ImageGlyphBltNonTEFlags) &&
+            CHECK_FG(pGC, infoRec->ImageGlyphBltNonTEFlags) &&
+            infoRec->SetupForSolidFill &&
+            CHECK_PLANEMASK(pGC, infoRec->SolidFillFlags) &&
+            CHECK_BG(pGC, infoRec->SolidFillFlags)) {
+            pGC->ops->ImageText8 = infoRec->ImageText8NonTE;
+            pGC->ops->ImageText16 = infoRec->ImageText16NonTE;
+            pGC->ops->ImageGlyphBlt = infoRec->ImageGlyphBltNonTE;
+        }
+    }
+    else if (infoRec->ImageGlyphBltTE &&
+             CHECK_PLANEMASK(pGC, infoRec->ImageGlyphBltTEFlags)) {
+        if (!(infoRec->ImageGlyphBltTEFlags & TRANSPARENCY_ONLY) &&
+            CHECK_COLORS(pGC, infoRec->ImageGlyphBltTEFlags)) {
+            pGC->ops->ImageText8 = infoRec->ImageText8TE;
+            pGC->ops->ImageText16 = infoRec->ImageText16TE;
+            pGC->ops->ImageGlyphBlt = infoRec->ImageGlyphBltTE;
+        }
+        else {
+            if (CHECK_FG(pGC, infoRec->ImageGlyphBltTEFlags) &&
+                infoRec->SetupForSolidFill &&
+                CHECK_PLANEMASK(pGC, infoRec->SolidFillFlags) &&
+                CHECK_BG(pGC, infoRec->SolidFillFlags)) {
+                pGC->ops->ImageText8 = infoRec->ImageText8TE;
+                pGC->ops->ImageText16 = infoRec->ImageText16TE;
+                pGC->ops->ImageGlyphBlt = infoRec->ImageGlyphBltTE;
+            }
+        }
+    }
+}
+
+void
+XAAValidatePolylines(GCPtr pGC, unsigned long changes, DrawablePtr pDraw)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    XAAGCPtr pGCPriv = (XAAGCPtr) dixLookupPrivate(&pGC->devPrivates,
+                                                   XAAGetGCKey());
+
+    if (pGC->lineStyle == LineSolid)
+        changes &= ~GCDashList;
+    if (!changes)
+        return;
+
+    pGC->ops->PolySegment = XAAFallbackOps.PolySegment;
+    pGC->ops->Polylines = XAAFallbackOps.Polylines;
+    pGC->ops->PolyRectangle = XAAFallbackOps.PolyRectangle;
+    pGC->ops->PolyArc = XAAFallbackOps.PolyArc;
+
+    if ((pGC->ops->FillSpans != XAAFallbackOps.FillSpans) &&
+        (pGC->lineWidth > 0)) {
+
+        pGC->ops->PolyArc = miPolyArc;
+        pGC->ops->PolySegment = miPolySegment;
+        pGC->ops->PolyRectangle = miPolyRectangle;
+        if (pGC->lineStyle == LineSolid)
+            pGC->ops->Polylines = miWideLine;
+        else
+            pGC->ops->Polylines = miWideDash;
+    }
+
+    if ((pGC->lineWidth == 0) && (pGC->fillStyle == FillSolid)) {
+
+        if (pGC->lineStyle == LineSolid) {
+
+            if (infoRec->PolyRectangleThinSolid &&
+                CHECK_PLANEMASK(pGC, infoRec->PolyRectangleThinSolidFlags) &&
+                CHECK_ROP(pGC, infoRec->PolyRectangleThinSolidFlags) &&
+                CHECK_ROPSRC(pGC, infoRec->PolyRectangleThinSolidFlags) &&
+                CHECK_FG(pGC, infoRec->PolyRectangleThinSolidFlags)) {
+
+                pGC->ops->PolyRectangle = infoRec->PolyRectangleThinSolid;
+            }
+
+            if (infoRec->PolySegmentThinSolid &&
+                CHECK_PLANEMASK(pGC, infoRec->PolySegmentThinSolidFlags) &&
+                CHECK_ROP(pGC, infoRec->PolySegmentThinSolidFlags) &&
+                CHECK_ROPSRC(pGC, infoRec->PolySegmentThinSolidFlags) &&
+                CHECK_FG(pGC, infoRec->PolySegmentThinSolidFlags)) {
+
+                pGC->ops->PolySegment = infoRec->PolySegmentThinSolid;
+            }
+
+            if (infoRec->PolylinesThinSolid &&
+                CHECK_PLANEMASK(pGC, infoRec->PolylinesThinSolidFlags) &&
+                CHECK_ROP(pGC, infoRec->PolylinesThinSolidFlags) &&
+                CHECK_ROPSRC(pGC, infoRec->PolylinesThinSolidFlags) &&
+                CHECK_FG(pGC, infoRec->PolylinesThinSolidFlags)) {
+
+                pGC->ops->Polylines = infoRec->PolylinesThinSolid;
+            }
+        }
+        else if ((pGC->lineStyle == LineOnOffDash) && pGCPriv->DashPattern) {
+
+            if (infoRec->PolySegmentThinDashed &&
+                !(infoRec->PolySegmentThinDashedFlags & NO_TRANSPARENCY) &&
+                ((pGC->alu == GXcopy) || !(infoRec->PolySegmentThinDashedFlags &
+                                           TRANSPARENCY_GXCOPY_ONLY)) &&
+                CHECK_PLANEMASK(pGC, infoRec->PolySegmentThinDashedFlags) &&
+                CHECK_ROP(pGC, infoRec->PolySegmentThinDashedFlags) &&
+                CHECK_ROPSRC(pGC, infoRec->PolySegmentThinDashedFlags) &&
+                CHECK_FG(pGC, infoRec->PolySegmentThinDashedFlags)) {
+
+                pGC->ops->PolySegment = infoRec->PolySegmentThinDashed;
+            }
+
+            if (infoRec->PolylinesThinDashed &&
+                !(infoRec->PolylinesThinDashedFlags & NO_TRANSPARENCY) &&
+                ((pGC->alu == GXcopy) || !(infoRec->PolylinesThinDashedFlags &
+                                           TRANSPARENCY_GXCOPY_ONLY)) &&
+                CHECK_PLANEMASK(pGC, infoRec->PolylinesThinDashedFlags) &&
+                CHECK_ROP(pGC, infoRec->PolylinesThinDashedFlags) &&
+                CHECK_ROPSRC(pGC, infoRec->PolylinesThinDashedFlags) &&
+                CHECK_FG(pGC, infoRec->PolylinesThinDashedFlags)) {
+
+                pGC->ops->Polylines = infoRec->PolylinesThinDashed;
+            }
+
+            if (pGC->ops->Polylines != XAAFallbackOps.Polylines)
+                pGC->ops->PolyRectangle = miPolyRectangle;
+
+        }
+        else if (pGCPriv->DashPattern && (pGC->depth != 32)) {
+            /* LineDoubleDash */
+            if (infoRec->PolySegmentThinDashed &&
+                !(infoRec->PolySegmentThinDashedFlags & TRANSPARENCY_ONLY) &&
+                CHECK_PLANEMASK(pGC, infoRec->PolySegmentThinDashedFlags) &&
+                CHECK_ROP(pGC, infoRec->PolySegmentThinDashedFlags) &&
+                CHECK_ROPSRC(pGC, infoRec->PolySegmentThinDashedFlags) &&
+                CHECK_COLORS(pGC, infoRec->PolySegmentThinDashedFlags)) {
+
+                pGC->ops->PolySegment = infoRec->PolySegmentThinDashed;
+            }
+
+            if (infoRec->PolylinesThinDashed &&
+                !(infoRec->PolylinesThinDashedFlags & TRANSPARENCY_ONLY) &&
+                CHECK_PLANEMASK(pGC, infoRec->PolylinesThinDashedFlags) &&
+                CHECK_ROP(pGC, infoRec->PolylinesThinDashedFlags) &&
+                CHECK_ROPSRC(pGC, infoRec->PolylinesThinDashedFlags) &&
+                CHECK_COLORS(pGC, infoRec->PolylinesThinDashedFlags)) {
+
+                pGC->ops->Polylines = infoRec->PolylinesThinDashed;
+            }
+
+            if (pGC->ops->Polylines != XAAFallbackOps.Polylines)
+                pGC->ops->PolyRectangle = miPolyRectangle;
+
+        }
+    }
+
+    if (infoRec->PolylinesWideSolid &&
+        (pGC->lineWidth > 0) &&
+        (pGC->fillStyle == FillSolid) &&
+        (pGC->lineStyle == LineSolid) &&
+        CHECK_PLANEMASK(pGC, infoRec->PolylinesWideSolidFlags) &&
+        CHECK_ROP(pGC, infoRec->PolylinesWideSolidFlags) &&
+        CHECK_ROPSRC(pGC, infoRec->PolylinesWideSolidFlags) &&
+        CHECK_FG(pGC, infoRec->PolylinesWideSolidFlags)) {
+
+        pGC->ops->Polylines = infoRec->PolylinesWideSolid;
+    }
+}
diff --git a/hw/xfree86/xaa/xaaImage.c b/hw/xfree86/xaa/xaaImage.c
new file mode 100644
index 000000000..4457c9efa
--- /dev/null
+++ b/hw/xfree86/xaa/xaaImage.c
@@ -0,0 +1,534 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+#include "servermd.h"
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include "mi.h"
+#include "pixmapstr.h"
+#include "xf86str.h"
+#include "xaa.h"
+#include "xaalocal.h"
+
+void
+XAAMoveDWORDS_FixedBase(register CARD32 *dest,
+                        register CARD32 *src, register int dwords)
+{
+    while (dwords & ~0x03) {
+        *dest = *src;
+        *dest = *(src + 1);
+        *dest = *(src + 2);
+        *dest = *(src + 3);
+        dwords -= 4;
+        src += 4;
+    }
+
+    if (!dwords)
+        return;
+    *dest = *src;
+    if (dwords == 1)
+        return;
+    *dest = *(src + 1);
+    if (dwords == 2)
+        return;
+    *dest = *(src + 2);
+}
+
+void
+XAAMoveDWORDS(register CARD32 *dest, register CARD32 *src, register int dwords)
+{
+    while (dwords & ~0x03) {
+        *dest = *src;
+        *(dest + 1) = *(src + 1);
+        *(dest + 2) = *(src + 2);
+        *(dest + 3) = *(src + 3);
+        src += 4;
+        dest += 4;
+        dwords -= 4;
+    }
+    if (!dwords)
+        return;
+    *dest = *src;
+    if (dwords == 1)
+        return;
+    *(dest + 1) = *(src + 1);
+    if (dwords == 2)
+        return;
+    *(dest + 2) = *(src + 2);
+}
+
+void
+XAAMoveDWORDS_FixedSrc(register CARD32 *dest,
+                       register CARD32 *src, register int dwords)
+{
+    while (dwords & ~0x03) {
+        *dest = *src;
+        *(dest + 1) = *src;
+        *(dest + 2) = *src;
+        *(dest + 3) = *src;
+        dest += 4;
+        dwords -= 4;
+    }
+    if (!dwords)
+        return;
+    *dest = *src;
+    if (dwords == 1)
+        return;
+    *(dest + 1) = *src;
+    if (dwords == 2)
+        return;
+    *(dest + 2) = *src;
+}
+
+static void
+XAAWritePixmap32To24(ScrnInfoPtr pScrn, int x, int y, int w, int h, unsigned char *srcInit, int srcwidth,       /* bytes */
+                     int rop, unsigned int planemask, int trans)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int count, dwords = bytes_to_int32(w * 3);
+    CARD32 *src, *dst;
+    Bool PlusOne = FALSE;
+
+    if ((infoRec->ImageWriteFlags & CPU_TRANSFER_PAD_QWORD) &&
+        ((dwords * h) & 0x01)) {
+        PlusOne = TRUE;
+    }
+
+    (*infoRec->SetupForImageWrite) (pScrn, rop, planemask, trans, 24, 24);
+    (*infoRec->SubsequentImageWriteRect) (pScrn, x, y, w, h, 0);
+
+    if (dwords > infoRec->ImageWriteRange) {
+        dst = (CARD32 *) infoRec->ImageWriteBase;
+        while (h--) {
+            src = (CARD32 *) srcInit;
+            count = w;
+
+            while (count >= 4) {
+                *dst = (src[0] & 0x00ffffff) | (src[1] << 24);
+                *dst = ((src[1] >> 8) & 0x0000ffff) | (src[2] << 16);
+                *dst = ((src[2] >> 16) & 0x000000ff) | (src[3] << 8);
+                src += 4;
+                count -= 4;
+            }
+            switch (count) {
+            case 0:
+                break;
+            case 1:
+                *dst = src[0];
+                break;
+            case 2:
+                *dst = (src[0] & 0x00ffffff) | (src[1] << 24);
+                *dst = src[1] >> 8;
+                break;
+            default:
+                *dst = (src[0] & 0x00ffffff) | (src[1] << 24);
+                *dst = ((src[1] >> 8) & 0x0000ffff) | (src[2] << 16);
+                *dst = src[2] >> 16;
+                break;
+            }
+            srcInit += srcwidth;
+        }
+    }
+    else {
+        while (h--) {
+            dst = (CARD32 *) infoRec->ImageWriteBase;
+            src = (CARD32 *) srcInit;
+            count = w;
+
+            while (count >= 4) {
+                dst[0] = (src[0] & 0x00ffffff) | (src[1] << 24);
+                dst[1] = ((src[1] >> 8) & 0x0000ffff) | (src[2] << 16);
+                dst[2] = ((src[2] >> 16) & 0x000000ff) | (src[3] << 8);
+                dst += 3;
+                src += 4;
+                count -= 4;
+            }
+            switch (count) {
+            case 0:
+                break;
+            case 1:
+                dst[0] = src[0];
+                break;
+            case 2:
+                dst[0] = (src[0] & 0x00ffffff) | (src[1] << 24);
+                dst[1] = src[1] >> 8;
+                break;
+            default:
+                dst[0] = (src[0] & 0x00ffffff) | (src[1] << 24);
+                dst[1] = ((src[1] >> 8) & 0x0000ffff) | (src[2] << 16);
+                dst[2] = src[2] >> 16;
+                break;
+            }
+            srcInit += srcwidth;
+        }
+    }
+
+    if (PlusOne) {
+        CARD32 *base = (CARD32 *) infoRec->ImageWriteBase;
+
+        *base = 0x00000000;
+    }
+
+    if (infoRec->ImageWriteFlags & SYNC_AFTER_IMAGE_WRITE)
+        (*infoRec->Sync) (pScrn);
+    else
+        SET_SYNC_FLAG(infoRec);
+
+}
+
+void
+XAAWritePixmap(ScrnInfoPtr pScrn, int x, int y, int w, int h, unsigned char *src, int srcwidth, /* bytes */
+               int rop, unsigned int planemask, int trans, int bpp, int depth)
+{
+    XAAInfoRecPtr infoRec;
+    int dwords, skipleft, Bpp;
+    Bool beCareful, PlusOne;
+
+    if ((bpp == 32) && (pScrn->bitsPerPixel == 24)) {
+        XAAWritePixmap32To24(pScrn, x, y, w, h, src, srcwidth,
+                             rop, planemask, trans);
+        return;
+    }
+
+    infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    beCareful = PlusOne = FALSE;
+    Bpp = bpp >> 3;
+
+    if ((skipleft = (long) src & 0x03L)) {
+        if (!(infoRec->ImageWriteFlags & LEFT_EDGE_CLIPPING)) {
+            skipleft = 0;
+            beCareful = TRUE;
+            goto BAD_ALIGNMENT;
+        }
+
+        if (Bpp == 3)
+            skipleft = 4 - skipleft;
+        else
+            skipleft /= Bpp;
+
+        if ((x < skipleft) && !(infoRec->ImageWriteFlags &
+                                LEFT_EDGE_CLIPPING_NEGATIVE_X)) {
+            skipleft = 0;
+            beCareful = TRUE;
+            goto BAD_ALIGNMENT;
+        }
+
+        x -= skipleft;
+        w += skipleft;
+
+        if (Bpp == 3)
+            src -= 3 * skipleft;
+        else                    /* is this Alpha friendly ? */
+            src = (unsigned char *) ((long) src & ~0x03L);
+    }
+
+ BAD_ALIGNMENT:
+
+    dwords = bytes_to_int32(w * Bpp);
+
+    if ((infoRec->ImageWriteFlags & CPU_TRANSFER_PAD_QWORD) &&
+        ((dwords * h) & 0x01)) {
+        PlusOne = TRUE;
+    }
+
+    (*infoRec->SetupForImageWrite) (pScrn, rop, planemask, trans, bpp, depth);
+    (*infoRec->SubsequentImageWriteRect) (pScrn, x, y, w, h, skipleft);
+
+    if (beCareful) {
+        /* in cases with bad alignment we have to be careful not
+           to read beyond the end of the source */
+        if (((x * Bpp) + (dwords << 2)) > srcwidth)
+            h--;
+        else
+            beCareful = FALSE;
+    }
+
+    if (dwords > infoRec->ImageWriteRange) {
+        while (h--) {
+            XAAMoveDWORDS_FixedBase((CARD32 *) infoRec->ImageWriteBase,
+                                    (CARD32 *) src, dwords);
+            src += srcwidth;
+        }
+        if (beCareful) {
+            int shift = ((long) src & 0x03L) << 3;
+
+            if (--dwords)
+                XAAMoveDWORDS_FixedBase((CARD32 *) infoRec->ImageWriteBase,
+                                        (CARD32 *) src, dwords);
+            src = (unsigned char *) ((long) (src + (dwords << 2)) & ~0x03L);
+            *((CARD32 *) infoRec->ImageWriteBase) = *((CARD32 *) src) >> shift;
+        }
+    }
+    else {
+        if (srcwidth == (dwords << 2)) {
+            int decrement = infoRec->ImageWriteRange / dwords;
+
+            while (h > decrement) {
+                XAAMoveDWORDS((CARD32 *) infoRec->ImageWriteBase,
+                              (CARD32 *) src, dwords * decrement);
+                src += (srcwidth * decrement);
+                h -= decrement;
+            }
+            if (h) {
+                XAAMoveDWORDS((CARD32 *) infoRec->ImageWriteBase,
+                              (CARD32 *) src, dwords * h);
+                if (beCareful)
+                    src += (srcwidth * h);
+            }
+        }
+        else {
+            while (h--) {
+                XAAMoveDWORDS((CARD32 *) infoRec->ImageWriteBase,
+                              (CARD32 *) src, dwords);
+                src += srcwidth;
+            }
+        }
+
+        if (beCareful) {
+            int shift = ((long) src & 0x03L) << 3;
+
+            if (--dwords)
+                XAAMoveDWORDS((CARD32 *) infoRec->ImageWriteBase,
+                              (CARD32 *) src, dwords);
+            src = (unsigned char *) ((long) (src + (dwords << 2)) & ~0x03L);
+
+            ((CARD32 *) infoRec->ImageWriteBase)[dwords] =
+                *((CARD32 *) src) >> shift;
+        }
+    }
+
+    if (PlusOne) {
+        CARD32 *base = (CARD32 *) infoRec->ImageWriteBase;
+
+        *base = 0x00000000;
+    }
+
+    if (infoRec->ImageWriteFlags & SYNC_AFTER_IMAGE_WRITE)
+        (*infoRec->Sync) (pScrn);
+    else
+        SET_SYNC_FLAG(infoRec);
+}
+
+void
+XAAWritePixmapScanline(ScrnInfoPtr pScrn, int x, int y, int w, int h, unsigned char *src, int srcwidth, /* bytes */
+                       int rop,
+                       unsigned int planemask, int trans, int bpp, int depth)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int dwords, skipleft, bufferNo = 0, Bpp = bpp >> 3;
+    Bool beCareful = FALSE;
+    CARD32 *base;
+
+    if ((skipleft = (long) src & 0x03L)) {
+        if (!(infoRec->ScanlineImageWriteFlags & LEFT_EDGE_CLIPPING)) {
+            skipleft = 0;
+            beCareful = TRUE;
+            goto BAD_ALIGNMENT;
+        }
+
+        if (Bpp == 3)
+            skipleft = 4 - skipleft;
+        else
+            skipleft /= Bpp;
+
+        if ((x < skipleft) && !(infoRec->ScanlineImageWriteFlags &
+                                LEFT_EDGE_CLIPPING_NEGATIVE_X)) {
+            skipleft = 0;
+            beCareful = TRUE;
+            goto BAD_ALIGNMENT;
+        }
+
+        x -= skipleft;
+        w += skipleft;
+
+        if (Bpp == 3)
+            src -= 3 * skipleft;
+        else
+            src = (unsigned char *) ((long) src & ~0x03L);
+    }
+
+ BAD_ALIGNMENT:
+
+    dwords = bytes_to_int32(w * Bpp);
+
+    (*infoRec->SetupForScanlineImageWrite) (pScrn, rop, planemask, trans, bpp,
+                                            depth);
+    (*infoRec->SubsequentScanlineImageWriteRect) (pScrn, x, y, w, h, skipleft);
+
+    if (beCareful) {
+        /* in cases with bad alignment we have to be careful not
+           to read beyond the end of the source */
+        if (((x * Bpp) + (dwords << 2)) > srcwidth)
+            h--;
+        else
+            beCareful = FALSE;
+    }
+
+    while (h--) {
+        base = (CARD32 *) infoRec->ScanlineImageWriteBuffers[bufferNo];
+        XAAMoveDWORDS(base, (CARD32 *) src, dwords);
+        (*infoRec->SubsequentImageWriteScanline) (pScrn, bufferNo++);
+        src += srcwidth;
+        if (bufferNo >= infoRec->NumScanlineImageWriteBuffers)
+            bufferNo = 0;
+    }
+
+    if (beCareful) {
+        int shift = ((long) src & 0x03L) << 3;
+
+        base = (CARD32 *) infoRec->ScanlineImageWriteBuffers[bufferNo];
+        if (--dwords)
+            XAAMoveDWORDS(base, (CARD32 *) src, dwords);
+        src = (unsigned char *) ((long) (src + (dwords << 2)) & ~0x03L);
+
+        base[dwords] = *((CARD32 *) src) >> shift;
+        (*infoRec->SubsequentImageWriteScanline) (pScrn, bufferNo);
+    }
+
+    SET_SYNC_FLAG(infoRec);
+}
+
+void
+XAAPutImage(DrawablePtr pDraw,
+            GCPtr pGC,
+            int depth,
+            int x, int y, int w, int h, int leftPad, int format, char *pImage)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    int bpp = BitsPerPixel(depth);
+    Bool depthBug = FALSE;
+
+    if (!w || !h)
+        return;
+
+    if (!RegionNumRects(pGC->pCompositeClip))
+        return;
+
+    depthBug = XAA_DEPTH_BUG(pGC);
+
+    if (((format == ZPixmap) && infoRec->WritePixmap &&
+         ((pDraw->bitsPerPixel == bpp) ||
+          ((pDraw->bitsPerPixel == 24) && (bpp == 32) &&
+           (infoRec->WritePixmapFlags & CONVERT_32BPP_TO_24BPP))) &&
+         CHECK_ROP(pGC, infoRec->WritePixmapFlags) &&
+         CHECK_ROPSRC(pGC, infoRec->WritePixmapFlags) &&
+         CHECK_PLANEMASK(pGC, infoRec->WritePixmapFlags) &&
+         CHECK_NO_GXCOPY(pGC, infoRec->WritePixmapFlags)) ||
+        ((format == XYBitmap) && !depthBug && infoRec->WriteBitmap &&
+         CHECK_ROP(pGC, infoRec->WriteBitmapFlags) &&
+         CHECK_ROPSRC(pGC, infoRec->WriteBitmapFlags) &&
+         CHECK_PLANEMASK(pGC, infoRec->WriteBitmapFlags) &&
+         CHECK_COLORS(pGC, infoRec->WriteBitmapFlags) &&
+         !(infoRec->WriteBitmapFlags & TRANSPARENCY_ONLY)) ||
+        ((format == XYPixmap) && !depthBug && infoRec->WriteBitmap &&
+         CHECK_ROP(pGC, infoRec->WriteBitmapFlags) &&
+         CHECK_ROPSRC(pGC, infoRec->WriteBitmapFlags) &&
+         !(infoRec->WriteBitmapFlags & NO_PLANEMASK) &&
+         !(infoRec->WriteBitmapFlags & TRANSPARENCY_ONLY))) {
+
+        int MaxBoxes = RegionNumRects(pGC->pCompositeClip);
+        BoxPtr pbox, pClipBoxes;
+        int nboxes, srcx, srcy, srcwidth;
+        xRectangle TheRect;
+
+        TheRect.x = pDraw->x + x;
+        TheRect.y = pDraw->y + y;
+        TheRect.width = w;
+        TheRect.height = h;
+
+        if (MaxBoxes > (infoRec->PreAllocSize / sizeof(BoxRec))) {
+            pClipBoxes = malloc(MaxBoxes * sizeof(BoxRec));
+            if (!pClipBoxes)
+                return;
+        }
+        else
+            pClipBoxes = (BoxPtr) infoRec->PreAllocMem;
+
+        nboxes = XAAGetRectClipBoxes(pGC, pClipBoxes, 1, &TheRect);
+        pbox = pClipBoxes;
+
+        if (format == XYBitmap) {
+            srcwidth = BitmapBytePad(leftPad + w);
+            while (nboxes--) {
+                srcx = pbox->x1 - TheRect.x + leftPad;
+                srcy = pbox->y1 - TheRect.y;
+                (*infoRec->WriteBitmap) (infoRec->pScrn, pbox->x1, pbox->y1,
+                                         pbox->x2 - pbox->x1,
+                                         pbox->y2 - pbox->y1,
+                                         (unsigned char *) pImage +
+                                         (srcwidth * srcy) + ((srcx >> 5) << 2),
+                                         srcwidth, srcx & 31, pGC->fgPixel,
+                                         pGC->bgPixel, pGC->alu,
+                                         pGC->planemask);
+                pbox++;
+            }
+        }
+        else if (format == ZPixmap) {
+            int Bpp = bpp >> 3;
+
+            srcwidth = PixmapBytePad(leftPad + w, depth);
+            while (nboxes--) {
+                srcx = pbox->x1 - TheRect.x + leftPad;
+                srcy = pbox->y1 - TheRect.y;
+                (*infoRec->WritePixmap) (infoRec->pScrn, pbox->x1, pbox->y1,
+                                         pbox->x2 - pbox->x1,
+                                         pbox->y2 - pbox->y1,
+                                         (unsigned char *) pImage +
+                                         (srcwidth * srcy) + (srcx * Bpp),
+                                         srcwidth, pGC->alu, pGC->planemask, -1,
+                                         Bpp << 3, depth);
+                pbox++;
+            }
+        }
+        else {                  /* XYPixmap */
+            int depth = pGC->depth;
+            int numBox, increment;
+            unsigned long i, mask;
+            BoxPtr pntBox;
+
+            srcwidth = BitmapBytePad(w + leftPad);
+            increment = h * srcwidth;
+            i = 1 << (depth - 1);
+            mask = ~0;
+
+            if ((infoRec->pScrn->overlayFlags & OVERLAY_8_32_PLANAR) &&
+                (pGC->depth == 8)) {
+                i = 0x80000000;
+                mask = 0xff000000;
+            }
+
+            for (; i & mask; i >>= 1, pImage += increment) {
+                if (i & pGC->planemask) {
+                    pntBox = pbox;
+                    numBox = nboxes;
+                    while (numBox--) {
+                        srcx = pntBox->x1 - TheRect.x + leftPad;
+                        srcy = pntBox->y1 - TheRect.y;
+                        (*infoRec->WriteBitmap) (infoRec->pScrn,
+                                                 pntBox->x1, pntBox->y1,
+                                                 pntBox->x2 - pntBox->x1,
+                                                 pntBox->y2 - pntBox->y1,
+                                                 (unsigned char *) pImage +
+                                                 (srcwidth * srcy) +
+                                                 ((srcx >> 5) << 2), srcwidth,
+                                                 srcx & 31, ~0, 0, pGC->alu, i);
+                        pntBox++;
+                    }
+                }
+            }
+
+        }
+
+        if (pClipBoxes != (BoxPtr) infoRec->PreAllocMem)
+            free(pClipBoxes);
+    }
+    else
+        XAAFallbackOps.PutImage(pDraw, pGC, depth, x, y, w, h, leftPad,
+                                format, pImage);
+}
diff --git a/hw/xfree86/xaa/xaaInit.c b/hw/xfree86/xaa/xaaInit.c
new file mode 100644
index 000000000..574fea50c
--- /dev/null
+++ b/hw/xfree86/xaa/xaaInit.c
@@ -0,0 +1,635 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include "pixmapstr.h"
+#include "windowstr.h"
+#include "xf86str.h"
+#include "mi.h"
+#include "miline.h"
+#include "xaa.h"
+#include "xaalocal.h"
+#include "xaawrap.h"
+#include "xf86fbman.h"
+#include "servermd.h"
+#ifdef COMPOSITE
+#include "cw.h"
+#endif
+
+#define MAX_PREALLOC_MEM	65536   /* MUST be >= 1024 */
+
+#define MIN_OFFPIX_SIZE		(320*200)
+
+static Bool XAACloseScreen(ScreenPtr pScreen);
+static void XAAGetImage(DrawablePtr pDrawable, int sx, int sy, int w, int h,
+                        unsigned int format, unsigned long planemask,
+                        char *pdstLine);
+static void XAAGetSpans(DrawablePtr pDrawable, int wMax, DDXPointPtr ppt,
+                        int *pwidth, int nspans, char *pdstStart);
+static PixmapPtr XAACreatePixmap(ScreenPtr pScreen, int w, int h, int depth,
+                                 unsigned usage_hint);
+static Bool XAADestroyPixmap(PixmapPtr pPixmap);
+static Bool XAAEnterVT(ScrnInfoPtr pScrn);
+static void XAALeaveVT(ScrnInfoPtr pScrn);
+static int XAASetDGAMode(ScrnInfoPtr pScrn, int num, DGADevicePtr devRet);
+static void XAAEnableDisableFBAccess(ScrnInfoPtr pScrn, Bool enable);
+static Bool XAAChangeWindowAttributes(WindowPtr pWin, unsigned long mask);
+
+static DevPrivateKeyRec XAAScreenKeyRec;
+
+#define XAAScreenKey (&XAAScreenKeyRec)
+static DevPrivateKeyRec XAAGCKeyRec;
+
+#define XAAGCKey (&XAAGCKeyRec)
+static DevPrivateKeyRec XAAPixmapKeyRec;
+
+#define XAAPixmapKey (&XAAPixmapKeyRec)
+
+DevPrivateKey
+XAAGetScreenKey(void)
+{
+    return XAAScreenKey;
+}
+
+DevPrivateKey
+XAAGetGCKey(void)
+{
+    return XAAGCKey;
+}
+
+DevPrivateKey
+XAAGetPixmapKey(void)
+{
+    return XAAPixmapKey;
+}
+
+/* temp kludge */
+static Bool SwitchedOut = FALSE;
+
+XAAInfoRecPtr
+XAACreateInfoRec(void)
+{
+    XAAInfoRecPtr infoRec;
+
+    infoRec = calloc(1, sizeof(XAAInfoRec));
+    if (infoRec)
+        infoRec->CachePixelGranularity = -1;
+
+    return infoRec;
+}
+
+void
+XAADestroyInfoRec(XAAInfoRecPtr infoRec)
+{
+    if (!infoRec)
+        return;
+
+    if (infoRec->ClosePixmapCache)
+        (*infoRec->ClosePixmapCache) (xf86ScrnToScreen(infoRec->pScrn));
+
+    free(infoRec->PreAllocMem);
+
+    free(infoRec->PixmapCachePrivate);
+
+    free(infoRec);
+}
+
+Bool
+XAAInit(ScreenPtr pScreen, XAAInfoRecPtr infoRec)
+{
+    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
+    XAAScreenPtr pScreenPriv;
+    int i;
+    PictureScreenPtr ps = GetPictureScreenIfSet(pScreen);
+
+    /* Return successfully if no acceleration wanted */
+    if (!infoRec)
+        return TRUE;
+
+    if (!dixRegisterPrivateKey(&XAAGCKeyRec, PRIVATE_GC, sizeof(XAAGCRec)))
+        return FALSE;
+
+    if (!dixRegisterPrivateKey
+        (&XAAPixmapKeyRec, PRIVATE_PIXMAP, sizeof(XAAPixmapRec)))
+        return FALSE;
+
+    if (!dixRegisterPrivateKey(&XAAScreenKeyRec, PRIVATE_SCREEN, 0))
+        return FALSE;
+
+    if (!(pScreenPriv = malloc(sizeof(XAAScreenRec))))
+        return FALSE;
+
+    dixSetPrivate(&pScreen->devPrivates, XAAScreenKey, pScreenPriv);
+
+    if (!xf86FBManagerRunning(pScreen))
+        infoRec->Flags &= ~(PIXMAP_CACHE | OFFSCREEN_PIXMAPS);
+    if (!(infoRec->Flags & LINEAR_FRAMEBUFFER))
+        infoRec->Flags &= ~OFFSCREEN_PIXMAPS;
+
+    if (!infoRec->FullPlanemask) {      /* for backwards compatibility */
+        infoRec->FullPlanemask = (1 << pScrn->depth) - 1;
+        infoRec->FullPlanemasks[pScrn->depth - 1] = infoRec->FullPlanemask;
+    }
+
+    for (i = 0; i < 32; i++) {
+        if (!infoRec->FullPlanemasks[i])        /* keep any set by caller */
+            infoRec->FullPlanemasks[i] = (1 << (i + 1)) - 1;
+    }
+
+    if (!XAAInitAccel(pScreen, infoRec))
+        return FALSE;
+    pScreenPriv->AccelInfoRec = infoRec;
+    infoRec->ScratchGC.pScreen = pScreen;
+
+    if (!infoRec->GetImage)
+        infoRec->GetImage = XAAGetImage;
+    if (!infoRec->GetSpans)
+        infoRec->GetSpans = XAAGetSpans;
+    if (!infoRec->CopyWindow)
+        infoRec->CopyWindow = XAACopyWindow;
+
+    pScreenPriv->CreateGC = pScreen->CreateGC;
+    pScreen->CreateGC = XAACreateGC;
+    pScreenPriv->CloseScreen = pScreen->CloseScreen;
+    pScreen->CloseScreen = XAACloseScreen;
+    pScreenPriv->GetImage = pScreen->GetImage;
+    pScreen->GetImage = infoRec->GetImage;
+    pScreenPriv->GetSpans = pScreen->GetSpans;
+    pScreen->GetSpans = infoRec->GetSpans;
+    pScreenPriv->CopyWindow = pScreen->CopyWindow;
+    pScreen->CopyWindow = infoRec->CopyWindow;
+    pScreenPriv->CreatePixmap = pScreen->CreatePixmap;
+    pScreen->CreatePixmap = XAACreatePixmap;
+    pScreenPriv->DestroyPixmap = pScreen->DestroyPixmap;
+    pScreen->DestroyPixmap = XAADestroyPixmap;
+    pScreenPriv->ChangeWindowAttributes = pScreen->ChangeWindowAttributes;
+    pScreen->ChangeWindowAttributes = XAAChangeWindowAttributes;
+
+    pScreenPriv->EnterVT = pScrn->EnterVT;
+    pScrn->EnterVT = XAAEnterVT;
+    pScreenPriv->LeaveVT = pScrn->LeaveVT;
+    pScrn->LeaveVT = XAALeaveVT;
+    pScreenPriv->SetDGAMode = pScrn->SetDGAMode;
+    pScrn->SetDGAMode = XAASetDGAMode;
+    pScreenPriv->EnableDisableFBAccess = pScrn->EnableDisableFBAccess;
+    pScrn->EnableDisableFBAccess = XAAEnableDisableFBAccess;
+
+    pScreenPriv->WindowExposures = pScreen->WindowExposures;
+    if (ps) {
+        pScreenPriv->Composite = ps->Composite;
+        ps->Composite = XAAComposite;
+        pScreenPriv->Glyphs = ps->Glyphs;
+        ps->Glyphs = XAAGlyphs;
+    }
+    if (pScrn->overlayFlags & OVERLAY_8_32_PLANAR)
+        XAASetupOverlay8_32Planar(pScreen);
+
+    infoRec->PreAllocMem = malloc(MAX_PREALLOC_MEM);
+    if (infoRec->PreAllocMem)
+        infoRec->PreAllocSize = MAX_PREALLOC_MEM;
+
+    if (infoRec->Flags & PIXMAP_CACHE)
+        xf86RegisterFreeBoxCallback(pScreen, infoRec->InitPixmapCache,
+                                    infoRec);
+
+    if (infoRec->Flags & MICROSOFT_ZERO_LINE_BIAS)
+        miSetZeroLineBias(pScreen, OCTANT1 | OCTANT2 | OCTANT3 | OCTANT4);
+
+#ifdef COMPOSITE
+    /* Initialize the composite wrapper.  This needs to happen after the
+     * wrapping above (so it comes before us), but before all other extensions,
+     * so it doesn't confuse them. (particularly damage).
+     */
+    miInitializeCompositeWrapper(pScreen);
+#endif
+
+    return TRUE;
+}
+
+static Bool
+XAACloseScreen(ScreenPtr pScreen)
+{
+    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
+    XAAScreenPtr pScreenPriv =
+        (XAAScreenPtr) dixLookupPrivate(&pScreen->devPrivates, XAAScreenKey);
+
+    pScrn->EnterVT = pScreenPriv->EnterVT;
+    pScrn->LeaveVT = pScreenPriv->LeaveVT;
+    pScrn->EnableDisableFBAccess = pScreenPriv->EnableDisableFBAccess;
+
+    pScreen->CreateGC = pScreenPriv->CreateGC;
+    pScreen->CloseScreen = pScreenPriv->CloseScreen;
+    pScreen->GetImage = pScreenPriv->GetImage;
+    pScreen->GetSpans = pScreenPriv->GetSpans;
+    pScreen->CopyWindow = pScreenPriv->CopyWindow;
+    pScreen->WindowExposures = pScreenPriv->WindowExposures;
+    pScreen->CreatePixmap = pScreenPriv->CreatePixmap;
+    pScreen->DestroyPixmap = pScreenPriv->DestroyPixmap;
+    pScreen->ChangeWindowAttributes = pScreenPriv->ChangeWindowAttributes;
+
+    /* We leave it up to the client to free the XAAInfoRec */
+
+    free(pScreenPriv);
+
+    return (*pScreen->CloseScreen) (pScreen);
+}
+
+static void
+XAAGetImage(DrawablePtr pDraw,
+            int sx, int sy, int w, int h,
+            unsigned int format, unsigned long planemask, char *pdstLine)
+{
+    ScreenPtr pScreen = pDraw->pScreen;
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
+    ScrnInfoPtr pScrn = infoRec->pScrn;
+
+    if (pScrn->vtSema &&
+        ((pDraw->type == DRAWABLE_WINDOW) || IS_OFFSCREEN_PIXMAP(pDraw))) {
+        if (infoRec->ReadPixmap && (format == ZPixmap) &&
+            ((planemask & infoRec->FullPlanemasks[pDraw->depth - 1]) ==
+             infoRec->FullPlanemasks[pDraw->depth - 1]) &&
+            (pDraw->bitsPerPixel == BitsPerPixel(pDraw->depth))) {
+            (*infoRec->ReadPixmap) (pScrn,
+                                    sx + pDraw->x, sy + pDraw->y, w, h,
+                                    (unsigned char *) pdstLine,
+                                    PixmapBytePad(w, pDraw->depth),
+                                    pDraw->bitsPerPixel, pDraw->depth);
+            return;
+        }
+        SYNC_CHECK(pDraw);
+    }
+
+    XAA_SCREEN_PROLOGUE(pScreen, GetImage);
+    (*pScreen->GetImage) (pDraw, sx, sy, w, h, format, planemask, pdstLine);
+    XAA_SCREEN_EPILOGUE(pScreen, GetImage, XAAGetImage);
+}
+
+static void
+XAAGetSpans(DrawablePtr pDraw,
+            int wMax, DDXPointPtr ppt, int *pwidth, int nspans, char *pdstStart)
+{
+    ScreenPtr pScreen = pDraw->pScreen;
+
+    XAA_SCREEN_PROLOGUE(pScreen, GetSpans);
+    if (xf86ScreenToScrn(pScreen)->vtSema &&
+        ((pDraw->type == DRAWABLE_WINDOW) || IS_OFFSCREEN_PIXMAP(pDraw))) {
+        SYNC_CHECK(pDraw);
+    }
+    (*pScreen->GetSpans) (pDraw, wMax, ppt, pwidth, nspans, pdstStart);
+    XAA_SCREEN_EPILOGUE(pScreen, GetSpans, XAAGetSpans);
+}
+
+static int
+XAAPixmapBPP(ScreenPtr pScreen, int depth)
+{
+    PixmapPtr pPix;
+    int bpp;
+    DestroyPixmapProcPtr destroyPixmap;
+
+    XAA_SCREEN_PROLOGUE(pScreen, CreatePixmap);
+    pPix = (*pScreen->CreatePixmap) (pScreen, 1, 1, depth,
+                                     CREATE_PIXMAP_USAGE_SCRATCH);
+    XAA_SCREEN_EPILOGUE(pScreen, CreatePixmap, XAACreatePixmap);
+    if (!pPix)
+        return 0;
+    bpp = pPix->drawable.bitsPerPixel;
+    destroyPixmap = pScreen->DestroyPixmap;
+    XAA_SCREEN_PROLOGUE(pScreen, DestroyPixmap);
+    (*pScreen->DestroyPixmap) (pPix);
+    XAA_SCREEN_EPILOGUE(pScreen, DestroyPixmap, destroyPixmap);
+    return bpp;
+}
+
+static void
+XAAInitializeOffscreenDepths(ScreenPtr pScreen)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
+    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
+    int d, dep;
+
+    infoRec->offscreenDepthsInitialized = TRUE;
+    infoRec->offscreenDepths = 0;
+    if (infoRec->Flags & OFFSCREEN_PIXMAPS) {
+        for (d = 0; d < pScreen->numDepths; d++) {
+            dep = pScreen->allowedDepths[d].depth;
+            if (XAAPixmapBPP(pScreen, dep) == pScrn->bitsPerPixel)
+                infoRec->offscreenDepths |= (1 << (dep - 1));
+        }
+    }
+}
+
+static PixmapPtr
+XAACreatePixmap(ScreenPtr pScreen, int w, int h, int depth, unsigned usage_hint)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
+    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
+    XAAPixmapPtr pPriv;
+    PixmapPtr pPix = NULL;
+    int size = w * h;
+
+    if (w > 32767 || h > 32767)
+        return NullPixmap;
+
+    if (!infoRec->offscreenDepthsInitialized)
+        XAAInitializeOffscreenDepths(pScreen);
+
+    if (pScrn->vtSema &&
+        (usage_hint != CREATE_PIXMAP_USAGE_GLYPH_PICTURE) &&
+        (infoRec->offscreenDepths & (1 << (depth - 1))) &&
+        (size >= MIN_OFFPIX_SIZE) && !SwitchedOut &&
+        (!infoRec->maxOffPixWidth || (w <= infoRec->maxOffPixWidth)) &&
+        (!infoRec->maxOffPixHeight || (h <= infoRec->maxOffPixHeight))) {
+        PixmapLinkPtr pLink;
+        PixmapPtr pScreenPix;
+        FBAreaPtr area;
+        int gran = 0;
+
+        switch (pScrn->bitsPerPixel) {
+        case 24:
+        case 8:
+            gran = 4;
+            break;
+        case 16:
+            gran = 2;
+            break;
+        case 32:
+            gran = 1;
+            break;
+        default:
+            break;
+        }
+
+        if (BITMAP_SCANLINE_PAD == 64)
+            gran *= 2;
+
+        if (!(area = xf86AllocateOffscreenArea(pScreen, w, h, gran, 0,
+                                               XAARemoveAreaCallback, NULL))) {
+            goto BAILOUT;
+        }
+
+        if (!(pLink = malloc(sizeof(PixmapLink)))) {
+            xf86FreeOffscreenArea(area);
+            goto BAILOUT;
+        }
+
+        XAA_SCREEN_PROLOGUE(pScreen, CreatePixmap);
+        pPix = (*pScreen->CreatePixmap) (pScreen, 0, 0, depth, usage_hint);
+        XAA_SCREEN_EPILOGUE(pScreen, CreatePixmap, XAACreatePixmap);
+
+        if (!pPix) {
+            free(pLink);
+            xf86FreeOffscreenArea(area);
+            goto BAILOUT;
+        }
+
+        pScreenPix = (*pScreen->GetScreenPixmap) (pScreen);
+
+        pPriv = XAA_GET_PIXMAP_PRIVATE(pPix);
+        pPix->drawable.x = area->box.x1;
+        pPix->drawable.y = area->box.y1;
+        pPix->drawable.width = w;
+        pPix->drawable.height = h;
+        pPix->drawable.bitsPerPixel = pScrn->bitsPerPixel;
+        pPix->devKind = pScreenPix->devKind;
+        pPix->devPrivate.ptr = pScreenPix->devPrivate.ptr;
+        area->devPrivate.ptr = pPix;
+
+        pPriv->flags = OFFSCREEN;
+        pPriv->offscreenArea = area;
+        pPriv->freeData = FALSE;
+
+        pLink->next = infoRec->OffscreenPixmaps;
+        pLink->pPix = pPix;
+        infoRec->OffscreenPixmaps = pLink;
+        return pPix;
+    }
+ BAILOUT:
+    XAA_SCREEN_PROLOGUE(pScreen, CreatePixmap);
+    pPix = (*pScreen->CreatePixmap) (pScreen, w, h, depth, usage_hint);
+    XAA_SCREEN_EPILOGUE(pScreen, CreatePixmap, XAACreatePixmap);
+
+    if (pPix) {
+        pPriv = XAA_GET_PIXMAP_PRIVATE(pPix);
+        pPriv->flags = 0;
+        pPriv->offscreenArea = NULL;
+        pPriv->freeData = FALSE;
+        if (!w || !h)           /* either scratch or shared memory */
+            pPriv->flags |= SHARED_PIXMAP;
+    }
+
+    return pPix;
+}
+
+static Bool
+XAADestroyPixmap(PixmapPtr pPix)
+{
+    ScreenPtr pScreen = pPix->drawable.pScreen;
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
+    XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pPix);
+    Bool ret;
+
+    if (pPix->refcnt == 1) {
+        if (pPriv->flags & OFFSCREEN) {
+            if (pPriv->flags & DGA_PIXMAP)
+                free(pPriv->offscreenArea);
+            else {
+                FBAreaPtr area = pPriv->offscreenArea;
+                PixmapLinkPtr pLink = infoRec->OffscreenPixmaps;
+                PixmapLinkPtr prev = NULL;
+
+                while (pLink->pPix != pPix) {
+                    prev = pLink;
+                    pLink = pLink->next;
+                }
+
+                if (prev)
+                    prev->next = pLink->next;
+                else
+                    infoRec->OffscreenPixmaps = pLink->next;
+
+                if (!area)
+                    area = pLink->area;
+
+                xf86FreeOffscreenArea(area);
+                pPriv->offscreenArea = NULL;
+                free(pLink);
+            }
+        }
+
+        if (pPriv->freeData) {  /* pixmaps that were once in video ram */
+            free(pPix->devPrivate.ptr);
+            pPix->devPrivate.ptr = NULL;
+        }
+    }
+
+    XAA_SCREEN_PROLOGUE(pScreen, DestroyPixmap);
+    ret = (*pScreen->DestroyPixmap) (pPix);
+    XAA_SCREEN_EPILOGUE(pScreen, DestroyPixmap, XAADestroyPixmap);
+
+    return ret;
+}
+
+static Bool
+XAAChangeWindowAttributes(WindowPtr pWin, unsigned long mask)
+{
+    ScreenPtr pScreen = pWin->drawable.pScreen;
+    Bool ret;
+
+    XAA_SCREEN_PROLOGUE(pScreen, ChangeWindowAttributes);
+    ret = (*pScreen->ChangeWindowAttributes) (pWin, mask);
+    XAA_SCREEN_EPILOGUE(pScreen, ChangeWindowAttributes,
+                        XAAChangeWindowAttributes);
+
+    /* we have to assume that shared memory pixmaps are dirty
+       because we can't wrap operations on them */
+
+    if ((mask & CWBackPixmap) && (pWin->backgroundState == BackgroundPixmap) &&
+        PIXMAP_IS_SHARED(pWin->background.pixmap)) {
+        XAAPixmapPtr pPixPriv = XAA_GET_PIXMAP_PRIVATE(pWin->background.pixmap);
+
+        pPixPriv->flags |= DIRTY;
+    }
+    if ((mask & CWBorderPixmap) && !(pWin->borderIsPixel) &&
+        PIXMAP_IS_SHARED(pWin->border.pixmap)) {
+        XAAPixmapPtr pPixPriv = XAA_GET_PIXMAP_PRIVATE(pWin->border.pixmap);
+
+        pPixPriv->flags |= DIRTY;
+    }
+
+    return ret;
+}
+
+/*  These two aren't really needed for anything */
+
+static Bool
+XAAEnterVT(ScrnInfoPtr pScrn)
+{
+    Bool ret;
+    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
+    XAAScreenPtr pScreenPriv =
+        (XAAScreenPtr) dixLookupPrivate(&pScreen->devPrivates, XAAScreenKey);
+
+    pScrn->EnterVT = pScreenPriv->EnterVT;
+    ret = ((*pScreenPriv->EnterVT) (pScrn));
+    pScreenPriv->EnterVT = pScrn->EnterVT;
+    pScrn->EnterVT = XAAEnterVT;
+    return ret;
+}
+
+static void
+XAALeaveVT(ScrnInfoPtr pScrn)
+{
+    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
+    XAAScreenPtr pScreenPriv =
+        (XAAScreenPtr) dixLookupPrivate(&pScreen->devPrivates, XAAScreenKey);
+    XAAInfoRecPtr infoRec = pScreenPriv->AccelInfoRec;
+
+    if (infoRec->NeedToSync) {
+        (*infoRec->Sync) (infoRec->pScrn);
+        infoRec->NeedToSync = FALSE;
+    }
+
+    pScrn->LeaveVT = pScreenPriv->LeaveVT;
+    (*pScreenPriv->LeaveVT) (pScrn);
+    pScreenPriv->LeaveVT = pScrn->LeaveVT;
+    pScrn->LeaveVT = XAALeaveVT;
+}
+
+typedef struct {
+    Bool UsingPixmapCache;
+    Bool CanDoColor8x8;
+    Bool CanDoMono8x8;
+} SavedCacheState, *SavedCacheStatePtr;
+
+static int
+XAASetDGAMode(ScrnInfoPtr pScrn, int num, DGADevicePtr devRet)
+{
+    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
+    XAAScreenPtr pScreenPriv =
+        (XAAScreenPtr) dixLookupPrivate(&pScreen->devPrivates, XAAScreenKey);
+    int ret;
+
+    if (!num && infoRec->dgaSaves) {    /* restore old pixmap cache state */
+        SavedCacheStatePtr state = (SavedCacheStatePtr) infoRec->dgaSaves;
+
+        infoRec->UsingPixmapCache = state->UsingPixmapCache;
+        infoRec->CanDoColor8x8 = state->CanDoColor8x8;
+        infoRec->CanDoMono8x8 = state->CanDoMono8x8;
+        free(infoRec->dgaSaves);
+        infoRec->dgaSaves = NULL;
+    }
+
+    ret = (*pScreenPriv->SetDGAMode) (pScrn, num, devRet);
+    if (ret != Success)
+        return ret;
+
+    if (num && devRet->pPix) {  /* accelerate this pixmap */
+        XAAPixmapPtr pixPriv = XAA_GET_PIXMAP_PRIVATE(devRet->pPix);
+        FBAreaPtr area;
+
+        if ((area = malloc(sizeof(FBArea)))) {
+            area->pScreen = pScreen;
+            area->box.x1 = 0;
+            area->box.x2 = 0;
+            area->box.y1 = devRet->mode->pixmapWidth;
+            area->box.y2 = devRet->mode->pixmapHeight;
+            area->granularity = 0;
+            area->MoveAreaCallback = 0;
+            area->RemoveAreaCallback = 0;
+            area->devPrivate.ptr = 0;
+
+            pixPriv->flags |= OFFSCREEN | DGA_PIXMAP;
+            pixPriv->offscreenArea = area;
+
+            if (!infoRec->dgaSaves) {   /* save pixmap cache state */
+                SavedCacheStatePtr state = malloc(sizeof(SavedCacheState));
+
+                state->UsingPixmapCache = infoRec->UsingPixmapCache;
+                state->CanDoColor8x8 = infoRec->CanDoColor8x8;
+                state->CanDoMono8x8 = infoRec->CanDoMono8x8;
+                infoRec->dgaSaves = (char *) state;
+
+                infoRec->UsingPixmapCache = FALSE;
+                if (infoRec->PixmapCacheFlags & CACHE_MONO_8x8)
+                    infoRec->CanDoMono8x8 = FALSE;
+                if (infoRec->PixmapCacheFlags & CACHE_COLOR_8x8)
+                    infoRec->CanDoColor8x8 = FALSE;
+            }
+        }
+    }
+
+    return ret;
+}
+
+static void
+XAAEnableDisableFBAccess(ScrnInfoPtr pScrn, Bool enable)
+{
+    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
+    XAAScreenPtr pScreenPriv =
+        (XAAScreenPtr) dixLookupPrivate(&pScreen->devPrivates, XAAScreenKey);
+
+    if (!enable) {
+        if ((infoRec->Flags & OFFSCREEN_PIXMAPS) && (infoRec->OffscreenPixmaps))
+            XAAMoveOutOffscreenPixmaps(pScreen);
+        if (infoRec->Flags & PIXMAP_CACHE)
+            XAAInvalidatePixmapCache(pScreen);
+        SwitchedOut = TRUE;
+    }
+
+    (*pScreenPriv->EnableDisableFBAccess) (pScrn, enable);
+
+    if (enable) {
+        if ((infoRec->Flags & OFFSCREEN_PIXMAPS) && (infoRec->OffscreenPixmaps))
+            XAAMoveInOffscreenPixmaps(pScreen);
+        SwitchedOut = FALSE;
+    }
+}
diff --git a/hw/xfree86/xaa/xaaInitAccel.c b/hw/xfree86/xaa/xaaInitAccel.c
new file mode 100644
index 000000000..a36e0b71b
--- /dev/null
+++ b/hw/xfree86/xaa/xaaInitAccel.c
@@ -0,0 +1,1571 @@
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <string.h>
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include "xf86str.h"
+#include "xaa.h"
+#include "xaalocal.h"
+#include "xf86fbman.h"
+#include "servermd.h"
+
+/*
+ * XAA Config options
+ */
+
+typedef enum {
+    XAAOPT_SCREEN_TO_SCREEN_COPY,
+    XAAOPT_SOLID_FILL_RECT,
+    XAAOPT_SOLID_FILL_TRAP,
+    XAAOPT_SOLID_TWO_POINT_LINE,
+    XAAOPT_SOLID_BRESENHAM_LINE,
+    XAAOPT_SOLID_HORVERT_LINE,
+    XAAOPT_DASHED_TWO_POINT_LINE,
+    XAAOPT_DASHED_BRESENHAM_LINE,
+    XAAOPT_MONO_8x8_PATTERN_FILL_RECT,
+    XAAOPT_MONO_8x8_PATTERN_FILL_TRAP,
+    XAAOPT_COL_8x8_PATTERN_FILL_RECT,
+    XAAOPT_COL_8x8_PATTERN_FILL_TRAP,
+    XAAOPT_CPU_TO_SCREEN_COL_EXP_FILL,
+    XAAOPT_SCANLINE_CPU_TO_SCREEN_COL_EXP_FILL,
+    XAAOPT_SCREEN_TO_SCREEN_COL_EXP_FILL,
+    XAAOPT_IMAGE_WRITE_RECT,
+    XAAOPT_SCANLINE_IMAGE_WRITE_RECT,
+    XAAOPT_WRITE_BITMAP,
+    XAAOPT_WRITE_PIXMAP,
+    XAAOPT_PIXMAP_CACHE,
+    XAAOPT_OFFSCREEN_PIXMAPS,
+    XAAOPT_HAS_DUMB_INVERTED_OPTION_SENSE
+} XAAOpts;
+
+static const OptionInfoRec XAAOptions[] = {
+    {XAAOPT_SCREEN_TO_SCREEN_COPY, "XaaNoScreenToScreenCopy",
+     OPTV_BOOLEAN, {0}, FALSE},
+    {XAAOPT_SOLID_FILL_RECT, "XaaNoSolidFillRect",
+     OPTV_BOOLEAN, {0}, FALSE},
+    {XAAOPT_SOLID_FILL_TRAP, "XaaNoSolidFillTrap",
+     OPTV_BOOLEAN, {0}, FALSE},
+    {XAAOPT_SOLID_TWO_POINT_LINE, "XaaNoSolidTwoPointLine",
+     OPTV_BOOLEAN, {0}, FALSE},
+    {XAAOPT_SOLID_BRESENHAM_LINE, "XaaNoSolidBresenhamLine",
+     OPTV_BOOLEAN, {0}, FALSE},
+    {XAAOPT_SOLID_HORVERT_LINE, "XaaNoSolidHorVertLine",
+     OPTV_BOOLEAN, {0}, FALSE},
+    {XAAOPT_DASHED_TWO_POINT_LINE, "XaaNoDashedTwoPointLine",
+     OPTV_BOOLEAN, {0}, FALSE},
+    {XAAOPT_DASHED_BRESENHAM_LINE, "XaaNoDashedBresenhamLine",
+     OPTV_BOOLEAN, {0}, FALSE},
+    {XAAOPT_MONO_8x8_PATTERN_FILL_RECT, "XaaNoMono8x8PatternFillRect",
+     OPTV_BOOLEAN, {0}, FALSE},
+    {XAAOPT_MONO_8x8_PATTERN_FILL_TRAP, "XaaNoMono8x8PatternFillTrap",
+     OPTV_BOOLEAN, {0}, FALSE},
+    {XAAOPT_COL_8x8_PATTERN_FILL_RECT, "XaaNoColor8x8PatternFillRect",
+     OPTV_BOOLEAN, {0}, FALSE},
+    {XAAOPT_COL_8x8_PATTERN_FILL_TRAP, "XaaNoColor8x8PatternFillTrap",
+     OPTV_BOOLEAN, {0}, FALSE},
+    {XAAOPT_CPU_TO_SCREEN_COL_EXP_FILL, "XaaNoCPUToScreenColorExpandFill",
+     OPTV_BOOLEAN, {0}, FALSE},
+    {XAAOPT_SCANLINE_CPU_TO_SCREEN_COL_EXP_FILL,
+     "XaaNoScanlineCPUToScreenColorExpandFill",
+     OPTV_BOOLEAN, {0}, FALSE},
+    {XAAOPT_SCREEN_TO_SCREEN_COL_EXP_FILL, "XaaNoScreenToScreenColorExpandFill",
+     OPTV_BOOLEAN, {0}, FALSE},
+    {XAAOPT_IMAGE_WRITE_RECT, "XaaNoImageWriteRect",
+     OPTV_BOOLEAN, {0}, FALSE},
+    {XAAOPT_SCANLINE_IMAGE_WRITE_RECT, "XaaNoScanlineImageWriteRect",
+     OPTV_BOOLEAN, {0}, FALSE},
+    {XAAOPT_WRITE_BITMAP, "XaaNoWriteBitmap",
+     OPTV_BOOLEAN, {0}, FALSE},
+    {XAAOPT_WRITE_PIXMAP, "XaaNoWritePixmap",
+     OPTV_BOOLEAN, {0}, FALSE},
+    {XAAOPT_PIXMAP_CACHE, "XaaNoPixmapCache",
+     OPTV_BOOLEAN, {0}, FALSE},
+    {XAAOPT_OFFSCREEN_PIXMAPS, "XaaNoOffscreenPixmaps",
+     OPTV_BOOLEAN, {0}, FALSE},
+    {XAAOPT_HAS_DUMB_INVERTED_OPTION_SENSE, "XaaOffscreenPixmaps",
+     OPTV_BOOLEAN, {0}, FALSE},
+    {-1, NULL,
+     OPTV_NONE, {0}, FALSE}
+};
+
+static XF86ModuleVersionInfo xaaVersRec = {
+    "xaa",
+    MODULEVENDORSTRING,
+    MODINFOSTRING1,
+    MODINFOSTRING2,
+    XORG_VERSION_CURRENT,
+    XAA_VERSION_MAJOR,
+    XAA_VERSION_MINOR,
+    XAA_VERSION_RELEASE,
+    ABI_CLASS_VIDEODRV,         /* requires the video driver ABI */
+    ABI_VIDEODRV_VERSION,
+    MOD_CLASS_NONE,
+    {0, 0, 0, 0}
+};
+
+_X_EXPORT XF86ModuleData xaaModuleData = { &xaaVersRec, NULL, NULL };
+
+Bool
+XAAInitAccel(ScreenPtr pScreen, XAAInfoRecPtr infoRec)
+{
+    int index = pScreen->myNum;
+    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
+    Bool HaveScreenToScreenCopy = FALSE;
+    Bool HaveColorExpansion = FALSE;
+    Bool HaveScanlineColorExpansion = FALSE;
+    Bool HaveSolidFillRect = FALSE;
+    Bool HaveMono8x8PatternFillRect = FALSE;
+    Bool HaveColor8x8PatternFillRect = FALSE;
+    Bool HaveSolidFillTrap = FALSE;
+    Bool HaveMono8x8PatternFillTrap = FALSE;
+    Bool HaveColor8x8PatternFillTrap = FALSE;
+    Bool HaveSolidTwoPointLine = FALSE;
+    Bool HaveSolidBresenhamLine = FALSE;
+    Bool HaveSolidHorVertLine = FALSE;
+    Bool HaveDashedTwoPointLine = FALSE;
+    Bool HaveDashedBresenhamLine = FALSE;
+    Bool HaveImageWriteRect = FALSE;
+    Bool HaveScanlineImageWriteRect = FALSE;
+    Bool HaveScreenToScreenColorExpandFill = FALSE;
+    OptionInfoPtr options;
+    int is_shared = 0;
+    int i;
+
+    options = xnfalloc(sizeof(XAAOptions));
+    (void) memcpy(options, XAAOptions, sizeof(XAAOptions));
+    xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, options);
+
+    infoRec->pScrn = pScrn;
+    infoRec->NeedToSync = FALSE;
+
+    /* must have a Sync function */
+    if (!infoRec->Sync)
+        return FALSE;
+    for (i = 0; i < pScrn->numEntities; i++) {
+        if (xf86IsEntityShared(pScrn->entityList[i]))
+            is_shared = 1;
+    }
+
+    /* If this PCI entity has IS_SHARED_ACCEL set in entityProp
+     * then a RestoreAccelState function is required
+     */
+    if (!infoRec->RestoreAccelState && is_shared)
+        return FALSE;
+
+    if (infoRec->RestoreAccelState) {
+        if (!XAAInitStateWrap(pScreen, infoRec))
+            return FALSE;
+    }
+
+    if (serverGeneration == 1)
+        xf86DrvMsg(index, X_INFO,
+                   "Using XFree86 Acceleration Architecture (XAA)\n");
+
+    /************** Low Level *************/
+
+    if (!infoRec->SetClippingRectangle || !infoRec->DisableClipping) {
+        infoRec->ClippingFlags = 0;
+        infoRec->SetClippingRectangle = NULL;
+        infoRec->DisableClipping = NULL;
+    }
+
+    /**** CopyArea ****/
+
+    if (infoRec->SetupForScreenToScreenCopy &&
+        infoRec->SubsequentScreenToScreenCopy &&
+        !xf86ReturnOptValBool(options, XAAOPT_SCREEN_TO_SCREEN_COPY, FALSE)) {
+        HaveScreenToScreenCopy = TRUE;
+    }
+    else {
+        infoRec->ScreenToScreenCopyFlags = 0;
+        infoRec->SetupForScreenToScreenCopy = NULL;
+        infoRec->SubsequentScreenToScreenCopy = NULL;
+    }
+
+    /**** Solid Filled Rects ****/
+
+    if (infoRec->SetupForSolidFill && infoRec->SubsequentSolidFillRect &&
+        !xf86ReturnOptValBool(options, XAAOPT_SOLID_FILL_RECT, FALSE)) {
+        HaveSolidFillRect = TRUE;
+        if (infoRec->SubsequentSolidFillTrap &&
+            !xf86ReturnOptValBool(options, XAAOPT_SOLID_FILL_TRAP, FALSE))
+            HaveSolidFillTrap = TRUE;
+        else
+            infoRec->SubsequentSolidFillTrap = NULL;
+    }
+    else {
+        infoRec->SolidFillFlags = 0;
+        infoRec->SetupForSolidFill = NULL;
+        infoRec->SubsequentSolidFillRect = NULL;
+        infoRec->SubsequentSolidFillTrap = NULL;
+    }
+
+    /**** Solid lines ****/
+
+    if (infoRec->SetupForSolidLine) {
+        if (infoRec->SubsequentSolidTwoPointLine &&
+            !xf86ReturnOptValBool(options, XAAOPT_SOLID_TWO_POINT_LINE, FALSE))
+            HaveSolidTwoPointLine = TRUE;
+        if (infoRec->SubsequentSolidBresenhamLine &&
+            !xf86ReturnOptValBool(options, XAAOPT_SOLID_BRESENHAM_LINE,
+                                  FALSE)) {
+            HaveSolidBresenhamLine = TRUE;
+
+            if (infoRec->SolidBresenhamLineErrorTermBits)
+                infoRec->SolidBresenhamLineErrorTermBits =
+                    ~((1 << infoRec->SolidBresenhamLineErrorTermBits) - 1);
+        }
+
+        if (infoRec->SubsequentSolidHorVertLine &&
+            !xf86ReturnOptValBool(options, XAAOPT_SOLID_HORVERT_LINE, FALSE))
+            HaveSolidHorVertLine = TRUE;
+        else if (HaveSolidTwoPointLine) {
+            infoRec->SubsequentSolidHorVertLine = XAASolidHorVertLineAsTwoPoint;
+            HaveSolidHorVertLine = TRUE;
+        }
+        else if (HaveSolidBresenhamLine) {
+            infoRec->SubsequentSolidHorVertLine =
+                XAASolidHorVertLineAsBresenham;
+            HaveSolidHorVertLine = TRUE;
+        }
+    }
+
+    /* XXX Should this also check for XAAOPT_SOLID_HORVERT_LINE? */
+    if (!HaveSolidTwoPointLine &&
+        !HaveSolidBresenhamLine && !HaveSolidHorVertLine && HaveSolidFillRect) {
+        infoRec->SetupForSolidLine = infoRec->SetupForSolidFill;
+        infoRec->SubsequentSolidHorVertLine = XAASolidHorVertLineAsRects;
+        infoRec->SolidLineFlags = infoRec->SolidFillFlags;
+        HaveSolidHorVertLine = TRUE;
+    }
+
+    if (!HaveSolidTwoPointLine)
+        infoRec->SubsequentSolidTwoPointLine = NULL;
+    if (!HaveSolidBresenhamLine)
+        infoRec->SubsequentSolidBresenhamLine = NULL;
+    if (!HaveSolidHorVertLine)
+        infoRec->SubsequentSolidHorVertLine = NULL;
+
+    /* Disable all if nothing left over */
+    if (!HaveSolidTwoPointLine &&
+        !HaveSolidBresenhamLine && !HaveSolidHorVertLine) {
+        infoRec->SolidLineFlags = 0;
+        infoRec->SetupForSolidLine = NULL;
+    }
+
+    /**** 8x8 Mono Pattern Filled Rects ****/
+
+    if (infoRec->SetupForMono8x8PatternFill &&
+        infoRec->SubsequentMono8x8PatternFillRect &&
+        !xf86ReturnOptValBool(options,
+                              XAAOPT_MONO_8x8_PATTERN_FILL_RECT, FALSE)) {
+        HaveMono8x8PatternFillRect = TRUE;
+        if (infoRec->SubsequentMono8x8PatternFillTrap &&
+            !xf86ReturnOptValBool(options,
+                                  XAAOPT_MONO_8x8_PATTERN_FILL_TRAP, FALSE))
+            HaveMono8x8PatternFillTrap = TRUE;
+
+        if (infoRec->Mono8x8PatternFillFlags & HARDWARE_PATTERN_PROGRAMMED_BITS) {
+            infoRec->CanDoMono8x8 = TRUE;
+        }
+        else {                  /* others require caching */
+            int min_pitch;
+
+            infoRec->PixmapCacheFlags |= CACHE_MONO_8x8;
+
+            switch (pScrn->bitsPerPixel) {
+            case 32:
+                min_pitch = 2;
+                break;
+            case 24:
+                min_pitch = 3;
+                break;
+            case 16:
+                min_pitch = 4;
+                break;
+            default:
+                min_pitch = 8;
+                break;
+            }
+
+            if (min_pitch > infoRec->MonoPatternPitch)
+                infoRec->MonoPatternPitch = min_pitch;
+
+            if (infoRec->Mono8x8PatternFillFlags &
+                HARDWARE_PATTERN_PROGRAMMED_ORIGIN) {
+                if (!infoRec->CacheWidthMono8x8Pattern ||
+                    !infoRec->CacheHeightMono8x8Pattern) {
+                    infoRec->CacheWidthMono8x8Pattern =
+                        infoRec->MonoPatternPitch;
+                    infoRec->CacheHeightMono8x8Pattern = 1;
+                }
+            }
+            else {
+                int numPerLine = 128 / infoRec->MonoPatternPitch;
+
+                if (!infoRec->CacheWidthMono8x8Pattern ||
+                    !infoRec->CacheHeightMono8x8Pattern) {
+                    infoRec->CacheWidthMono8x8Pattern =
+                        numPerLine * infoRec->MonoPatternPitch;
+                    infoRec->CacheHeightMono8x8Pattern =
+                        (64 + numPerLine - 1) / numPerLine;
+                }
+            }
+        }
+    }
+    else {
+        infoRec->Mono8x8PatternFillFlags = 0;
+        infoRec->SetupForMono8x8PatternFill = NULL;
+        infoRec->SubsequentMono8x8PatternFillRect = NULL;
+    }
+
+    /**** Dashed lines ****/
+
+    if (infoRec->SetupForDashedLine && infoRec->DashPatternMaxLength) {
+        if (infoRec->SubsequentDashedTwoPointLine &&
+            !xf86ReturnOptValBool(options, XAAOPT_DASHED_TWO_POINT_LINE, FALSE))
+            HaveDashedTwoPointLine = TRUE;
+        if (infoRec->SubsequentDashedBresenhamLine &&
+            !xf86ReturnOptValBool(options, XAAOPT_DASHED_BRESENHAM_LINE,
+                                  FALSE)) {
+            HaveDashedBresenhamLine = TRUE;
+
+            if (infoRec->DashedBresenhamLineErrorTermBits)
+                infoRec->DashedBresenhamLineErrorTermBits =
+                    ~((1 << infoRec->DashedBresenhamLineErrorTermBits) - 1);
+        }
+    }
+
+    if (!HaveDashedTwoPointLine)
+        infoRec->SubsequentDashedTwoPointLine = NULL;
+    if (!HaveDashedBresenhamLine)
+        infoRec->SubsequentDashedBresenhamLine = NULL;
+
+    /* Disable all if nothing left over */
+    if (!HaveDashedTwoPointLine && !HaveDashedBresenhamLine) {
+        infoRec->DashedLineFlags = 0;
+        infoRec->SetupForDashedLine = NULL;
+    }
+
+    /**** 8x8 Color Pattern Filled Rects ****/
+
+    if (infoRec->SetupForColor8x8PatternFill &&
+        infoRec->SubsequentColor8x8PatternFillRect &&
+        !xf86ReturnOptValBool(options, XAAOPT_COL_8x8_PATTERN_FILL_RECT,
+                              FALSE)) {
+        HaveColor8x8PatternFillRect = TRUE;
+        if (infoRec->SubsequentColor8x8PatternFillTrap &&
+            !xf86ReturnOptValBool(options, XAAOPT_COL_8x8_PATTERN_FILL_TRAP,
+                                  FALSE))
+            HaveColor8x8PatternFillTrap = TRUE;
+        else
+            infoRec->SubsequentColor8x8PatternFillTrap = NULL;
+
+        infoRec->PixmapCacheFlags |= CACHE_COLOR_8x8;
+
+        if (infoRec->Color8x8PatternFillFlags &
+            HARDWARE_PATTERN_PROGRAMMED_ORIGIN) {
+            if (!infoRec->CacheWidthColor8x8Pattern ||
+                !infoRec->CacheHeightColor8x8Pattern) {
+                infoRec->CacheWidthColor8x8Pattern = 64;
+                infoRec->CacheHeightColor8x8Pattern = 1;
+            }
+        }
+        else {
+            if (!infoRec->CacheWidthColor8x8Pattern ||
+                !infoRec->CacheHeightColor8x8Pattern) {
+                infoRec->CacheWidthColor8x8Pattern = 128;
+                infoRec->CacheHeightColor8x8Pattern = 8;
+            }
+        }
+    }
+    else {
+        infoRec->Color8x8PatternFillFlags = 0;
+        infoRec->SetupForColor8x8PatternFill = NULL;
+        infoRec->SubsequentColor8x8PatternFillRect = NULL;
+        infoRec->SubsequentColor8x8PatternFillTrap = NULL;
+    }
+
+    /**** Color Expansion ****/
+
+    if (infoRec->SetupForCPUToScreenColorExpandFill &&
+        infoRec->ColorExpandBase &&
+        infoRec->SubsequentCPUToScreenColorExpandFill &&
+        !xf86ReturnOptValBool(options, XAAOPT_CPU_TO_SCREEN_COL_EXP_FILL,
+                              FALSE)) {
+        int dwordsNeeded = pScrn->virtualX;
+
+        infoRec->ColorExpandRange >>= 2;        /* convert to DWORDS */
+        HaveColorExpansion = TRUE;
+
+        if (infoRec->CPUToScreenColorExpandFillFlags &
+            LEFT_EDGE_CLIPPING_NEGATIVE_X)
+            dwordsNeeded += 31;
+        dwordsNeeded = (dwordsNeeded + 31) >> 5;
+        if (dwordsNeeded > infoRec->ColorExpandRange)
+            infoRec->CPUToScreenColorExpandFillFlags |= CPU_TRANSFER_BASE_FIXED;
+    }
+    else {
+        infoRec->CPUToScreenColorExpandFillFlags = 0;
+        infoRec->SetupForCPUToScreenColorExpandFill = NULL;
+        infoRec->SubsequentCPUToScreenColorExpandFill = NULL;
+    }
+
+    /**** Scanline Color Expansion ****/
+
+    if (infoRec->SetupForScanlineCPUToScreenColorExpandFill &&
+        infoRec->SubsequentScanlineCPUToScreenColorExpandFill &&
+        infoRec->SubsequentColorExpandScanline &&
+        infoRec->ScanlineColorExpandBuffers &&
+        (infoRec->NumScanlineColorExpandBuffers > 0) &&
+        !xf86ReturnOptValBool(options,
+                              XAAOPT_SCANLINE_CPU_TO_SCREEN_COL_EXP_FILL,
+                              FALSE)) {
+        HaveScanlineColorExpansion = TRUE;
+    }
+    else {
+        infoRec->ScanlineCPUToScreenColorExpandFillFlags = 0;
+        infoRec->SetupForScanlineCPUToScreenColorExpandFill = NULL;
+        infoRec->SubsequentScanlineCPUToScreenColorExpandFill = NULL;
+        infoRec->SubsequentColorExpandScanline = NULL;
+    }
+
+    /**** Screen to Screen Color Expansion ****/
+
+    if (infoRec->SetupForScreenToScreenColorExpandFill &&
+        infoRec->SubsequentScreenToScreenColorExpandFill &&
+        !xf86ReturnOptValBool(options, XAAOPT_SCREEN_TO_SCREEN_COL_EXP_FILL,
+                              FALSE)) {
+        HaveScreenToScreenColorExpandFill = TRUE;
+        if (!infoRec->CacheColorExpandDensity)
+            infoRec->CacheColorExpandDensity = 1;
+    }
+    else {
+        infoRec->ScreenToScreenColorExpandFillFlags = 0;
+        infoRec->SetupForScreenToScreenColorExpandFill = NULL;
+        infoRec->SubsequentScreenToScreenColorExpandFill = NULL;
+    }
+
+    /**** Image Writes ****/
+
+    if (infoRec->SetupForImageWrite && infoRec->ImageWriteBase &&
+        infoRec->SubsequentImageWriteRect &&
+        !xf86ReturnOptValBool(options, XAAOPT_IMAGE_WRITE_RECT, FALSE)) {
+
+        infoRec->ImageWriteRange >>= 2; /* convert to DWORDS */
+        if (infoRec->ImageWriteFlags & CPU_TRANSFER_BASE_FIXED)
+            infoRec->ImageWriteRange = 0;
+        HaveImageWriteRect = TRUE;
+    }
+    else {
+        infoRec->ImageWriteFlags = 0;
+        infoRec->SetupForImageWrite = NULL;
+        infoRec->SubsequentImageWriteRect = NULL;
+    }
+
+    /**** Scanline Image Writes ****/
+
+    if (infoRec->SetupForScanlineImageWrite &&
+        infoRec->SubsequentScanlineImageWriteRect &&
+        infoRec->SubsequentImageWriteScanline &&
+        infoRec->ScanlineImageWriteBuffers &&
+        (infoRec->NumScanlineImageWriteBuffers > 0) &&
+        !xf86ReturnOptValBool(options, XAAOPT_SCANLINE_IMAGE_WRITE_RECT,
+                              FALSE)) {
+        HaveScanlineImageWriteRect = TRUE;
+    }
+    else {
+        infoRec->ScanlineImageWriteFlags = 0;
+        infoRec->SetupForScanlineImageWrite = NULL;
+        infoRec->SubsequentScanlineImageWriteRect = NULL;
+        infoRec->SubsequentImageWriteScanline = NULL;
+    }
+
+#ifndef __i386__
+    /* XAA makes some unaligned accesses when clipping is not available */
+#define CLIP_FLAGS (LEFT_EDGE_CLIPPING | LEFT_EDGE_CLIPPING_NEGATIVE_X)
+    if (HaveImageWriteRect &&
+        ((infoRec->ImageWriteFlags & CLIP_FLAGS) != CLIP_FLAGS)) {
+        HaveImageWriteRect = FALSE;
+    }
+    if (HaveScanlineImageWriteRect &&
+        ((infoRec->ScanlineImageWriteFlags & CLIP_FLAGS) != CLIP_FLAGS)) {
+        HaveScanlineImageWriteRect = FALSE;
+    }
+#endif
+
+    if (serverGeneration == 1) {
+        if (HaveScreenToScreenCopy)
+            xf86ErrorF("\tScreen to screen bit blits\n");
+        if (HaveSolidFillRect)
+            xf86ErrorF("\tSolid filled rectangles\n");
+        if (HaveSolidFillTrap)
+            xf86ErrorF("\tSolid filled trapezoids\n");
+        if (HaveMono8x8PatternFillRect)
+            xf86ErrorF("\t8x8 mono pattern filled rectangles\n");
+        if (HaveMono8x8PatternFillTrap)
+            xf86ErrorF("\t8x8 mono pattern filled trapezoids\n");
+        if (HaveColor8x8PatternFillRect)
+            xf86ErrorF("\t8x8 color pattern filled rectangles\n");
+        if (HaveColor8x8PatternFillTrap)
+            xf86ErrorF("\t8x8 color pattern filled trapezoids\n");
+
+        if (HaveColorExpansion)
+            xf86ErrorF("\tCPU to Screen color expansion\n");
+        else if (HaveScanlineColorExpansion)
+            xf86ErrorF("\tIndirect CPU to Screen color expansion\n");
+
+        if (HaveScreenToScreenColorExpandFill)
+            xf86ErrorF("\tScreen to Screen color expansion\n");
+
+        if (HaveSolidTwoPointLine || HaveSolidBresenhamLine)
+            xf86ErrorF("\tSolid Lines\n");
+        else if (HaveSolidHorVertLine)
+            xf86ErrorF("\tSolid Horizontal and Vertical Lines\n");
+
+        if (HaveDashedTwoPointLine || HaveDashedBresenhamLine)
+            xf86ErrorF("\tDashed Lines\n");
+
+        if (HaveImageWriteRect)
+            xf86ErrorF("\tImage Writes\n");
+        else if (HaveScanlineImageWriteRect)
+            xf86ErrorF("\tScanline Image Writes\n");
+
+    }
+
+#define XAAMSG(s) do { if (serverGeneration == 1) xf86ErrorF(s); } while (0)
+
+    if ((infoRec->Flags & OFFSCREEN_PIXMAPS) && HaveScreenToScreenCopy &&
+        xf86ReturnOptValBool(options,
+                             XAAOPT_HAS_DUMB_INVERTED_OPTION_SENSE, FALSE)) {
+        XAAMSG("\tOffscreen Pixmaps\n");
+    }
+    else {
+        infoRec->Flags &= ~OFFSCREEN_PIXMAPS;
+    }
+
+    /************** Mid Level *************/
+
+    /**** ScreenToScreenBitBlt ****/
+
+    if (infoRec->ScreenToScreenBitBlt) {
+        XAAMSG("\tDriver provided ScreenToScreenBitBlt replacement\n");
+    }
+    else if (HaveScreenToScreenCopy) {
+        infoRec->ScreenToScreenBitBlt = XAAScreenToScreenBitBlt;
+        infoRec->ScreenToScreenBitBltFlags = infoRec->ScreenToScreenCopyFlags;
+    }
+
+    /**** FillSolidRects ****/
+
+    if (infoRec->FillSolidRects) {
+        XAAMSG("\tDriver provided FillSolidRects replacement\n");
+    }
+    else if (HaveSolidFillRect) {
+        infoRec->FillSolidRects = XAAFillSolidRects;
+        infoRec->FillSolidRectsFlags = infoRec->SolidFillFlags;
+    }
+
+    /**** FillSolidSpans ****/
+
+    if (infoRec->FillSolidSpans) {
+        XAAMSG("\tDriver provided FillSolidSpans replacement\n");
+    }
+    else if (HaveSolidFillRect) {
+        infoRec->FillSolidSpans = XAAFillSolidSpans;
+        infoRec->FillSolidSpansFlags = infoRec->SolidFillFlags;
+    }
+
+    /**** FillMono8x8PatternRects ****/
+
+    if (infoRec->FillMono8x8PatternRects) {
+        XAAMSG("\tDriver provided FillMono8x8PatternRects replacement\n");
+    }
+    else if (HaveMono8x8PatternFillRect) {
+        infoRec->FillMono8x8PatternRects =
+            (infoRec->
+             Mono8x8PatternFillFlags & HARDWARE_PATTERN_SCREEN_ORIGIN) ?
+            XAAFillMono8x8PatternRectsScreenOrigin : XAAFillMono8x8PatternRects;
+
+        infoRec->FillMono8x8PatternRectsFlags =
+            infoRec->Mono8x8PatternFillFlags;
+    }
+
+    /**** FillMono8x8PatternSpans ****/
+
+    if (infoRec->FillMono8x8PatternSpans) {
+        XAAMSG("\tDriver provided FillMono8x8PatternSpans replacement\n");
+    }
+    else if (HaveMono8x8PatternFillRect) {
+        infoRec->FillMono8x8PatternSpans =
+            (infoRec->
+             Mono8x8PatternFillFlags & HARDWARE_PATTERN_SCREEN_ORIGIN) ?
+            XAAFillMono8x8PatternSpansScreenOrigin : XAAFillMono8x8PatternSpans;
+
+        infoRec->FillMono8x8PatternSpansFlags =
+            infoRec->Mono8x8PatternFillFlags;
+    }
+
+    /**** FillColor8x8Rects ****/
+
+    if (infoRec->FillColor8x8PatternRects) {
+        XAAMSG("\tDriver provided FillColor8x8PatternRects replacement\n");
+    }
+    else if (HaveColor8x8PatternFillRect) {
+        infoRec->FillColor8x8PatternRects =
+            (infoRec->
+             Color8x8PatternFillFlags & HARDWARE_PATTERN_SCREEN_ORIGIN) ?
+            XAAFillColor8x8PatternRectsScreenOrigin :
+            XAAFillColor8x8PatternRects;
+
+        infoRec->FillColor8x8PatternRectsFlags =
+            infoRec->Color8x8PatternFillFlags;
+    }
+
+    /**** FillColor8x8Spans ****/
+
+    if (infoRec->FillColor8x8PatternSpans) {
+        XAAMSG("\tDriver provided FillColor8x8PatternSpans replacement\n");
+    }
+    else if (HaveColor8x8PatternFillRect) {
+        infoRec->FillColor8x8PatternSpans =
+            (infoRec->
+             Color8x8PatternFillFlags & HARDWARE_PATTERN_SCREEN_ORIGIN) ?
+            XAAFillColor8x8PatternSpansScreenOrigin :
+            XAAFillColor8x8PatternSpans;
+
+        infoRec->FillColor8x8PatternSpansFlags =
+            infoRec->Color8x8PatternFillFlags;
+    }
+
+    /**** FillCacheBltRects ****/
+
+    if (infoRec->FillCacheBltRects) {
+        XAAMSG("\tDriver provided FillCacheBltRects replacement\n");
+    }
+    else if (HaveScreenToScreenCopy) {
+        infoRec->FillCacheBltRects = XAAFillCacheBltRects;
+        infoRec->FillCacheBltRectsFlags = infoRec->ScreenToScreenCopyFlags;
+    }
+
+    /**** FillCacheBltSpans ****/
+
+    if (infoRec->FillCacheBltSpans) {
+        XAAMSG("\tDriver provided FillCacheBltSpans replacement\n");
+    }
+    else if (HaveScreenToScreenCopy) {
+        infoRec->FillCacheBltSpans = XAAFillCacheBltSpans;
+        infoRec->FillCacheBltSpansFlags = infoRec->ScreenToScreenCopyFlags;
+    }
+
+    /**** FillCacheExpandRects ****/
+
+    if (infoRec->FillCacheExpandRects) {
+        XAAMSG("\tDriver provided FillCacheExpandRects replacement\n");
+    }
+    else if (HaveScreenToScreenColorExpandFill) {
+        infoRec->FillCacheExpandRects = XAAFillCacheExpandRects;
+        infoRec->FillCacheExpandRectsFlags =
+            infoRec->ScreenToScreenColorExpandFillFlags;
+    }
+
+    /**** FillCacheExpandSpans ****/
+
+    if (infoRec->FillCacheExpandSpans) {
+        XAAMSG("\tDriver provided FillCacheExpandSpans replacement\n");
+    }
+    else if (HaveScreenToScreenColorExpandFill) {
+        infoRec->FillCacheExpandSpans = XAAFillCacheExpandSpans;
+        infoRec->FillCacheExpandSpansFlags =
+            infoRec->ScreenToScreenColorExpandFillFlags;
+    }
+
+    /**** FillColorExpandRects ****/
+
+    if (infoRec->FillColorExpandRects) {
+        XAAMSG("\tDriver provided FillColorExpandRects replacement\n");
+    }
+    else if (HaveColorExpansion) {
+        if (infoRec->CPUToScreenColorExpandFillFlags & TRIPLE_BITS_24BPP) {
+            if (infoRec->CPUToScreenColorExpandFillFlags &
+                BIT_ORDER_IN_BYTE_MSBFIRST) {
+                if (infoRec->CPUToScreenColorExpandFillFlags &
+                    CPU_TRANSFER_BASE_FIXED)
+                    infoRec->FillColorExpandRects =
+                        XAAFillColorExpandRects3MSBFirstFixedBase;
+                else
+                    infoRec->FillColorExpandRects =
+                        XAAFillColorExpandRects3MSBFirst;
+            }
+            else {
+                if (infoRec->CPUToScreenColorExpandFillFlags &
+                    CPU_TRANSFER_BASE_FIXED)
+                    infoRec->FillColorExpandRects =
+                        XAAFillColorExpandRects3LSBFirstFixedBase;
+                else
+                    infoRec->FillColorExpandRects =
+                        XAAFillColorExpandRects3LSBFirst;
+            }
+        }
+        else {
+            if (infoRec->CPUToScreenColorExpandFillFlags &
+                BIT_ORDER_IN_BYTE_MSBFIRST) {
+                if (infoRec->CPUToScreenColorExpandFillFlags &
+                    CPU_TRANSFER_BASE_FIXED)
+                    infoRec->FillColorExpandRects =
+                        XAAFillColorExpandRectsMSBFirstFixedBase;
+                else
+                    infoRec->FillColorExpandRects =
+                        XAAFillColorExpandRectsMSBFirst;
+            }
+            else {
+                if (infoRec->CPUToScreenColorExpandFillFlags &
+                    CPU_TRANSFER_BASE_FIXED)
+                    infoRec->FillColorExpandRects =
+                        XAAFillColorExpandRectsLSBFirstFixedBase;
+                else
+                    infoRec->FillColorExpandRects =
+                        XAAFillColorExpandRectsLSBFirst;
+            }
+        }
+        infoRec->FillColorExpandRectsFlags =
+            infoRec->CPUToScreenColorExpandFillFlags;
+    }
+    else if (HaveScanlineColorExpansion) {
+        if (infoRec->ScanlineCPUToScreenColorExpandFillFlags &
+            TRIPLE_BITS_24BPP) {
+            if (infoRec->ScanlineCPUToScreenColorExpandFillFlags &
+                BIT_ORDER_IN_BYTE_MSBFIRST)
+                infoRec->FillColorExpandRects =
+                    XAAFillScanlineColorExpandRects3MSBFirst;
+            else
+                infoRec->FillColorExpandRects =
+                    XAAFillScanlineColorExpandRects3LSBFirst;
+        }
+        else {
+            if (infoRec->ScanlineCPUToScreenColorExpandFillFlags &
+                BIT_ORDER_IN_BYTE_MSBFIRST)
+                infoRec->FillColorExpandRects =
+                    XAAFillScanlineColorExpandRectsMSBFirst;
+            else
+                infoRec->FillColorExpandRects =
+                    XAAFillScanlineColorExpandRectsLSBFirst;
+        }
+        infoRec->FillColorExpandRectsFlags =
+            infoRec->ScanlineCPUToScreenColorExpandFillFlags;
+    }
+
+    /**** FillColorExpandSpans ****/
+
+    if (infoRec->FillColorExpandSpans) {
+        XAAMSG("\tDriver provided FillColorExpandSpans replacement\n");
+    }
+    else if (HaveColorExpansion) {
+        if (infoRec->CPUToScreenColorExpandFillFlags & TRIPLE_BITS_24BPP) {
+            if (infoRec->CPUToScreenColorExpandFillFlags &
+                BIT_ORDER_IN_BYTE_MSBFIRST) {
+                if (infoRec->CPUToScreenColorExpandFillFlags &
+                    CPU_TRANSFER_BASE_FIXED)
+                    infoRec->FillColorExpandSpans =
+                        XAAFillColorExpandSpans3MSBFirstFixedBase;
+                else
+                    infoRec->FillColorExpandSpans =
+                        XAAFillColorExpandSpans3MSBFirst;
+            }
+            else {
+                if (infoRec->CPUToScreenColorExpandFillFlags &
+                    CPU_TRANSFER_BASE_FIXED)
+                    infoRec->FillColorExpandSpans =
+                        XAAFillColorExpandSpans3LSBFirstFixedBase;
+                else
+                    infoRec->FillColorExpandSpans =
+                        XAAFillColorExpandSpans3LSBFirst;
+            }
+        }
+        else {
+            if (infoRec->CPUToScreenColorExpandFillFlags &
+                BIT_ORDER_IN_BYTE_MSBFIRST) {
+                if (infoRec->CPUToScreenColorExpandFillFlags &
+                    CPU_TRANSFER_BASE_FIXED)
+                    infoRec->FillColorExpandSpans =
+                        XAAFillColorExpandSpansMSBFirstFixedBase;
+                else
+                    infoRec->FillColorExpandSpans =
+                        XAAFillColorExpandSpansMSBFirst;
+            }
+            else {
+                if (infoRec->CPUToScreenColorExpandFillFlags &
+                    CPU_TRANSFER_BASE_FIXED)
+                    infoRec->FillColorExpandSpans =
+                        XAAFillColorExpandSpansLSBFirstFixedBase;
+                else
+                    infoRec->FillColorExpandSpans =
+                        XAAFillColorExpandSpansLSBFirst;
+            }
+        }
+        infoRec->FillColorExpandSpansFlags =
+            infoRec->CPUToScreenColorExpandFillFlags;
+    }
+    else if (HaveScanlineColorExpansion) {
+        if (infoRec->ScanlineCPUToScreenColorExpandFillFlags &
+            TRIPLE_BITS_24BPP) {
+            if (infoRec->ScanlineCPUToScreenColorExpandFillFlags &
+                BIT_ORDER_IN_BYTE_MSBFIRST)
+                infoRec->FillColorExpandSpans =
+                    XAAFillScanlineColorExpandSpans3MSBFirst;
+            else
+                infoRec->FillColorExpandSpans =
+                    XAAFillScanlineColorExpandSpans3LSBFirst;
+        }
+        else {
+            if (infoRec->ScanlineCPUToScreenColorExpandFillFlags &
+                BIT_ORDER_IN_BYTE_MSBFIRST)
+                infoRec->FillColorExpandSpans =
+                    XAAFillScanlineColorExpandSpansMSBFirst;
+            else
+                infoRec->FillColorExpandSpans =
+                    XAAFillScanlineColorExpandSpansLSBFirst;
+        }
+        infoRec->FillColorExpandSpansFlags =
+            infoRec->ScanlineCPUToScreenColorExpandFillFlags;
+    }
+
+    /**** FillImageWriteRects ****/
+
+    if (infoRec->FillImageWriteRects) {
+        XAAMSG("\tDriver provided FillImageWriteRects replacement\n");
+    }
+    else if (HaveImageWriteRect &&
+             (infoRec->ImageWriteFlags & LEFT_EDGE_CLIPPING_NEGATIVE_X) &&
+             (infoRec->ImageWriteFlags & LEFT_EDGE_CLIPPING)) {
+        infoRec->FillImageWriteRects = XAAFillImageWriteRects;
+        infoRec->FillImageWriteRectsFlags = infoRec->ImageWriteFlags;
+    }
+
+    /**** WriteBitmap ****/
+
+    if (infoRec->WriteBitmap &&
+        !xf86ReturnOptValBool(options, XAAOPT_WRITE_BITMAP, FALSE)) {
+        XAAMSG("\tDriver provided WriteBitmap replacement\n");
+    }
+    else if (HaveColorExpansion) {
+        if (infoRec->CPUToScreenColorExpandFillFlags & TRIPLE_BITS_24BPP) {
+            if (infoRec->CPUToScreenColorExpandFillFlags &
+                BIT_ORDER_IN_BYTE_MSBFIRST) {
+                if (infoRec->CPUToScreenColorExpandFillFlags &
+                    CPU_TRANSFER_BASE_FIXED)
+                    infoRec->WriteBitmap =
+                        XAAWriteBitmapColorExpand3MSBFirstFixedBase;
+                else
+                    infoRec->WriteBitmap = XAAWriteBitmapColorExpand3MSBFirst;
+            }
+            else {
+                if (infoRec->CPUToScreenColorExpandFillFlags &
+                    CPU_TRANSFER_BASE_FIXED)
+                    infoRec->WriteBitmap =
+                        XAAWriteBitmapColorExpand3LSBFirstFixedBase;
+                else
+                    infoRec->WriteBitmap = XAAWriteBitmapColorExpand3LSBFirst;
+            }
+        }
+        else {
+            if (infoRec->CPUToScreenColorExpandFillFlags &
+                BIT_ORDER_IN_BYTE_MSBFIRST) {
+                if (infoRec->CPUToScreenColorExpandFillFlags &
+                    CPU_TRANSFER_BASE_FIXED)
+                    infoRec->WriteBitmap =
+                        XAAWriteBitmapColorExpandMSBFirstFixedBase;
+                else
+                    infoRec->WriteBitmap = XAAWriteBitmapColorExpandMSBFirst;
+            }
+            else {
+                if (infoRec->CPUToScreenColorExpandFillFlags &
+                    CPU_TRANSFER_BASE_FIXED)
+                    infoRec->WriteBitmap =
+                        XAAWriteBitmapColorExpandLSBFirstFixedBase;
+                else
+                    infoRec->WriteBitmap = XAAWriteBitmapColorExpandLSBFirst;
+            }
+        }
+        infoRec->WriteBitmapFlags = infoRec->CPUToScreenColorExpandFillFlags;
+    }
+    else if (HaveScanlineColorExpansion) {
+        if (infoRec->ScanlineCPUToScreenColorExpandFillFlags &
+            TRIPLE_BITS_24BPP) {
+            if (infoRec->ScanlineCPUToScreenColorExpandFillFlags &
+                BIT_ORDER_IN_BYTE_MSBFIRST)
+                infoRec->WriteBitmap =
+                    XAAWriteBitmapScanlineColorExpand3MSBFirst;
+            else
+                infoRec->WriteBitmap =
+                    XAAWriteBitmapScanlineColorExpand3LSBFirst;
+        }
+        else {
+            if (infoRec->ScanlineCPUToScreenColorExpandFillFlags &
+                BIT_ORDER_IN_BYTE_MSBFIRST)
+                infoRec->WriteBitmap =
+                    XAAWriteBitmapScanlineColorExpandMSBFirst;
+            else
+                infoRec->WriteBitmap =
+                    XAAWriteBitmapScanlineColorExpandLSBFirst;
+        }
+        infoRec->WriteBitmapFlags =
+            infoRec->ScanlineCPUToScreenColorExpandFillFlags;
+    }
+    else
+        infoRec->WriteBitmap = NULL;
+
+    /**** TE Glyphs ****/
+
+    if (infoRec->TEGlyphRenderer) {
+        XAAMSG("\tDriver provided TEGlyphRenderer replacement\n");
+    }
+    else if (HaveColorExpansion) {
+        infoRec->TEGlyphRendererFlags =
+            infoRec->CPUToScreenColorExpandFillFlags;
+
+        if (infoRec->TEGlyphRendererFlags & TRIPLE_BITS_24BPP) {
+            if (infoRec->TEGlyphRendererFlags & BIT_ORDER_IN_BYTE_MSBFIRST) {
+                if (infoRec->TEGlyphRendererFlags & CPU_TRANSFER_BASE_FIXED)
+                    infoRec->TEGlyphRenderer =
+                        XAATEGlyphRenderer3MSBFirstFixedBase;
+                else
+                    infoRec->TEGlyphRenderer = XAATEGlyphRenderer3MSBFirst;
+            }
+            else {
+                if (infoRec->TEGlyphRendererFlags & CPU_TRANSFER_BASE_FIXED)
+                    infoRec->TEGlyphRenderer =
+                        XAATEGlyphRenderer3LSBFirstFixedBase;
+                else
+                    infoRec->TEGlyphRenderer = XAATEGlyphRenderer3LSBFirst;
+            }
+
+            if (!HaveSolidFillRect &&
+                (infoRec->TEGlyphRendererFlags & RGB_EQUAL)) {
+                infoRec->TEGlyphRendererFlags &= ~RGB_EQUAL;
+                XAAMSG("WARNING:  TEGlyphRenderer cannot support RGB_EQUAL"
+                       " without solid fills\n");
+            }
+        }
+        else {
+            if (infoRec->TEGlyphRendererFlags & BIT_ORDER_IN_BYTE_MSBFIRST) {
+                if (infoRec->TEGlyphRendererFlags & CPU_TRANSFER_BASE_FIXED)
+                    infoRec->TEGlyphRenderer =
+                        XAATEGlyphRendererMSBFirstFixedBase;
+                else
+                    infoRec->TEGlyphRenderer = XAATEGlyphRendererMSBFirst;
+            }
+            else {
+                if (infoRec->TEGlyphRendererFlags & CPU_TRANSFER_BASE_FIXED)
+                    infoRec->TEGlyphRenderer =
+                        XAATEGlyphRendererLSBFirstFixedBase;
+                else
+                    infoRec->TEGlyphRenderer = XAATEGlyphRendererLSBFirst;
+            }
+        }
+
+        if (!HaveSolidFillRect &&
+            (infoRec->TEGlyphRendererFlags & TRANSPARENCY_ONLY)) {
+            infoRec->TEGlyphRendererFlags &= ~TRANSPARENCY_ONLY;
+            XAAMSG("WARNING:  TEGlyphRenderer cannot support TRANPARENCY_ONLY"
+                   " without solid fills\n");
+        }
+
+    }
+    else if (HaveScanlineColorExpansion) {
+        infoRec->TEGlyphRendererFlags =
+            infoRec->ScanlineCPUToScreenColorExpandFillFlags;
+
+        if (infoRec->TEGlyphRendererFlags & TRIPLE_BITS_24BPP) {
+            if (infoRec->TEGlyphRendererFlags & BIT_ORDER_IN_BYTE_MSBFIRST)
+                infoRec->TEGlyphRenderer = XAATEGlyphRendererScanline3MSBFirst;
+            else
+                infoRec->TEGlyphRenderer = XAATEGlyphRendererScanline3LSBFirst;
+
+            if (!HaveSolidFillRect &&
+                (infoRec->TEGlyphRendererFlags & RGB_EQUAL)) {
+                infoRec->TEGlyphRendererFlags &= ~RGB_EQUAL;
+                XAAMSG("WARNING:  TEGlyphRenderer cannot support RGB_EQUAL"
+                       " without solid fills\n");
+            }
+        }
+        else {
+            if (infoRec->TEGlyphRendererFlags & BIT_ORDER_IN_BYTE_MSBFIRST)
+                infoRec->TEGlyphRenderer = XAATEGlyphRendererScanlineMSBFirst;
+            else
+                infoRec->TEGlyphRenderer = XAATEGlyphRendererScanlineLSBFirst;
+        }
+
+        if (!HaveSolidFillRect &&
+            (infoRec->TEGlyphRendererFlags & TRANSPARENCY_ONLY)) {
+            infoRec->TEGlyphRendererFlags &= ~TRANSPARENCY_ONLY;
+            XAAMSG("WARNING:  TEGlyphRenderer cannot support TRANPARENCY_ONLY"
+                   " without solid fills\n");
+        }
+    }
+
+    /**** NonTE Glyphs ****/
+
+    if (infoRec->NonTEGlyphRenderer) {
+        XAAMSG("\tDriver provided NonTEGlyphRenderer replacement\n");
+    }
+    else if (infoRec->WriteBitmap &&
+             !(infoRec->WriteBitmapFlags & NO_TRANSPARENCY)) {
+        infoRec->NonTEGlyphRenderer = XAANonTEGlyphRenderer;
+        infoRec->NonTEGlyphRendererFlags = infoRec->WriteBitmapFlags;
+    }
+
+    /**** WritePixmap ****/
+
+    if (infoRec->WritePixmap &&
+        !xf86ReturnOptValBool(options, XAAOPT_WRITE_PIXMAP, FALSE)) {
+        XAAMSG("\tDriver provided WritePixmap replacement\n");
+    }
+    else if (HaveImageWriteRect) {
+        infoRec->WritePixmap = XAAWritePixmap;
+        infoRec->WritePixmapFlags =
+            infoRec->ImageWriteFlags | CONVERT_32BPP_TO_24BPP;
+    }
+    else if (HaveScanlineImageWriteRect) {
+        infoRec->WritePixmap = XAAWritePixmapScanline;
+        infoRec->WritePixmapFlags = infoRec->ScanlineImageWriteFlags;
+    }
+    else
+        infoRec->WritePixmap = NULL;
+
+    /**** ReadPixmap ****/
+
+    if (infoRec->ReadPixmap) {
+        XAAMSG("\tDriver provided ReadPixmap replacement\n");
+    }
+
+    /************** GC Level *************/
+
+    /**** CopyArea ****/
+
+    if (infoRec->CopyArea) {
+        XAAMSG("\tDriver provided GC level CopyArea replacement\n");
+    }
+    else if (infoRec->ScreenToScreenBitBlt) {
+        infoRec->CopyArea = XAACopyArea;
+        infoRec->CopyAreaFlags = infoRec->ScreenToScreenBitBltFlags;
+
+        /* most GC level primitives use one mid-level primitive so
+           the GC level primitive gets the mid-level primitive flag
+           and we use that at GC validation time.  But CopyArea uses
+           more than one mid-level primitive so we have to essentially
+           do a GC validation every time that primitive is used.
+           The CopyAreaFlags would only be used for filtering out the
+           common denominators.  Here we assume that if you don't do
+           ScreenToScreenBitBlt you aren't going to do the others.
+           We also assume that ScreenToScreenBitBlt has the least
+           restrictions. */
+    }
+
+    if (infoRec->CopyPlane) {
+        XAAMSG("\tDriver provided GC level CopyPlane replacement\n");
+    }
+    else if (infoRec->WriteBitmap &&
+             !(infoRec->WriteBitmapFlags & TRANSPARENCY_ONLY)) {
+        infoRec->CopyPlane = XAACopyPlaneColorExpansion;
+        infoRec->CopyPlaneFlags = infoRec->WriteBitmapFlags;
+    }
+
+    if (infoRec->PushPixelsSolid) {
+        XAAMSG("\tDriver provided GC level PushPixelsSolid replacement\n");
+    }
+    else if (infoRec->WriteBitmap &&
+             !(infoRec->WriteBitmapFlags & NO_TRANSPARENCY)) {
+        infoRec->PushPixelsSolid = XAAPushPixelsSolidColorExpansion;
+        infoRec->PushPixelsFlags = infoRec->WriteBitmapFlags;
+    }
+
+    if (infoRec->FillSolidRects) {
+        if (!infoRec->PolyFillRectSolid) {
+            infoRec->PolyFillRectSolid = XAAPolyFillRect;
+            infoRec->PolyFillRectSolidFlags = infoRec->FillSolidRectsFlags;
+        }
+    }
+    if (infoRec->FillSolidSpans) {
+        if (!infoRec->FillSpansSolid) {
+            infoRec->FillSpansSolid = XAAFillSpans;
+            infoRec->FillSpansSolidFlags = infoRec->FillSolidSpansFlags;
+        }
+    }
+
+    if (infoRec->FillMono8x8PatternRects || infoRec->FillColor8x8PatternRects ||
+        infoRec->FillCacheBltRects || infoRec->FillColorExpandRects ||
+        infoRec->FillCacheExpandRects) {
+        if (!infoRec->PolyFillRectStippled) {
+
+            infoRec->PolyFillRectStippled = XAAPolyFillRect;
+            infoRec->PolyFillRectStippledFlags = 0;
+        }
+    }
+
+    if (infoRec->FillMono8x8PatternSpans || infoRec->FillColor8x8PatternSpans ||
+        infoRec->FillCacheBltSpans || infoRec->FillColorExpandSpans ||
+        infoRec->FillCacheExpandSpans) {
+        if (!infoRec->FillSpansStippled) {
+
+            infoRec->FillSpansStippled = XAAFillSpans;
+            infoRec->FillSpansStippledFlags = 0;
+        }
+    }
+
+    if (infoRec->FillMono8x8PatternRects || infoRec->FillColor8x8PatternRects ||
+        infoRec->FillCacheBltRects || infoRec->FillColorExpandRects ||
+        infoRec->FillCacheExpandRects) {
+        if (!infoRec->PolyFillRectOpaqueStippled) {
+
+            infoRec->PolyFillRectOpaqueStippled = XAAPolyFillRect;
+            infoRec->PolyFillRectOpaqueStippledFlags = 0;
+        }
+    }
+
+    if (infoRec->FillMono8x8PatternSpans || infoRec->FillColor8x8PatternSpans ||
+        infoRec->FillCacheBltSpans || infoRec->FillColorExpandSpans ||
+        infoRec->FillCacheExpandSpans) {
+        if (!infoRec->FillSpansOpaqueStippled) {
+
+            infoRec->FillSpansOpaqueStippled = XAAFillSpans;
+            infoRec->FillSpansOpaqueStippledFlags = 0;
+        }
+    }
+
+    if (infoRec->FillMono8x8PatternRects || infoRec->FillColor8x8PatternRects ||
+        infoRec->FillCacheBltRects || infoRec->FillImageWriteRects) {
+        if (!infoRec->PolyFillRectTiled) {
+
+            infoRec->PolyFillRectTiled = XAAPolyFillRect;
+            infoRec->PolyFillRectTiledFlags = 0;
+        }
+    }
+
+    if (infoRec->FillMono8x8PatternSpans || infoRec->FillColor8x8PatternSpans ||
+        infoRec->FillCacheBltSpans) {
+        if (!infoRec->FillSpansTiled) {
+
+            infoRec->FillSpansTiled = XAAFillSpans;
+            infoRec->FillSpansTiledFlags = 0;
+        }
+    }
+
+    if (infoRec->TEGlyphRenderer &&
+        !(infoRec->TEGlyphRendererFlags & NO_TRANSPARENCY)) {
+
+        if (!infoRec->PolyText8TE) {
+            infoRec->PolyText8TE = XAAPolyText8TEColorExpansion;
+            infoRec->PolyText8TEFlags = infoRec->TEGlyphRendererFlags;
+        }
+
+        if (!infoRec->PolyText16TE) {
+            infoRec->PolyText16TE = XAAPolyText16TEColorExpansion;
+            infoRec->PolyText16TEFlags = infoRec->TEGlyphRendererFlags;
+        }
+
+        if (!infoRec->PolyGlyphBltTE) {
+            infoRec->PolyGlyphBltTE = XAAPolyGlyphBltTEColorExpansion;
+            infoRec->PolyGlyphBltTEFlags = infoRec->TEGlyphRendererFlags;
+        }
+    }
+
+    if (infoRec->TEGlyphRenderer &&
+        !(infoRec->TEGlyphRendererFlags & TRANSPARENCY_ONLY)) {
+
+        if (!infoRec->ImageText8TE) {
+            infoRec->ImageText8TE = XAAImageText8TEColorExpansion;
+            infoRec->ImageText8TEFlags = infoRec->TEGlyphRendererFlags;
+        }
+
+        if (!infoRec->ImageText16TE) {
+            infoRec->ImageText16TE = XAAImageText16TEColorExpansion;
+            infoRec->ImageText16TEFlags = infoRec->TEGlyphRendererFlags;
+        }
+
+        if (!infoRec->ImageGlyphBltTE) {
+            infoRec->ImageGlyphBltTE = XAAImageGlyphBltTEColorExpansion;
+            infoRec->ImageGlyphBltTEFlags = infoRec->TEGlyphRendererFlags;
+        }
+    }
+
+    if (infoRec->NonTEGlyphRenderer) {
+        if (!infoRec->PolyText8NonTE) {
+            infoRec->PolyText8NonTE = XAAPolyText8NonTEColorExpansion;
+            infoRec->PolyText8NonTEFlags = infoRec->NonTEGlyphRendererFlags;
+        }
+
+        if (!infoRec->PolyText16NonTE) {
+            infoRec->PolyText16NonTE = XAAPolyText16NonTEColorExpansion;
+            infoRec->PolyText16NonTEFlags = infoRec->NonTEGlyphRendererFlags;
+        }
+        if (!infoRec->PolyGlyphBltNonTE) {
+            infoRec->PolyGlyphBltNonTE = XAAPolyGlyphBltNonTEColorExpansion;
+            infoRec->PolyGlyphBltNonTEFlags = infoRec->NonTEGlyphRendererFlags;
+        }
+    }
+
+    if (infoRec->NonTEGlyphRenderer && HaveSolidFillRect) {
+        if (!infoRec->ImageText8NonTE) {
+            infoRec->ImageText8NonTE = XAAImageText8NonTEColorExpansion;
+            infoRec->ImageText8NonTEFlags = infoRec->NonTEGlyphRendererFlags;
+        }
+
+        if (!infoRec->ImageText16NonTE) {
+            infoRec->ImageText16NonTE = XAAImageText16NonTEColorExpansion;
+            infoRec->ImageText16NonTEFlags = infoRec->NonTEGlyphRendererFlags;
+        }
+
+        if (!infoRec->ImageGlyphBltNonTE) {
+            infoRec->ImageGlyphBltNonTE = XAAImageGlyphBltNonTEColorExpansion;
+            infoRec->ImageGlyphBltNonTEFlags = infoRec->NonTEGlyphRendererFlags;
+        }
+    }
+
+    if (!infoRec->PolyRectangleThinSolid && HaveSolidHorVertLine) {
+        infoRec->PolyRectangleThinSolid = XAAPolyRectangleThinSolid;
+        infoRec->PolyRectangleThinSolidFlags = infoRec->SolidLineFlags;
+    }
+
+    if (!infoRec->FillPolygonSolid && HaveSolidFillRect) {
+        infoRec->FillPolygonSolid = XAAFillPolygonSolid;
+        infoRec->FillPolygonSolidFlags = infoRec->SolidFillFlags;
+    }
+
+    if (!infoRec->FillPolygonStippled && (HaveMono8x8PatternFillRect ||
+                                          HaveScreenToScreenColorExpandFill ||
+                                          HaveScreenToScreenCopy)) {
+        infoRec->FillPolygonStippled = XAAFillPolygonStippled;
+        infoRec->FillPolygonStippledFlags = infoRec->SolidFillFlags;
+    }
+
+    if (!infoRec->FillPolygonOpaqueStippled && (HaveMono8x8PatternFillRect ||
+                                                HaveScreenToScreenColorExpandFill
+                                                || HaveScreenToScreenCopy)) {
+        infoRec->FillPolygonOpaqueStippled = XAAFillPolygonStippled;
+        infoRec->FillPolygonOpaqueStippledFlags = infoRec->SolidFillFlags;
+    }
+
+    if (!infoRec->FillPolygonTiled && (HaveMono8x8PatternFillRect ||
+                                       HaveScreenToScreenColorExpandFill ||
+                                       HaveScreenToScreenCopy)) {
+        infoRec->FillPolygonTiled = XAAFillPolygonTiled;
+        infoRec->FillPolygonTiledFlags = infoRec->SolidFillFlags;
+    }
+
+    if (!infoRec->PolyFillArcSolid && HaveSolidFillRect) {
+        infoRec->PolyFillArcSolid = XAAPolyFillArcSolid;
+        infoRec->PolyFillArcSolidFlags = infoRec->SolidFillFlags;
+    }
+
+    if (!infoRec->PolylinesWideSolid && HaveSolidFillRect) {
+        infoRec->PolylinesWideSolid = XAAPolylinesWideSolid;
+        infoRec->PolylinesWideSolidFlags =
+            infoRec->SolidFillFlags | GXCOPY_ONLY;
+    }
+
+    if (!infoRec->PutImage && (infoRec->WritePixmap ||
+                               (infoRec->WriteBitmap &&
+                                !(infoRec->
+                                  WriteBitmapFlags & TRANSPARENCY_ONLY)))) {
+        infoRec->PutImage = XAAPutImage;
+
+        /* See comment for CopyArea above.  But here we make fewer 
+           assumptions.  The driver can provide the PutImageFlags if
+           it wants too */
+    }
+
+    if (HaveSolidHorVertLine &&
+        (HaveSolidBresenhamLine || (HaveSolidTwoPointLine &&
+                                    (infoRec->
+                                     ClippingFlags &
+                                     HARDWARE_CLIP_SOLID_LINE)))) {
+        if (!infoRec->PolylinesThinSolid) {
+            infoRec->PolylinesThinSolid = XAAPolyLines;
+            infoRec->PolylinesThinSolidFlags = infoRec->SolidLineFlags;
+        }
+        if (!infoRec->PolySegmentThinSolid) {
+            infoRec->PolySegmentThinSolid = XAAPolySegment;
+            infoRec->PolySegmentThinSolidFlags = infoRec->SolidLineFlags;
+        }
+    }
+
+    if (HaveDashedBresenhamLine || (HaveDashedTwoPointLine &&
+                                    (infoRec->
+                                     ClippingFlags &
+                                     HARDWARE_CLIP_DASHED_LINE))) {
+        if (!infoRec->PolylinesThinDashed) {
+            infoRec->PolylinesThinDashed = XAAPolyLinesDashed;
+            infoRec->PolylinesThinDashedFlags = infoRec->DashedLineFlags;
+        }
+        if (!infoRec->PolySegmentThinDashed) {
+            infoRec->PolySegmentThinDashed = XAAPolySegmentDashed;
+            infoRec->PolySegmentThinDashedFlags = infoRec->DashedLineFlags;
+        }
+    }
+
+    if (infoRec->PolylinesThinDashed || infoRec->PolySegmentThinDashed) {
+        if (!infoRec->ComputeDash)
+            infoRec->ComputeDash = XAAComputeDash;
+    }
+
+    {
+        Bool haveTexture = infoRec->CPUToScreenTextureFormats &&
+            infoRec->CPUToScreenTextureDstFormats &&
+            infoRec->SetupForCPUToScreenTexture2 &&
+            infoRec->SubsequentCPUToScreenTexture;
+        Bool haveAlphaTexture = infoRec->CPUToScreenAlphaTextureFormats &&
+            infoRec->CPUToScreenAlphaTextureDstFormats &&
+            infoRec->SetupForCPUToScreenAlphaTexture2 &&
+            infoRec->SubsequentCPUToScreenAlphaTexture;
+
+        if (!infoRec->Composite && (haveTexture || haveAlphaTexture))
+            infoRec->Composite = XAADoComposite;
+
+        if (!infoRec->Glyphs && infoRec->WriteBitmap &&
+            !(infoRec->WriteBitmapFlags & NO_TRANSPARENCY)) {
+            infoRec->Glyphs = XAADoGlyphs;
+        }
+    }
+
+    /************  Validation Functions **************/
+
+    if (!infoRec->ValidateCopyArea && infoRec->CopyArea) {
+        infoRec->CopyAreaMask = GCWhenForced;
+        if ((infoRec->CopyAreaFlags & GXCOPY_ONLY) ||
+            (infoRec->CopyAreaFlags & ROP_NEEDS_SOURCE))
+            infoRec->CopyAreaMask |= GCFunction;
+        if (infoRec->CopyAreaFlags & NO_PLANEMASK)
+            infoRec->CopyAreaMask |= GCPlaneMask;
+        infoRec->ValidateCopyArea = XAAValidateCopyArea;
+    }
+
+    if (!infoRec->ValidateCopyPlane && infoRec->CopyPlane) {
+        infoRec->CopyPlaneMask = GCWhenForced;
+        if ((infoRec->CopyPlaneFlags & GXCOPY_ONLY) ||
+            (infoRec->CopyPlaneFlags & ROP_NEEDS_SOURCE))
+            infoRec->CopyPlaneMask |= GCFunction;
+        if (infoRec->CopyPlaneFlags & NO_PLANEMASK)
+            infoRec->CopyPlaneMask |= GCPlaneMask;
+        if (infoRec->CopyPlaneFlags & RGB_EQUAL)
+            infoRec->CopyPlaneMask |= GCForeground | GCBackground;
+        infoRec->ValidateCopyPlane = XAAValidateCopyPlane;
+    }
+
+    if (!infoRec->ValidatePutImage && infoRec->PutImage) {
+        infoRec->PutImageMask = GCWhenForced;
+        if ((infoRec->PutImageFlags & GXCOPY_ONLY) ||
+            (infoRec->PutImageFlags & ROP_NEEDS_SOURCE))
+            infoRec->PutImageMask |= GCFunction;
+        if (infoRec->PutImageFlags & NO_PLANEMASK)
+            infoRec->PutImageMask |= GCPlaneMask;
+        if (infoRec->PutImageFlags & RGB_EQUAL)
+            infoRec->PutImageMask |= GCForeground | GCBackground;
+        infoRec->ValidatePutImage = XAAValidatePutImage;
+    }
+
+    if (!infoRec->ValidatePushPixels && infoRec->PushPixelsSolid) {
+        infoRec->PushPixelsMask = GCFillStyle;
+        if ((infoRec->PushPixelsFlags & GXCOPY_ONLY) ||
+            (infoRec->PushPixelsFlags & ROP_NEEDS_SOURCE) ||
+            (infoRec->PushPixelsFlags & TRANSPARENCY_GXCOPY_ONLY))
+            infoRec->PushPixelsMask |= GCFunction;
+        if (infoRec->PushPixelsFlags & NO_PLANEMASK)
+            infoRec->PushPixelsMask |= GCPlaneMask;
+        if (infoRec->PushPixelsFlags & RGB_EQUAL)
+            infoRec->PushPixelsMask |= GCForeground;
+        infoRec->ValidatePushPixels = XAAValidatePushPixels;
+    }
+
+    /* By default XAA assumes the FillSpans, PolyFillRects, FillPolygon
+       and PolyFillArcs have the same restrictions.  If you supply GC 
+       level replacements for any of these and alter this relationship 
+       you may need to supply replacement validation routines */
+
+    if (!infoRec->ValidateFillSpans &&
+        (infoRec->FillSpansSolid || infoRec->FillSpansStippled ||
+         infoRec->FillSpansOpaqueStippled || infoRec->FillSpansTiled)) {
+
+        int compositeFlags = infoRec->FillSpansSolidFlags |
+            infoRec->FillSpansStippledFlags |
+            infoRec->FillSpansOpaqueStippledFlags |
+            infoRec->FillSpansTiledFlags;
+
+        infoRec->FillSpansMask = GCFillStyle | GCTile | GCStipple;
+
+        if ((compositeFlags & GXCOPY_ONLY) ||
+            (compositeFlags & ROP_NEEDS_SOURCE))
+            infoRec->FillSpansMask |= GCFunction;
+        if (compositeFlags & NO_PLANEMASK)
+            infoRec->FillSpansMask |= GCPlaneMask;
+        if (compositeFlags & RGB_EQUAL)
+            infoRec->FillSpansMask |= GCForeground;
+        infoRec->ValidateFillSpans = XAAValidateFillSpans;
+    }
+
+    /* By default XAA only provides Validations for the GlyphBlt
+       functions and not the text higher up. This is because the
+       Text8/16 and GlyphBlt are linked.  If you break this linkage,
+       you may need to have the driver supply its own Validation
+       routines */
+
+    if (!infoRec->ValidatePolyGlyphBlt &&
+        (infoRec->PolyGlyphBltTE || infoRec->PolyGlyphBltNonTE)) {
+        int compositeFlags = infoRec->PolyGlyphBltTEFlags |
+            infoRec->PolyGlyphBltNonTEFlags;
+
+        infoRec->PolyGlyphBltMask = GCFillStyle | GCFont;
+        if ((compositeFlags & GXCOPY_ONLY) ||
+            (compositeFlags & ROP_NEEDS_SOURCE) ||
+            (infoRec->PolyGlyphBltNonTEFlags & TRANSPARENCY_GXCOPY_ONLY))
+            infoRec->PolyGlyphBltMask |= GCFunction;
+        if (compositeFlags & NO_PLANEMASK)
+            infoRec->PolyGlyphBltMask |= GCPlaneMask;
+        if (compositeFlags & RGB_EQUAL)
+            infoRec->PolyGlyphBltMask |= GCForeground;
+        infoRec->ValidatePolyGlyphBlt = XAAValidatePolyGlyphBlt;
+    }
+
+    if (!infoRec->ValidateImageGlyphBlt &&
+        (infoRec->ImageGlyphBltTE || infoRec->ImageGlyphBltNonTE)) {
+        int compositeFlags = infoRec->ImageGlyphBltTEFlags |
+            infoRec->ImageGlyphBltNonTEFlags;
+
+        if (infoRec->ImageGlyphBltNonTE)
+            compositeFlags |= infoRec->SolidFillFlags;
+
+        infoRec->ImageGlyphBltMask = GCFont;
+        if (compositeFlags & NO_PLANEMASK)
+            infoRec->ImageGlyphBltMask |= GCPlaneMask;
+        if (compositeFlags & RGB_EQUAL)
+            infoRec->ImageGlyphBltMask |= GCForeground | GCBackground;
+        infoRec->ValidateImageGlyphBlt = XAAValidateImageGlyphBlt;
+    }
+
+    /* By default XAA only provides a Validation function for the 
+       Polylines and does segments and polylines at the same time */
+
+    if (!infoRec->ValidatePolylines && infoRec->ValidateFillSpans) {
+        int compositeFlags = infoRec->PolyRectangleThinSolidFlags |
+            infoRec->PolylinesWideSolidFlags |
+            infoRec->PolylinesThinSolidFlags |
+            infoRec->PolySegmentThinSolidFlags |
+            infoRec->PolySegmentThinDashedFlags |
+            infoRec->PolylinesThinDashedFlags;
+
+        infoRec->ValidatePolylines = XAAValidatePolylines;
+        infoRec->PolylinesMask =
+            infoRec->FillSpansMask | GCLineStyle | GCLineWidth;
+
+        if (infoRec->PolySegmentThinDashed || infoRec->PolylinesThinDashed)
+            infoRec->PolylinesMask |= GCDashList;
+        if (compositeFlags & NO_PLANEMASK)
+            infoRec->PolylinesMask |= GCPlaneMask;
+        if ((compositeFlags & GXCOPY_ONLY) ||
+            (compositeFlags & ROP_NEEDS_SOURCE))
+            infoRec->PolylinesMask |= GCFunction;
+        if (compositeFlags & RGB_EQUAL)
+            infoRec->PolylinesMask |= GCForeground;
+    }
+
+    /**** Fill choosers ****/
+
+    if (!infoRec->StippledFillChooser)
+        infoRec->StippledFillChooser = XAAStippledFillChooser;
+
+    if (!infoRec->OpaqueStippledFillChooser)
+        infoRec->OpaqueStippledFillChooser = XAAOpaqueStippledFillChooser;
+
+    if (!infoRec->TiledFillChooser)
+        infoRec->TiledFillChooser = XAATiledFillChooser;
+
+    /**** Setup the pixmap cache ****/
+
+    if (infoRec->WriteBitmapToCache) {
+    }
+    else if (infoRec->WriteBitmap &&
+             !(infoRec->WriteBitmapFlags & TRANSPARENCY_ONLY))
+        infoRec->WriteBitmapToCache = XAAWriteBitmapToCache;
+    else if (infoRec->Flags & LINEAR_FRAMEBUFFER)
+        infoRec->WriteBitmapToCache = XAAWriteBitmapToCacheLinear;
+    else
+        infoRec->PixmapCacheFlags |= DO_NOT_BLIT_STIPPLES;
+
+    if (infoRec->WritePixmapToCache) {
+    }
+    else if (infoRec->WritePixmap && !(infoRec->WritePixmapFlags & NO_GXCOPY))
+        infoRec->WritePixmapToCache = XAAWritePixmapToCache;
+    else if (infoRec->Flags & LINEAR_FRAMEBUFFER)
+        infoRec->WritePixmapToCache = XAAWritePixmapToCacheLinear;
+    else
+        infoRec->Flags &= ~PIXMAP_CACHE;
+
+    if (xf86ReturnOptValBool(options, XAAOPT_PIXMAP_CACHE, FALSE))
+        infoRec->Flags &= ~PIXMAP_CACHE;
+
+    if (infoRec->WriteMono8x8PatternToCache) {
+    }
+    else if (infoRec->PixmapCacheFlags & CACHE_MONO_8x8) {
+        if (infoRec->WritePixmapToCache)
+            infoRec->WriteMono8x8PatternToCache = XAAWriteMono8x8PatternToCache;
+        else
+            infoRec->PixmapCacheFlags &= ~CACHE_MONO_8x8;
+    }
+
+    if (infoRec->WriteColor8x8PatternToCache) {
+    }
+    else if (infoRec->PixmapCacheFlags & CACHE_COLOR_8x8) {
+        if (infoRec->WritePixmapToCache && infoRec->WriteBitmapToCache)
+            infoRec->WriteColor8x8PatternToCache =
+                XAAWriteColor8x8PatternToCache;
+        else
+            infoRec->PixmapCacheFlags &= ~CACHE_COLOR_8x8;
+    }
+
+    if (infoRec->CachePixelGranularity < 0) {
+        switch (pScrn->bitsPerPixel) {
+        case 24:
+        case 8:
+            infoRec->CachePixelGranularity = 4;
+            break;
+        case 16:
+            infoRec->CachePixelGranularity = 2;
+            break;
+        case 32:
+            infoRec->CachePixelGranularity = 1;
+            break;
+        default:
+            break;
+        }
+
+        if (BITMAP_SCANLINE_PAD == 64)
+            infoRec->CachePixelGranularity *= 2;
+    }
+
+    free(options);
+
+    if (!infoRec->CacheTile && infoRec->WritePixmapToCache)
+        infoRec->CacheTile = XAACacheTile;
+    if (!infoRec->CacheMonoStipple && infoRec->WritePixmapToCache)
+        infoRec->CacheMonoStipple = XAACacheMonoStipple;
+    if (!infoRec->CacheStipple && infoRec->WriteBitmapToCache)
+        infoRec->CacheStipple = XAACacheStipple;
+    if (!infoRec->CacheMono8x8Pattern && infoRec->WriteMono8x8PatternToCache)
+        infoRec->CacheMono8x8Pattern = XAACacheMono8x8Pattern;
+    if (!infoRec->CacheColor8x8Pattern && infoRec->WriteColor8x8PatternToCache)
+        infoRec->CacheColor8x8Pattern = XAACacheColor8x8Pattern;
+
+    if ((infoRec->Flags & PIXMAP_CACHE) && !infoRec->InitPixmapCache) {
+        infoRec->InitPixmapCache = XAAInitPixmapCache;
+        infoRec->ClosePixmapCache = XAAClosePixmapCache;
+    }
+
+    return TRUE;
+}
diff --git a/hw/xfree86/xaa/xaaLine.c b/hw/xfree86/xaa/xaaLine.c
new file mode 100644
index 000000000..d7c60975e
--- /dev/null
+++ b/hw/xfree86/xaa/xaaLine.c
@@ -0,0 +1,422 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <stdlib.h>
+
+#include <X11/X.h>
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include "scrnintstr.h"
+#include "pixmapstr.h"
+#include "miline.h"
+#include "xf86str.h"
+#include "xaa.h"
+#include "xaalocal.h"
+
+void
+#ifdef POLYSEGMENT
+ XAAPolySegment(DrawablePtr pDrawable, GCPtr pGC, int nseg, xSegment * pSeg
+#else
+XAAPolyLines(DrawablePtr pDrawable, GCPtr pGC, int mode,        /* Origin or Previous */
+             int npt,           /* number of points */
+             DDXPointPtr pptInit
+#endif
+    )
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    BoxPtr pboxInit = RegionRects(pGC->pCompositeClip);
+    int nboxInit = RegionNumRects(pGC->pCompositeClip);
+    unsigned int bias = miGetZeroLineBias(pDrawable->pScreen);
+    int xorg = pDrawable->x;
+    int yorg = pDrawable->y;
+    int nbox;
+    BoxPtr pbox;
+
+#ifndef POLYSEGMENT
+    DDXPointPtr ppt;
+#endif
+    int x1, x2, y1, y2, tmp, len;
+
+    if (!nboxInit)
+        return;
+
+    if (infoRec->SolidLineFlags & LINE_LIMIT_COORDS) {
+        int minValX = infoRec->SolidLineLimits.x1;
+        int maxValX = infoRec->SolidLineLimits.x2;
+        int minValY = infoRec->SolidLineLimits.y1;
+        int maxValY = infoRec->SolidLineLimits.y2;
+
+#ifdef POLYSEGMENT
+        int n = nseg;
+        xSegment *s = pSeg;
+
+        while (n--)
+#else
+        int n = npt;
+        int xorgtmp = xorg;
+        int yorgtmp = yorg;
+
+        ppt = pptInit;
+        x2 = ppt->x + xorgtmp;
+        y2 = ppt->y + yorgtmp;
+        while (--n)
+#endif
+        {
+#ifdef POLYSEGMENT
+            x1 = s->x1 + xorg;
+            y1 = s->y1 + yorg;
+            x2 = s->x2 + xorg;
+            y2 = s->y2 + yorg;
+            s++;
+#else
+            x1 = x2;
+            y1 = y2;
+            ++ppt;
+            if (mode == CoordModePrevious) {
+                xorgtmp = x1;
+                yorgtmp = y1;
+            }
+            x2 = ppt->x + xorgtmp;
+            y2 = ppt->y + yorgtmp;
+#endif
+            if (x1 > maxValX || x1 < minValX ||
+                x2 > maxValX || x2 < minValX ||
+                y1 > maxValY || y1 < minValY || y2 > maxValY || y2 < minValY) {
+#ifdef POLYSEGMENT
+                XAAFallbackOps.PolySegment(pDrawable, pGC, nseg, pSeg);
+#else
+                XAAFallbackOps.Polylines(pDrawable, pGC, mode, npt, pptInit);
+#endif
+                return;
+            }
+        }
+    }
+
+    (*infoRec->SetupForSolidLine) (infoRec->pScrn, pGC->fgPixel,
+                                   pGC->alu, pGC->planemask);
+
+#ifdef POLYSEGMENT
+    while (nseg--)
+#else
+    ppt = pptInit;
+    x2 = ppt->x + xorg;
+    y2 = ppt->y + yorg;
+    while (--npt)
+#endif
+    {
+        nbox = nboxInit;
+        pbox = pboxInit;
+
+#ifdef POLYSEGMENT
+        x1 = pSeg->x1 + xorg;
+        y1 = pSeg->y1 + yorg;
+        x2 = pSeg->x2 + xorg;
+        y2 = pSeg->y2 + yorg;
+        pSeg++;
+#else
+        x1 = x2;
+        y1 = y2;
+        ++ppt;
+        if (mode == CoordModePrevious) {
+            xorg = x1;
+            yorg = y1;
+        }
+        x2 = ppt->x + xorg;
+        y2 = ppt->y + yorg;
+#endif
+
+        if (x1 == x2) {         /* vertical line */
+            /* make the line go top to bottom of screen, keeping
+               endpoint semantics
+             */
+            if (y1 > y2) {
+                tmp = y2;
+                y2 = y1 + 1;
+                y1 = tmp + 1;
+#ifdef POLYSEGMENT
+                if (pGC->capStyle != CapNotLast)
+                    y1--;
+#endif
+            }
+#ifdef POLYSEGMENT
+            else if (pGC->capStyle != CapNotLast)
+                y2++;
+#endif
+            /* get to first band that might contain part of line */
+            while (nbox && (pbox->y2 <= y1)) {
+                pbox++;
+                nbox--;
+            }
+
+            /* stop when lower edge of box is beyond end of line */
+            while (nbox && (y2 >= pbox->y1)) {
+                if ((x1 >= pbox->x1) && (x1 < pbox->x2)) {
+                    tmp = max(y1, pbox->y1);
+                    len = min(y2, pbox->y2) - tmp;
+                    if (len)
+                        (*infoRec->SubsequentSolidHorVertLine) (infoRec->pScrn,
+                                                                x1, tmp, len,
+                                                                DEGREES_270);
+                }
+                nbox--;
+                pbox++;
+            }
+#ifndef POLYSEGMENT
+            y2 = ppt->y + yorg;
+#endif
+        }
+        else if (y1 == y2) {    /* horizontal line */
+            /* force line from left to right, keeping endpoint semantics */
+            if (x1 > x2) {
+                tmp = x2;
+                x2 = x1 + 1;
+                x1 = tmp + 1;
+#ifdef POLYSEGMENT
+                if (pGC->capStyle != CapNotLast)
+                    x1--;
+#endif
+            }
+#ifdef POLYSEGMENT
+            else if (pGC->capStyle != CapNotLast)
+                x2++;
+#endif
+
+            /* find the correct band */
+            while (nbox && (pbox->y2 <= y1)) {
+                pbox++;
+                nbox--;
+            }
+
+            /* try to draw the line, if we haven't gone beyond it */
+            if (nbox && (pbox->y1 <= y1)) {
+                int orig_y = pbox->y1;
+
+                /* when we leave this band, we're done */
+                while (nbox && (orig_y == pbox->y1)) {
+                    if (pbox->x2 <= x1) {
+                        /* skip boxes until one might contain start point */
+                        nbox--;
+                        pbox++;
+                        continue;
+                    }
+
+                    /* stop if left of box is beyond right of line */
+                    if (pbox->x1 >= x2) {
+                        nbox = 0;
+                        break;
+                    }
+
+                    tmp = max(x1, pbox->x1);
+                    len = min(x2, pbox->x2) - tmp;
+                    if (len)
+                        (*infoRec->SubsequentSolidHorVertLine) (infoRec->pScrn,
+                                                                tmp, y1, len,
+                                                                DEGREES_0);
+                    nbox--;
+                    pbox++;
+                }
+            }
+#ifndef POLYSEGMENT
+            x2 = ppt->x + xorg;
+#endif
+        }
+        else {                  /* sloped line */
+            unsigned int oc1, oc2;
+            int dmin, dmaj, e, octant;
+
+            if (infoRec->SubsequentSolidBresenhamLine) {
+                if ((dmaj = x2 - x1) < 0) {
+                    dmaj = -dmaj;
+                    octant = XDECREASING;
+                }
+                else
+                    octant = 0;
+
+                if ((dmin = y2 - y1) < 0) {
+                    dmin = -dmin;
+                    octant |= YDECREASING;
+                }
+
+                if (dmin >= dmaj) {
+                    tmp = dmin;
+                    dmin = dmaj;
+                    dmaj = tmp;
+                    octant |= YMAJOR;
+                }
+
+                e = -dmaj - ((bias >> octant) & 1);
+                len = dmaj;
+                dmin <<= 1;
+                dmaj <<= 1;
+            }
+            else {              /* Muffle compiler */
+                dmin = dmaj = e = octant = len = 0;
+            }
+
+            while (nbox--) {
+                oc1 = oc2 = 0;
+                OUTCODES(oc1, x1, y1, pbox);
+                OUTCODES(oc2, x2, y2, pbox);
+                if (!(oc1 | oc2)) {     /* unclipped */
+                    if (infoRec->SubsequentSolidTwoPointLine) {
+                        (*infoRec->SubsequentSolidTwoPointLine) (infoRec->pScrn,
+                                                                 x1, y1, x2, y2,
+#ifdef POLYSEGMENT
+                                                                 (pGC->
+                                                                  capStyle !=
+                                                                  CapNotLast) ?
+                                                                 0 :
+#endif
+                                                                 OMIT_LAST);
+                    }
+                    else {
+                        (*infoRec->SubsequentSolidBresenhamLine) (infoRec->
+                                                                  pScrn, x1, y1,
+                                                                  dmaj, dmin, e,
+#ifdef POLYSEGMENT
+                                                                  (pGC->
+                                                                   capStyle !=
+                                                                   CapNotLast)
+                                                                  ? (len + 1) :
+#endif
+                                                                  len, octant);
+                    }
+                    break;
+                }
+                else if (oc1 & oc2) {   /* completely clipped */
+                    pbox++;
+                }
+                else if (infoRec->ClippingFlags & HARDWARE_CLIP_SOLID_LINE) {
+                    (*infoRec->SetClippingRectangle) (infoRec->pScrn,
+                                                      pbox->x1, pbox->y1,
+                                                      pbox->x2 - 1,
+                                                      pbox->y2 - 1);
+
+                    if (infoRec->SubsequentSolidBresenhamLine) {
+                        (*infoRec->SubsequentSolidBresenhamLine) (infoRec->
+                                                                  pScrn, x1, y1,
+                                                                  dmaj, dmin, e,
+#ifdef POLYSEGMENT
+                                                                  (pGC->
+                                                                   capStyle !=
+                                                                   CapNotLast)
+                                                                  ? (len + 1) :
+#endif
+                                                                  len, octant);
+                    }
+                    else {
+                        (*infoRec->SubsequentSolidTwoPointLine) (infoRec->pScrn,
+                                                                 x1, y1, x2, y2,
+#ifdef POLYSEGMENT
+                                                                 (pGC->
+                                                                  capStyle !=
+                                                                  CapNotLast) ?
+                                                                 0 :
+#endif
+                                                                 OMIT_LAST);
+                    }
+                    (*infoRec->DisableClipping) (infoRec->pScrn);
+                    pbox++;
+                }
+                else {
+                    int new_x1 = x1, new_y1 = y1, new_x2 = x2, new_y2 = y2;
+                    int clip1 = 0, clip2 = 0;
+                    int err, adx, ady;
+
+                    if (octant & YMAJOR) {
+                        ady = dmaj >> 1;
+                        adx = dmin >> 1;
+                    }
+                    else {
+                        ady = dmin >> 1;
+                        adx = dmaj >> 1;
+                    }
+
+                    if (miZeroClipLine(pbox->x1, pbox->y1,
+                                       pbox->x2 - 1, pbox->y2 - 1,
+                                       &new_x1, &new_y1, &new_x2, &new_y2,
+                                       adx, ady, &clip1, &clip2,
+                                       octant, bias, oc1, oc2) == -1) {
+                        pbox++;
+                        continue;
+                    }
+
+                    if (octant & YMAJOR)
+                        len = abs(new_y2 - new_y1);
+                    else
+                        len = abs(new_x2 - new_x1);
+#ifdef POLYSEGMENT
+                    if (clip2 != 0 || pGC->capStyle != CapNotLast)
+                        len++;
+#else
+                    len += (clip2 != 0);
+#endif
+                    if (len) {
+                        int abserr, clipdx, clipdy;
+
+                        /* unwind bresenham error term to first point */
+                        if (clip1) {
+                            clipdx = abs(new_x1 - x1);
+                            clipdy = abs(new_y1 - y1);
+
+                            if (octant & YMAJOR)
+                                err = e + clipdy * dmin - clipdx * dmaj;
+                            else
+                                err = e + clipdx * dmin - clipdy * dmaj;
+                        }
+                        else
+                            err = e;
+
+#define range infoRec->SolidBresenhamLineErrorTermBits
+                        abserr = abs(err);
+                        while ((abserr & range) ||
+                               (dmaj & range) || (dmin & range)) {
+                            dmin >>= 1;
+                            dmaj >>= 1;
+                            abserr >>= 1;
+                            err /= 2;
+                        }
+
+                        (*infoRec->SubsequentSolidBresenhamLine) (infoRec->
+                                                                  pScrn, new_x1,
+                                                                  new_y1, dmaj,
+                                                                  dmin, err,
+                                                                  len, octant);
+                    }
+                    pbox++;
+                }
+            }                   /* while (nbox--) */
+        }                       /* sloped line */
+    }                           /* while (nline--) */
+
+#ifndef POLYSEGMENT
+    /* paint the last point if the end style isn't CapNotLast.
+       (Assume that a projecting, butt, or round cap that is one
+       pixel wide is the same as the single pixel of the endpoint.)
+     */
+
+    if ((pGC->capStyle != CapNotLast) &&
+        ((ppt->x + xorg != pptInit->x + pDrawable->x) ||
+         (ppt->y + yorg != pptInit->y + pDrawable->y) ||
+         (ppt == pptInit + 1))) {
+        nbox = nboxInit;
+        pbox = pboxInit;
+        while (nbox--) {
+            if ((x2 >= pbox->x1) && (y2 >= pbox->y1) &&
+                (x2 < pbox->x2) && (y2 < pbox->y2)) {
+                (*infoRec->SubsequentSolidHorVertLine) (infoRec->pScrn, x2, y2,
+                                                        1, DEGREES_0);
+                break;
+            }
+            else
+                pbox++;
+        }
+    }
+#endif
+
+    SET_SYNC_FLAG(infoRec);
+}
diff --git a/hw/xfree86/xaa/xaaLineMisc.c b/hw/xfree86/xaa/xaaLineMisc.c
new file mode 100644
index 000000000..4379778f6
--- /dev/null
+++ b/hw/xfree86/xaa/xaaLineMisc.c
@@ -0,0 +1,149 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include "miline.h"
+#include "xf86str.h"
+#include "xaa.h"
+#include "xaalocal.h"
+
+void
+XAASolidHorVertLineAsRects(ScrnInfoPtr pScrn, int x, int y, int len, int dir)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+
+    if (dir == DEGREES_0)
+        (*infoRec->SubsequentSolidFillRect) (pScrn, x, y, len, 1);
+    else
+        (*infoRec->SubsequentSolidFillRect) (pScrn, x, y, 1, len);
+}
+
+void
+XAASolidHorVertLineAsTwoPoint(ScrnInfoPtr pScrn, int x, int y, int len, int dir)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+
+    len--;
+
+    if (dir == DEGREES_0)
+        (*infoRec->SubsequentSolidTwoPointLine) (pScrn, x, y, x + len, y, 0);
+    else
+        (*infoRec->SubsequentSolidTwoPointLine) (pScrn, x, y, x, y + len, 0);
+}
+
+void
+XAASolidHorVertLineAsBresenham(ScrnInfoPtr pScrn,
+                               int x, int y, int len, int dir)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+
+    if (dir == DEGREES_0)
+        (*infoRec->SubsequentSolidBresenhamLine) (pScrn, x, y, len << 1, 0,
+                                                  -len, len, 0);
+    else
+        (*infoRec->SubsequentSolidBresenhamLine) (pScrn, x, y, len << 1, 0,
+                                                  -len, len, YMAJOR);
+}
+
+void
+XAAComputeDash(GCPtr pGC)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    XAAGCPtr pGCPriv = (XAAGCPtr) dixLookupPrivate(&pGC->devPrivates,
+                                                   XAAGetGCKey());
+    Bool EvenDash = (pGC->numInDashList & 0x01) ? FALSE : TRUE;
+    int PatternLength = 0;
+    unsigned char *DashPtr = (unsigned char *) pGC->dash;
+    CARD32 *ptr;
+    int count = pGC->numInDashList;
+    int shift, value, direction;
+    Bool set;
+
+    free(pGCPriv->DashPattern);
+
+    pGCPriv->DashPattern = NULL;
+    pGCPriv->DashLength = 0;
+
+    while (count--)
+        PatternLength += *(DashPtr++);
+
+    if (!EvenDash)
+        PatternLength <<= 1;
+
+    if (PatternLength > infoRec->DashPatternMaxLength)
+        return;
+
+    if ((infoRec->DashedLineFlags & LINE_PATTERN_POWER_OF_2_ONLY) &&
+        (PatternLength & (PatternLength - 1)))
+        return;
+
+    pGCPriv->DashPattern = calloc((PatternLength + 31) >> 5, 4);
+    if (!pGCPriv->DashPattern)
+        return;
+    pGCPriv->DashLength = PatternLength;
+
+    if (infoRec->DashedLineFlags & (LINE_PATTERN_LSBFIRST_MSBJUSTIFIED |
+                                    LINE_PATTERN_LSBFIRST_LSBJUSTIFIED)) {
+        direction = 1;
+        set = TRUE;
+        DashPtr = (unsigned char *) pGC->dash;
+    }
+    else {
+        direction = -1;
+        set = FALSE;
+        DashPtr = (unsigned char *) pGC->dash + pGC->numInDashList - 1;
+    }
+
+    if (infoRec->DashedLineFlags & (LINE_PATTERN_LSBFIRST_MSBJUSTIFIED |
+                                    LINE_PATTERN_MSBFIRST_MSBJUSTIFIED))
+        shift = 32 - (PatternLength & 31);
+    else
+        shift = 0;
+
+    ptr = (CARD32 *) (pGCPriv->DashPattern);
+
+ CONCATENATE:
+
+    count = pGC->numInDashList;
+
+    while (count--) {
+        value = *DashPtr;
+        DashPtr += direction;
+        while (value) {
+            if (value < (32 - shift)) {
+                if (set)
+                    *ptr |= XAAShiftMasks[value] << shift;
+                shift += value;
+                break;
+            }
+            else {
+                if (set)
+                    *ptr |= ~0L << shift;
+                value -= (32 - shift);
+                shift = 0;
+                ptr++;
+            }
+        }
+        if (set)
+            set = FALSE;
+        else
+            set = TRUE;
+    }
+
+    if (!EvenDash) {
+        EvenDash = TRUE;
+        if (infoRec->DashedLineFlags & (LINE_PATTERN_LSBFIRST_MSBJUSTIFIED |
+                                        LINE_PATTERN_LSBFIRST_LSBJUSTIFIED))
+            DashPtr = (unsigned char *) pGC->dash;
+        else
+            DashPtr = (unsigned char *) pGC->dash + pGC->numInDashList;
+        goto CONCATENATE;
+    }
+}
diff --git a/hw/xfree86/xaa/xaaNonTEGlyph.c b/hw/xfree86/xaa/xaaNonTEGlyph.c
new file mode 100644
index 000000000..bfe7f9a09
--- /dev/null
+++ b/hw/xfree86/xaa/xaaNonTEGlyph.c
@@ -0,0 +1,192 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "xaa.h"
+#include "xaalocal.h"
+#include "xaacexp.h"
+#include "xf86.h"
+
+/* Not used anymore because the algorithm isn't correct. It doesn't
+   handle overlapping characters properly */
+
+#ifdef TRIPLE_BITS
+#define NonTEGlyphFunc EXPNAME(XAANonTEGlyphScanlineFunc3)
+#else
+#define NonTEGlyphFunc EXPNAME(XAANonTEGlyphScanlineFunc)
+#endif
+
+/********************************************************************
+
+   Here we have NonTEGlyphRenders for a bunch of different color
+   expansion types.  The driver may provide its own renderer, but
+   this is the default one which renders using lower-level primitives
+   exported by the chipset driver.
+
+********************************************************************/
+
+/* Since the dimensions of the text string and the backing rectangle
+	do not always coincide, it is possible that wBack or wText
+	may be 0!  The NonTEGlyphRender must always check for this. */
+
+/* This gets built for MSBFIRST or LSBFIRST with FIXEDBASE or not,
+	with TRIPLE_BITS or not. A total of 8 versions */
+
+/* if the backing rectangle and text are of the same dimensions
+	then we can draw in one pass */
+
+void
+#ifdef TRIPLE_BITS
+ EXPNAME(XAANonTEGlyphRenderer3) (
+#else
+ EXPNAME(XAANonTEGlyphRenderer) (
+#endif
+                                    ScrnInfoPtr pScrn,
+                                    int xText, int wText,
+                                    int y, int h, int skipleft, int startline,
+                                    NonTEGlyphInfo * glyphp,
+                                    int fg, int rop, unsigned int planemask) {
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    CARD32 *base = (CARD32 *) infoRec->ColorExpandBase;
+
+#ifdef TRIPLE_BITS
+    int dwords = ((3 * wText + 31) >> 5) * h;
+#else
+    int dwords = ((wText + 31) >> 5) * h;
+#endif
+
+    (*infoRec->SetupForCPUToScreenColorExpandFill) (pScrn, fg, -1, rop,
+                                                    planemask);
+    (*infoRec->SubsequentCPUToScreenColorExpandFill) (pScrn, xText, y, wText, h,
+                                                      0);
+
+#ifndef FIXEDBASE
+#ifdef TRIPLE_BITS
+    if ((((3 * wText + 31) >> 5) * h) <= infoRec->ColorExpandRange)
+#else
+    if ((((wText + 31) >> 5) * h) <= infoRec->ColorExpandRange)
+#endif
+        while (h--)
+            base = NonTEGlyphFunc(base, glyphp, startline++, wText, skipleft);
+    else
+#endif
+        while (h--)
+            NonTEGlyphFunc(base, glyphp, startline++, wText, skipleft);
+
+    if ((infoRec->CPUToScreenColorExpandFillFlags & CPU_TRANSFER_PAD_QWORD) &&
+        (dwords & 1)) {
+        base = (CARD32 *) infoRec->ColorExpandBase;
+        base[0] = 0x00000000;
+    }
+
+    if (infoRec->CPUToScreenColorExpandFillFlags & SYNC_AFTER_COLOR_EXPAND)
+        (*infoRec->Sync) (pScrn);
+    else
+        SET_SYNC_FLAG(infoRec);
+}
+
+#ifndef FIXEDBASE
+/*  Scanline version of above gets built for LSBFIRST and MSBFIRST */
+
+void
+#ifdef TRIPLE_BITS
+ EXPNAME(XAANonTEGlyphRendererScanline3) (
+#else
+ EXPNAME(XAANonTEGlyphRendererScanline) (
+#endif
+                                            ScrnInfoPtr pScrn,
+                                            int xText, int wText,
+                                            int y, int h, int skipleft,
+                                            int startline,
+                                            NonTEGlyphInfo * glyphp, int fg,
+                                            int rop, unsigned int planemask) {
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int bufferNo = 0;
+    CARD32 *base;
+
+    (*infoRec->SetupForScanlineCPUToScreenColorExpandFill) (pScrn, fg, -1, rop,
+                                                            planemask);
+    (*infoRec->SubsequentScanlineCPUToScreenColorExpandFill) (pScrn, xText, y,
+                                                              wText, h, 0);
+
+    while (h--) {
+        base = (CARD32 *) infoRec->ScanlineColorExpandBuffers[bufferNo];
+        NonTEGlyphFunc(base, glyphp, startline++, wText, skipleft);
+        (*infoRec->SubsequentColorExpandScanline) (pScrn, bufferNo++);
+        if (bufferNo >= infoRec->NumScanlineColorExpandBuffers)
+            bufferNo = 0;
+    }
+
+    SET_SYNC_FLAG(infoRec);
+}
+
+#endif
+
+/********************************************************************
+
+   Generic NonTE scanline rendering code.
+
+********************************************************************/
+
+CARD32 *
+NonTEGlyphFunc(CARD32 *base,
+               NonTEGlyphInfo * glyphp, int line, int TotalWidth, int skipleft)
+{
+    CARD32 bits = 0;
+    int shift = glyphp->width;
+
+    if (skipleft) {
+        if ((line >= glyphp->firstline) && (line <= glyphp->lastline))
+            bits = SHIFT_R(glyphp->bitsp[line], skipleft);
+        shift -= skipleft;
+    }
+    else if ((line >= glyphp->firstline) && (line <= glyphp->lastline))
+        bits = glyphp->bitsp[line];
+
+    while (TotalWidth > 32) {
+        while (shift < 32) {
+            glyphp++;
+            if ((line >= glyphp->firstline) && (line <= glyphp->lastline))
+                bits |= SHIFT_L(glyphp->bitsp[line], shift);
+            shift += glyphp->width;
+        }
+#ifdef TRIPLE_BITS
+        WRITE_BITS3(bits);
+#else
+        WRITE_BITS(bits);
+#endif
+        shift &= 31;
+        if (shift && (line >= glyphp->firstline) && (line <= glyphp->lastline))
+            bits = SHIFT_R(glyphp->bitsp[line], glyphp->width - shift);
+        else
+            bits = 0;
+        TotalWidth -= 32;
+    }
+
+    if (TotalWidth) {
+        TotalWidth -= shift;
+        while (TotalWidth > 0) {
+            glyphp++;
+            if ((line >= glyphp->firstline) && (line <= glyphp->lastline))
+                bits |= SHIFT_L(glyphp->bitsp[line], shift);
+            shift += glyphp->width;
+            TotalWidth -= glyphp->width;
+        }
+#ifdef TRIPLE_BITS
+        if (shift >= 22) {
+            WRITE_BITS3(bits);
+        }
+        else if (shift >= 11) {
+            WRITE_BITS2(bits);
+        }
+        else {
+            WRITE_BITS1(bits);
+        }
+#else
+        WRITE_BITS(bits);
+#endif
+    }
+
+    return base;
+}
diff --git a/hw/xfree86/xaa/xaaNonTEText.c b/hw/xfree86/xaa/xaaNonTEText.c
new file mode 100644
index 000000000..9cd228590
--- /dev/null
+++ b/hw/xfree86/xaa/xaaNonTEText.c
@@ -0,0 +1,591 @@
+
+/********************************************************************
+
+   In this file we have GC level replacements for PolyText8/16,
+   ImageText8/16, ImageGlyphBlt and PolyGlyphBlt for NonTE (proportional) 
+   fonts. The idea is that everything in this file is device independent.
+   The mentioned GCOps are merely wrappers for the 
+   PolyGlyphBltNonTEColorExpansion and ImageGlyphBltNonTEColorExpansion
+   functions which calculate the boxes containing arbitrarily clipped 
+   text and passes them to the NonTEGlyphRenderer which will usually 
+   be a lower level XAA function which renders these clipped glyphs using
+   the basic color expansion functions exported by the chipset driver.
+   The NonTEGlyphRenderer itself may optionally be driver supplied to
+   facilitate work-arounds/optimizations at a higher level than usual.
+
+   Written by Mark Vojkovich (mvojkovi@ucsd.edu)
+
+********************************************************************/
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <string.h>
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include <X11/fonts/font.h>
+#include "scrnintstr.h"
+#include "dixfontstr.h"
+#include "xf86str.h"
+#include "xaa.h"
+#include "xaacexp.h"
+#include "xaalocal.h"
+#include "gcstruct.h"
+#include "pixmapstr.h"
+
+static void ImageGlyphBltNonTEColorExpansion(ScrnInfoPtr pScrn,
+                                             int xInit, int yInit, FontPtr font,
+                                             int fg, int bg, unsigned planemask,
+                                             RegionPtr cclip, int nglyph,
+                                             unsigned char *gBase,
+                                             CharInfoPtr * ppci);
+static int PolyGlyphBltNonTEColorExpansion(ScrnInfoPtr pScrn, int xInit,
+                                           int yInit, FontPtr font, int fg,
+                                           int rop, unsigned planemask,
+                                           RegionPtr cclip, int nglyph,
+                                           unsigned char *gBase,
+                                           CharInfoPtr * ppci);
+
+/********************************************************************
+
+   GC level replacements for PolyText8/16 and ImageText8/16
+   for NonTE fonts when using color expansion.
+
+********************************************************************/
+
+int
+XAAPolyText8NonTEColorExpansion(DrawablePtr pDraw,
+                                GCPtr pGC, int x, int y, int count, char *chars)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    unsigned long n;
+    int width = 0;
+
+    (*pGC->font->get_glyphs) (pGC->font, (unsigned long) count,
+                              (unsigned char *) chars, Linear8Bit, &n,
+                              infoRec->CharInfo);
+
+    if (n) {
+        width = PolyGlyphBltNonTEColorExpansion(infoRec->pScrn,
+                                                x + pDraw->x, y + pDraw->y,
+                                                pGC->font, pGC->fgPixel,
+                                                pGC->alu, pGC->planemask,
+                                                pGC->pCompositeClip, n,
+                                                FONTGLYPHS(pGC->font),
+                                                infoRec->CharInfo);
+    }
+
+    return x + width;
+}
+
+int
+XAAPolyText16NonTEColorExpansion(DrawablePtr pDraw,
+                                 GCPtr pGC,
+                                 int x, int y, int count, unsigned short *chars)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    unsigned long n;
+    int width = 0;
+
+    (*pGC->font->get_glyphs) (pGC->font, (unsigned long) count,
+                              (unsigned char *) chars,
+                              (FONTLASTROW(pGC->font) ==
+                               0) ? Linear16Bit : TwoD16Bit, &n,
+                              infoRec->CharInfo);
+
+    if (n) {
+        width = PolyGlyphBltNonTEColorExpansion(infoRec->pScrn,
+                                                x + pDraw->x, y + pDraw->y,
+                                                pGC->font, pGC->fgPixel,
+                                                pGC->alu, pGC->planemask,
+                                                pGC->pCompositeClip, n,
+                                                FONTGLYPHS(pGC->font),
+                                                infoRec->CharInfo);
+    }
+
+    return x + width;
+}
+
+void
+XAAImageText8NonTEColorExpansion(DrawablePtr pDraw,
+                                 GCPtr pGC,
+                                 int x, int y, int count, char *chars)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    unsigned long n;
+
+    if (!RegionNumRects(pGC->pCompositeClip))
+        return;
+
+    (*pGC->font->get_glyphs) (pGC->font, (unsigned long) count,
+                              (unsigned char *) chars, Linear8Bit, &n,
+                              infoRec->CharInfo);
+
+    if (n)
+        ImageGlyphBltNonTEColorExpansion(infoRec->pScrn, x + pDraw->x,
+                                         y + pDraw->y, pGC->font, pGC->fgPixel,
+                                         pGC->bgPixel, pGC->planemask,
+                                         pGC->pCompositeClip, n,
+                                         FONTGLYPHS(pGC->font),
+                                         infoRec->CharInfo);
+}
+
+void
+XAAImageText16NonTEColorExpansion(DrawablePtr pDraw,
+                                  GCPtr pGC,
+                                  int x,
+                                  int y, int count, unsigned short *chars)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    unsigned long n;
+
+    if (!RegionNumRects(pGC->pCompositeClip))
+        return;
+
+    (*pGC->font->get_glyphs) (pGC->font, (unsigned long) count,
+                              (unsigned char *) chars,
+                              (FONTLASTROW(pGC->font) ==
+                               0) ? Linear16Bit : TwoD16Bit, &n,
+                              infoRec->CharInfo);
+
+    if (n)
+        ImageGlyphBltNonTEColorExpansion(infoRec->pScrn, x + pDraw->x,
+                                         y + pDraw->y, pGC->font, pGC->fgPixel,
+                                         pGC->bgPixel, pGC->planemask,
+                                         pGC->pCompositeClip, n,
+                                         FONTGLYPHS(pGC->font),
+                                         infoRec->CharInfo);
+}
+
+/********************************************************************
+
+   GC level replacements for ImageGlyphBlt and PolyGlyphBlt for
+   NonTE fonts when using color expansion.
+
+********************************************************************/
+
+void
+XAAImageGlyphBltNonTEColorExpansion(DrawablePtr pDraw, GCPtr pGC, int xInit, int yInit, unsigned int nglyph, CharInfoPtr * ppci,        /* array of character info */
+                                    void *pglyphBase  /* start of array of glyphs */
+    )
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+
+    if (!RegionNumRects(pGC->pCompositeClip))
+        return;
+
+    ImageGlyphBltNonTEColorExpansion(infoRec->pScrn, xInit + pDraw->x,
+                                     yInit + pDraw->y, pGC->font, pGC->fgPixel,
+                                     pGC->bgPixel, pGC->planemask,
+                                     pGC->pCompositeClip, nglyph,
+                                     (unsigned char *) pglyphBase, ppci);
+}
+
+void
+XAAPolyGlyphBltNonTEColorExpansion(DrawablePtr pDraw, GCPtr pGC, int xInit, int yInit, unsigned int nglyph, CharInfoPtr * ppci, /* array of character info */
+                                   void *pglyphBase   /* start of array of glyphs */
+    )
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+
+    if (!RegionNumRects(pGC->pCompositeClip))
+        return;
+
+    PolyGlyphBltNonTEColorExpansion(infoRec->pScrn, xInit + pDraw->x,
+                                    yInit + pDraw->y, pGC->font, pGC->fgPixel,
+                                    pGC->alu, pGC->planemask,
+                                    pGC->pCompositeClip, nglyph,
+                                    (unsigned char *) pglyphBase, ppci);
+}
+
+/********************************************************************
+
+   ImageGlyphBltNonTEColorExpansion -
+   PolyGlyphBltNonTEColorExpansion -
+
+   These guys compute the clipped pieces of text and send it to
+   the lower-level function which will handle acceleration of 
+   arbitrarily clipped text.
+  
+********************************************************************/
+
+static int
+CollectCharacterInfo(NonTEGlyphPtr glyphs,
+                     unsigned int nglyph, CharInfoPtr * ppci, FontPtr pfont)
+{
+    int i, w = 0;
+
+    for (i = 0; i < nglyph; i++, ppci++, glyphs++) {
+        glyphs->bits = (unsigned char *) ((*ppci)->bits);
+        glyphs->start = w + (*ppci)->metrics.leftSideBearing;
+        glyphs->end = w + (*ppci)->metrics.rightSideBearing;
+        glyphs->yoff = (*ppci)->metrics.ascent;
+        glyphs->height = glyphs->yoff + (*ppci)->metrics.descent;
+        glyphs->srcwidth = PADGLYPHWIDTHBYTES(glyphs->end - glyphs->start);
+        w += (*ppci)->metrics.characterWidth;
+    }
+    return w;
+}
+
+static void
+PolyGlyphBltAsSingleBitmap(ScrnInfoPtr pScrn,
+                           int nglyph,
+                           FontPtr font,
+                           int xInit,
+                           int yInit,
+                           int nbox,
+                           BoxPtr pbox, int fg, int rop, unsigned planemask)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    CARD32 *block, *pntr, *bits;
+    int pitch, topLine, botLine, top, bot, height;
+    int Left, Right, Top, Bottom;
+    int LeftEdge, RightEdge;
+    int bitPitch, shift, size, i, skippix;
+    NonTEGlyphPtr glyphs = infoRec->GlyphInfo;
+    Bool extra;
+
+    Left = xInit + infoRec->GlyphInfo[0].start;
+    Right = xInit + infoRec->GlyphInfo[nglyph - 1].end;
+    Top = yInit - FONTMAXBOUNDS(font, ascent);
+    Bottom = yInit + FONTMAXBOUNDS(font, descent);
+
+    /* get into the first band that may contain part of our string */
+    while (nbox && (Top >= pbox->y2)) {
+        pbox++;
+        nbox--;
+    }
+
+    if (!nbox)
+        return;
+
+    pitch = (Right - Left + 31) >> 5;
+    size = (pitch << 2) * (Bottom - Top);
+    block = calloc(1, size);
+
+    topLine = 10000;
+    botLine = -10000;
+
+    while (nglyph--) {
+        top = -glyphs->yoff;
+        bot = top + glyphs->height;
+        if (top < topLine)
+            topLine = top;
+        if (bot > botLine)
+            botLine = bot;
+        skippix = glyphs->start - infoRec->GlyphInfo[0].start;
+        bits = (CARD32 *) glyphs->bits;
+        bitPitch = glyphs->srcwidth >> 2;
+        pntr = block + ((FONTMAXBOUNDS(font, ascent) + top) * pitch) +
+            (skippix >> 5);
+        shift = skippix & 31;
+        extra = ((shift + glyphs->end - glyphs->start) > 32);
+
+        for (i = top; i < bot; i++) {
+            *pntr |= SHIFT_L(*bits, shift);
+            if (extra)
+                *(pntr + 1) |= SHIFT_R(*bits, 32 - shift);
+            pntr += pitch;
+            bits += bitPitch;
+        }
+
+        glyphs++;
+    }
+
+    pntr = block + ((FONTMAXBOUNDS(font, ascent) + topLine) * pitch);
+
+    Top = yInit + topLine;
+    Bottom = yInit + botLine;
+
+    while (nbox && (Top >= pbox->y2)) {
+        pbox++;
+        nbox--;
+    }
+
+    while (nbox && (Bottom > pbox->y1)) {
+        LeftEdge = max(Left, pbox->x1);
+        RightEdge = min(Right, pbox->x2);
+
+        if (RightEdge > LeftEdge) {
+            skippix = LeftEdge - Left;
+            topLine = max(Top, pbox->y1);
+            botLine = min(Bottom, pbox->y2);
+            height = botLine - topLine;
+
+            if (height > 0)
+                (*infoRec->WriteBitmap) (pScrn, LeftEdge, topLine,
+                                         RightEdge - LeftEdge, height,
+                                         (unsigned char *) (pntr +
+                                                            ((topLine -
+                                                              Top) * pitch) +
+                                                            (skippix >> 5)),
+                                         pitch << 2, skippix & 31, fg, -1, rop,
+                                         planemask);
+        }
+
+        nbox--;
+        pbox++;
+    }
+
+    free(block);
+}
+
+static void
+ImageGlyphBltNonTEColorExpansion(ScrnInfoPtr pScrn,
+                                 int xInit, int yInit,
+                                 FontPtr font,
+                                 int fg, int bg,
+                                 unsigned planemask,
+                                 RegionPtr cclip,
+                                 int nglyph,
+                                 unsigned char *gBase, CharInfoPtr * ppci)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int skippix, skipglyph, width, n, i;
+    int Left, Right, Top, Bottom;
+    int LeftEdge, RightEdge, ytop, ybot;
+    int nbox = RegionNumRects(cclip);
+    BoxPtr pbox = RegionRects(cclip);
+    Bool AlreadySetup = FALSE;
+
+    width = CollectCharacterInfo(infoRec->GlyphInfo, nglyph, ppci, font);
+
+    /* find our backing rectangle dimensions */
+    Left = xInit;
+    Right = Left + width;
+    Top = yInit - FONTASCENT(font);
+    Bottom = yInit + FONTDESCENT(font);
+
+    /* get into the first band that may contain part of our box */
+    while (nbox && (Top >= pbox->y2)) {
+        pbox++;
+        nbox--;
+    }
+
+    while (nbox && (Bottom >= pbox->y1)) {
+        /* handle backing rect first */
+        LeftEdge = max(Left, pbox->x1);
+        RightEdge = min(Right, pbox->x2);
+        if (RightEdge > LeftEdge) {
+            ytop = max(Top, pbox->y1);
+            ybot = min(Bottom, pbox->y2);
+
+            if (ybot > ytop) {
+                if (!AlreadySetup) {
+                    (*infoRec->SetupForSolidFill) (pScrn, bg, GXcopy,
+                                                   planemask);
+                    AlreadySetup = TRUE;
+                }
+                (*infoRec->SubsequentSolidFillRect) (pScrn,
+                                                     LeftEdge, ytop,
+                                                     RightEdge - LeftEdge,
+                                                     ybot - ytop);
+            }
+        }
+        nbox--;
+        pbox++;
+    }
+
+    nbox = RegionNumRects(cclip);
+    pbox = RegionRects(cclip);
+
+    if (infoRec->WriteBitmap && (nglyph > 1) &&
+        ((FONTMAXBOUNDS(font, rightSideBearing) -
+          FONTMINBOUNDS(font, leftSideBearing)) <= 32)) {
+        PolyGlyphBltAsSingleBitmap(pScrn, nglyph, font,
+                                   xInit, yInit, nbox, pbox,
+                                   fg, GXcopy, planemask);
+
+        return;
+    }
+
+    /* compute an approximate but covering bounding box */
+    Left = xInit + infoRec->GlyphInfo[0].start;
+    Right = xInit + infoRec->GlyphInfo[nglyph - 1].end;
+    Top = yInit - FONTMAXBOUNDS(font, ascent);
+    Bottom = yInit + FONTMAXBOUNDS(font, descent);
+
+    /* get into the first band that may contain part of our box */
+    while (nbox && (Top >= pbox->y2)) {
+        pbox++;
+        nbox--;
+    }
+
+    /* stop when the lower edge of the box is beyond our string */
+    while (nbox && (Bottom >= pbox->y1)) {
+        LeftEdge = max(Left, pbox->x1);
+        RightEdge = min(Right, pbox->x2);
+
+        if (RightEdge > LeftEdge) {     /* we're possibly drawing something */
+            ytop = max(Top, pbox->y1);
+            ybot = min(Bottom, pbox->y2);
+            if (ybot > ytop) {
+                skippix = LeftEdge - xInit;
+                skipglyph = 0;
+                while (skippix >= infoRec->GlyphInfo[skipglyph].end)
+                    skipglyph++;
+
+                skippix = RightEdge - xInit;
+                n = 0;
+                i = skipglyph;
+                while ((i < nglyph) && (skippix > infoRec->GlyphInfo[i].start)) {
+                    i++;
+                    n++;
+                }
+
+                if (n)
+                    (*infoRec->NonTEGlyphRenderer) (pScrn,
+                                                    xInit, yInit, n,
+                                                    infoRec->GlyphInfo +
+                                                    skipglyph, pbox, fg, GXcopy,
+                                                    planemask);
+            }
+        }
+
+        nbox--;
+        pbox++;
+    }
+}
+
+static int
+PolyGlyphBltNonTEColorExpansion(ScrnInfoPtr pScrn,
+                                int xInit, int yInit,
+                                FontPtr font,
+                                int fg, int rop,
+                                unsigned planemask,
+                                RegionPtr cclip,
+                                int nglyph,
+                                unsigned char *gBase, CharInfoPtr * ppci)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int skippix, skipglyph, width, n, i;
+    int Left, Right, Top, Bottom;
+    int LeftEdge, RightEdge;
+    int nbox = RegionNumRects(cclip);
+    BoxPtr pbox = RegionRects(cclip);
+
+    width = CollectCharacterInfo(infoRec->GlyphInfo, nglyph, ppci, font);
+
+    if (!nbox)
+        return width;
+
+    if ((infoRec->WriteBitmap) && (rop == GXcopy) && (nglyph > 1) &&
+        ((FONTMAXBOUNDS(font, rightSideBearing) -
+          FONTMINBOUNDS(font, leftSideBearing)) <= 32)) {
+
+        PolyGlyphBltAsSingleBitmap(pScrn, nglyph, font,
+                                   xInit, yInit, nbox, pbox,
+                                   fg, rop, planemask);
+
+        return width;
+    }
+
+    /* compute an approximate but covering bounding box */
+    Left = xInit + infoRec->GlyphInfo[0].start;
+    Right = xInit + infoRec->GlyphInfo[nglyph - 1].end;
+    Top = yInit - FONTMAXBOUNDS(font, ascent);
+    Bottom = yInit + FONTMAXBOUNDS(font, descent);
+
+    /* get into the first band that may contain part of our string */
+    while (nbox && (Top >= pbox->y2)) {
+        pbox++;
+        nbox--;
+    }
+
+    /* stop when the lower edge of the box is beyond our string */
+    while (nbox && (Bottom >= pbox->y1)) {
+        LeftEdge = max(Left, pbox->x1);
+        RightEdge = min(Right, pbox->x2);
+
+        if (RightEdge > LeftEdge) {     /* we're possibly drawing something */
+
+            skippix = LeftEdge - xInit;
+            skipglyph = 0;
+            while (skippix >= infoRec->GlyphInfo[skipglyph].end)
+                skipglyph++;
+
+            skippix = RightEdge - xInit;
+            n = 0;
+            i = skipglyph;
+            while ((i < nglyph) && (skippix > infoRec->GlyphInfo[i].start)) {
+                i++;
+                n++;
+            }
+
+            if (n)
+                (*infoRec->NonTEGlyphRenderer) (pScrn,
+                                                xInit, yInit, n,
+                                                infoRec->GlyphInfo + skipglyph,
+                                                pbox, fg, rop, planemask);
+        }
+
+        nbox--;
+        pbox++;
+    }
+    return width;
+}
+
+/* It is possible that the none of the glyphs passed to the 
+   NonTEGlyphRenderer will be drawn.  This function being called
+   indicates that part of the text string's bounding box is visible
+   but not necessarily that any of the characters are visible */
+
+void
+XAANonTEGlyphRenderer(ScrnInfoPtr pScrn,
+                      int x, int y, int n,
+                      NonTEGlyphPtr glyphs,
+                      BoxPtr pbox, int fg, int rop, unsigned int planemask)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int x1, x2, y1, y2, i, w, h, skipleft, skiptop;
+    unsigned char *src;
+
+    for (i = 0; i < n; i++, glyphs++) {
+        x1 = x + glyphs->start;
+        x2 = x + glyphs->end;
+        y1 = y - glyphs->yoff;
+        y2 = y1 + glyphs->height;
+
+        if (y1 < pbox->y1) {
+            skiptop = pbox->y1 - y1;
+            y1 = pbox->y1;
+        }
+        else
+            skiptop = 0;
+        if (y2 > pbox->y2)
+            y2 = pbox->y2;
+        h = y2 - y1;
+        if (h <= 0)
+            continue;
+
+        if (x1 < pbox->x1) {
+            skipleft = pbox->x1 - x1;
+            x1 = pbox->x1;
+        }
+        else
+            skipleft = 0;
+        if (x2 > pbox->x2)
+            x2 = pbox->x2;
+
+        w = x2 - x1;
+
+        if (w > 0) {
+            src = glyphs->bits + (skiptop * glyphs->srcwidth);
+
+            if (skipleft) {
+                src += (skipleft >> 5) << 2;
+                skipleft &= 31;
+            }
+
+            (*infoRec->WriteBitmap) (pScrn, x1, y1, w, h, src,
+                                     glyphs->srcwidth, skipleft, fg, -1, rop,
+                                     planemask);
+        }
+    }
+
+}
diff --git a/hw/xfree86/xaa/xaaOffscreen.c b/hw/xfree86/xaa/xaaOffscreen.c
new file mode 100644
index 000000000..3f3a2bb15
--- /dev/null
+++ b/hw/xfree86/xaa/xaaOffscreen.c
@@ -0,0 +1,163 @@
+
+/*
+   Copyright (c) 1999 -  The XFree86 Project Inc.
+
+   Written by Mark Vojkovich
+
+*/
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include "pixmapstr.h"
+#include "windowstr.h"
+#include "xf86str.h"
+#include "mi.h"
+#include "miline.h"
+#include "xaa.h"
+#include "xaalocal.h"
+#include "xaawrap.h"
+#include "xf86fbman.h"
+#include "servermd.h"
+
+void
+XAAMoveOutOffscreenPixmaps(ScreenPtr pScreen)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
+    PixmapLinkPtr pLink = infoRec->OffscreenPixmaps;
+    XAAPixmapPtr pPriv;
+
+    while (pLink) {
+        pPriv = XAA_GET_PIXMAP_PRIVATE(pLink->pPix);
+        pLink->area = pPriv->offscreenArea;
+        XAAMoveOutOffscreenPixmap(pLink->pPix);
+        pLink = pLink->next;
+    }
+}
+
+void
+XAAMoveInOffscreenPixmaps(ScreenPtr pScreen)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
+    PixmapLinkPtr pLink = infoRec->OffscreenPixmaps;
+    PixmapPtr pPix, pScreenPix, tmpPix;
+    void *data;
+    XAAPixmapPtr pPriv;
+    GCPtr pGC;
+    FBAreaPtr area;
+
+    pScreenPix = (*pScreen->GetScreenPixmap) (pScreen);
+
+    while (pLink) {
+        pPix = pLink->pPix;
+        pPriv = XAA_GET_PIXMAP_PRIVATE(pPix);
+        area = pLink->area;
+
+        data = pPix->devPrivate.ptr;
+        tmpPix = GetScratchPixmapHeader(pScreen,
+                                        pPix->drawable.width,
+                                        pPix->drawable.height,
+                                        pPix->drawable.depth,
+                                        pPix->drawable.bitsPerPixel,
+                                        pPix->devKind, data);
+
+        pPriv->freeData = FALSE;
+
+        pPix->drawable.x = area->box.x1;
+        pPix->drawable.y = area->box.y1;
+        pPix->devKind = pScreenPix->devKind;
+        pPix->devPrivate.ptr = pScreenPix->devPrivate.ptr;
+        pPix->drawable.bitsPerPixel = infoRec->pScrn->bitsPerPixel;
+        pPix->drawable.serialNumber = NEXT_SERIAL_NUMBER;
+
+        if (!tmpPix) {
+            pPriv->offscreenArea = area;
+            free(data);
+            pLink = pLink->next;
+            continue;
+        }
+
+        pGC = GetScratchGC(pPix->drawable.depth, pScreen);
+        ValidateGC((DrawablePtr) pPix, pGC);
+
+        (*pGC->ops->CopyArea) ((DrawablePtr) tmpPix, (DrawablePtr) pPix, pGC,
+                               0, 0, pPix->drawable.width,
+                               pPix->drawable.height, 0, 0);
+
+        free(data);
+        tmpPix->devPrivate.ptr = NULL;
+
+        FreeScratchGC(pGC);
+        FreeScratchPixmapHeader(tmpPix);
+
+        pPriv->offscreenArea = area;
+        pLink->area = NULL;
+        pLink = pLink->next;
+    }
+}
+
+void
+XAARemoveAreaCallback(FBAreaPtr area)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(area->pScreen);
+    PixmapPtr pPix = (PixmapPtr) area->devPrivate.ptr;
+    XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pPix);
+
+    XAAMoveOutOffscreenPixmap(pPix);
+
+    pPriv->flags &= ~OFFSCREEN;
+
+    DELIST_OFFSCREEN_PIXMAP(pPix);
+}
+
+void
+XAAMoveOutOffscreenPixmap(PixmapPtr pPix)
+{
+    ScreenPtr pScreen = pPix->drawable.pScreen;
+    XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pPix);
+    int width, height, devKind, bitsPerPixel;
+    PixmapPtr tmpPix;
+    unsigned char *data;
+    GCPtr pGC;
+
+    width = pPix->drawable.width;
+    height = pPix->drawable.height;
+    bitsPerPixel = pPix->drawable.bitsPerPixel;
+
+    devKind = BitmapBytePad(width * bitsPerPixel);
+    if (!(data = malloc(devKind * height)))
+        FatalError("Out of memory\n");
+
+    tmpPix = GetScratchPixmapHeader(pScreen, width, height,
+                                    pPix->drawable.depth, bitsPerPixel, devKind,
+                                    data);
+    if (!tmpPix) {
+        free(data);
+        FatalError("Out of memory\n");
+    }
+
+    pGC = GetScratchGC(pPix->drawable.depth, pScreen);
+    ValidateGC((DrawablePtr) tmpPix, pGC);
+
+    (*pGC->ops->CopyArea) ((DrawablePtr) pPix, (DrawablePtr) tmpPix,
+                           pGC, 0, 0, width, height, 0, 0);
+
+    FreeScratchGC(pGC);
+    FreeScratchPixmapHeader(tmpPix);
+
+    pPix->drawable.x = 0;
+    pPix->drawable.y = 0;
+    pPix->devKind = devKind;
+    pPix->devPrivate.ptr = data;
+    pPix->drawable.serialNumber = NEXT_SERIAL_NUMBER;
+
+    pPriv->offscreenArea = NULL;
+    pPriv->freeData = TRUE;
+}
diff --git a/hw/xfree86/xaa/xaaOverlay.c b/hw/xfree86/xaa/xaaOverlay.c
new file mode 100644
index 000000000..25d18da96
--- /dev/null
+++ b/hw/xfree86/xaa/xaaOverlay.c
@@ -0,0 +1,122 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include "windowstr.h"
+#include "xf86str.h"
+#include "xaa.h"
+#include "xaalocal.h"
+#include "xaawrap.h"
+#include "gcstruct.h"
+#include "pixmapstr.h"
+#include "mioverlay.h"
+
+#ifdef PANORAMIX
+#include "panoramiX.h"
+#include "panoramiXsrv.h"
+#endif
+
+static void
+XAACopyWindow8_32(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
+{
+    DDXPointPtr pptSrc, ppt;
+    RegionRec rgnDst;
+    BoxPtr pbox;
+    int dx, dy, nbox;
+    WindowPtr pwinRoot;
+    ScreenPtr pScreen = pWin->drawable.pScreen;
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_DRAWABLE((&pWin->drawable));
+    Bool doUnderlay = miOverlayCopyUnderlay(pScreen);
+    RegionPtr borderClip = &pWin->borderClip;
+    Bool freeReg = FALSE;
+
+    if (!infoRec->pScrn->vtSema || !infoRec->ScreenToScreenBitBlt ||
+        (infoRec->ScreenToScreenBitBltFlags & NO_PLANEMASK)) {
+        XAA_SCREEN_PROLOGUE(pScreen, CopyWindow);
+        if (infoRec->pScrn->vtSema && infoRec->NeedToSync) {
+            (*infoRec->Sync) (infoRec->pScrn);
+            infoRec->NeedToSync = FALSE;
+        }
+        (*pScreen->CopyWindow) (pWin, ptOldOrg, prgnSrc);
+        XAA_SCREEN_EPILOGUE(pScreen, CopyWindow, XAACopyWindow8_32);
+        return;
+    }
+
+    pwinRoot = pScreen->root;
+
+    if (doUnderlay)
+        freeReg = miOverlayCollectUnderlayRegions(pWin, &borderClip);
+
+    RegionNull(&rgnDst);
+
+    dx = ptOldOrg.x - pWin->drawable.x;
+    dy = ptOldOrg.y - pWin->drawable.y;
+    RegionTranslate(prgnSrc, -dx, -dy);
+    RegionIntersect(&rgnDst, borderClip, prgnSrc);
+
+    pbox = RegionRects(&rgnDst);
+    nbox = RegionNumRects(&rgnDst);
+    if (!nbox || !(pptSrc = (DDXPointPtr) malloc(nbox * sizeof(DDXPointRec)))) {
+        RegionUninit(&rgnDst);
+        return;
+    }
+    ppt = pptSrc;
+
+    while (nbox--) {
+        ppt->x = pbox->x1 + dx;
+        ppt->y = pbox->y1 + dy;
+        ppt++;
+        pbox++;
+    }
+
+    infoRec->ScratchGC.planemask = doUnderlay ? 0x00ffffff : 0xff000000;
+    infoRec->ScratchGC.alu = GXcopy;
+
+    XAADoBitBlt((DrawablePtr) pwinRoot, (DrawablePtr) pwinRoot,
+                &(infoRec->ScratchGC), &rgnDst, pptSrc);
+
+    free(pptSrc);
+    RegionUninit(&rgnDst);
+    if (freeReg)
+        RegionDestroy(borderClip);
+}
+
+static void
+XAASetColorKey8_32(ScreenPtr pScreen, int nbox, BoxPtr pbox)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
+    ScrnInfoPtr pScrn = infoRec->pScrn;
+
+    /* I'm counting on writes being clipped away while switched away.
+       If this isn't going to be true then I need to be wrapping instead. */
+    if (!infoRec->pScrn->vtSema)
+        return;
+
+    (*infoRec->FillSolidRects) (pScrn, pScrn->colorKey << 24, GXcopy,
+                                0xff000000, nbox, pbox);
+
+    SET_SYNC_FLAG(infoRec);
+}
+
+void
+XAASetupOverlay8_32Planar(ScreenPtr pScreen)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
+    int i;
+
+    pScreen->CopyWindow = XAACopyWindow8_32;
+
+    if (!(infoRec->FillSolidRectsFlags & NO_PLANEMASK))
+        miOverlaySetTransFunction(pScreen, XAASetColorKey8_32);
+
+    infoRec->FullPlanemask = ~0;
+    for (i = 0; i < 32; i++)    /* haven't thought about this much */
+        infoRec->FullPlanemasks[i] = ~0;
+}
diff --git a/hw/xfree86/xaa/xaaOverlayDF.c b/hw/xfree86/xaa/xaaOverlayDF.c
new file mode 100644
index 000000000..a8b726222
--- /dev/null
+++ b/hw/xfree86/xaa/xaaOverlayDF.c
@@ -0,0 +1,906 @@
+/*
+   Copyright (c) 1999 - The XFree86 Project Inc.
+
+   Written by Mark Vojkovich
+*/
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include "pixmapstr.h"
+#include "windowstr.h"
+#include "xf86str.h"
+#include "mi.h"
+#include "miline.h"
+#include "xaa.h"
+#include "xaalocal.h"
+#include "xaawrap.h"
+#include "servermd.h"
+
+/* Screen funcs */
+
+static void XAAOverCopyWindow(WindowPtr, DDXPointRec, RegionPtr);
+static void XAAOverWindowExposures(WindowPtr, RegionPtr);
+
+static int XAAOverStippledFillChooser(GCPtr);
+static int XAAOverOpaqueStippledFillChooser(GCPtr);
+static int XAAOverTiledFillChooser(GCPtr);
+
+/* GC funcs */
+
+static RegionPtr XAAOverCopyArea(DrawablePtr, DrawablePtr, GC *,
+                                 int, int, int, int, int, int);
+static RegionPtr XAAOverCopyPlane(DrawablePtr, DrawablePtr, GCPtr,
+                                  int, int, int, int, int, int, unsigned long);
+static void XAAOverPushPixelsSolid(GCPtr, PixmapPtr, DrawablePtr, int,
+                                   int, int, int);
+static void XAAOverPolyFillRectSolid(DrawablePtr, GCPtr, int, xRectangle *);
+static void XAAOverPolyFillRectStippled(DrawablePtr, GCPtr, int, xRectangle *);
+static void XAAOverPolyFillRectOpaqueStippled(DrawablePtr, GCPtr,
+                                              int, xRectangle *);
+static void XAAOverPolyFillRectTiled(DrawablePtr, GCPtr, int, xRectangle *);
+static void XAAOverFillSpansSolid(DrawablePtr, GCPtr, int, DDXPointPtr,
+                                  int *, int);
+static void XAAOverFillSpansStippled(DrawablePtr, GCPtr, int, DDXPointPtr,
+                                     int *, int);
+static void XAAOverFillSpansOpaqueStippled(DrawablePtr, GCPtr, int,
+                                           DDXPointPtr, int *, int);
+static void XAAOverFillSpansTiled(DrawablePtr, GCPtr, int, DDXPointPtr,
+                                  int *, int);
+static int XAAOverPolyText8TE(DrawablePtr, GCPtr, int, int, int, char *);
+static int XAAOverPolyText16TE(DrawablePtr, GCPtr, int, int, int,
+                               unsigned short *);
+static void XAAOverImageText8TE(DrawablePtr, GCPtr, int, int, int, char *);
+static void XAAOverImageText16TE(DrawablePtr, GCPtr, int, int, int,
+                                 unsigned short *);
+static void XAAOverImageGlyphBltTE(DrawablePtr, GCPtr, int, int,
+                                   unsigned int, CharInfoPtr *, void*);
+static void XAAOverPolyGlyphBltTE(DrawablePtr, GCPtr, int, int,
+                                  unsigned int, CharInfoPtr *, void*);
+static int XAAOverPolyText8NonTE(DrawablePtr, GCPtr, int, int, int, char *);
+static int XAAOverPolyText16NonTE(DrawablePtr, GCPtr, int, int, int,
+                                  unsigned short *);
+static void XAAOverImageText8NonTE(DrawablePtr, GCPtr, int, int, int, char *);
+static void XAAOverImageText16NonTE(DrawablePtr, GCPtr, int, int, int,
+                                    unsigned short *);
+static void XAAOverImageGlyphBltNonTE(DrawablePtr, GCPtr, int, int,
+                                      unsigned int, CharInfoPtr *, void*);
+static void XAAOverPolyGlyphBltNonTE(DrawablePtr, GCPtr, int, int,
+                                     unsigned int, CharInfoPtr *, void*);
+static void XAAOverPolyRectangleThinSolid(DrawablePtr, GCPtr, int,
+                                          xRectangle *);
+static void XAAOverPolylinesWideSolid(DrawablePtr, GCPtr, int, int,
+                                      DDXPointPtr);
+static void XAAOverPolylinesThinSolid(DrawablePtr, GCPtr, int, int,
+                                      DDXPointPtr);
+static void XAAOverPolySegmentThinSolid(DrawablePtr, GCPtr, int, xSegment *);
+static void XAAOverPolylinesThinDashed(DrawablePtr, GCPtr, int, int,
+                                       DDXPointPtr);
+static void XAAOverPolySegmentThinDashed(DrawablePtr, GCPtr, int, xSegment *);
+static void XAAOverFillPolygonSolid(DrawablePtr, GCPtr, int, int, int,
+                                    DDXPointPtr);
+static void XAAOverFillPolygonStippled(DrawablePtr, GCPtr, int, int, int,
+                                       DDXPointPtr);
+static void XAAOverFillPolygonOpaqueStippled(DrawablePtr, GCPtr, int, int, int,
+                                             DDXPointPtr);
+static void XAAOverFillPolygonTiled(DrawablePtr, GCPtr, int, int, int,
+                                    DDXPointPtr);
+static void XAAOverPolyFillArcSolid(DrawablePtr, GCPtr, int, xArc *);
+static void XAAOverPutImage(DrawablePtr, GCPtr, int, int, int, int, int,
+                            int, int, char *);
+
+typedef struct {
+    ScrnInfoPtr pScrn;
+    DepthChangeFuncPtr callback;
+    int currentDepth;
+/* GC funcs */
+    RegionPtr (*CopyArea) (DrawablePtr, DrawablePtr, GC *,
+                           int, int, int, int, int, int);
+    RegionPtr (*CopyPlane) (DrawablePtr, DrawablePtr, GCPtr,
+                            int, int, int, int, int, int, unsigned long);
+    void (*PushPixelsSolid) (GCPtr, PixmapPtr, DrawablePtr, int, int, int, int);
+    void (*PolyFillRectSolid) (DrawablePtr, GCPtr, int, xRectangle *);
+    void (*PolyFillRectStippled) (DrawablePtr, GCPtr, int, xRectangle *);
+    void (*PolyFillRectOpaqueStippled) (DrawablePtr, GCPtr, int, xRectangle *);
+    void (*PolyFillRectTiled) (DrawablePtr, GCPtr, int, xRectangle *);
+    void (*FillSpansSolid) (DrawablePtr, GCPtr, int, DDXPointPtr, int *, int);
+    void (*FillSpansStippled) (DrawablePtr, GCPtr, int, DDXPointPtr, int *,
+                               int);
+    void (*FillSpansOpaqueStippled) (DrawablePtr, GCPtr, int, DDXPointPtr,
+                                     int *, int);
+    void (*FillSpansTiled) (DrawablePtr, GCPtr, int, DDXPointPtr, int *, int);
+    int (*PolyText8TE) (DrawablePtr, GCPtr, int, int, int, char *);
+    int (*PolyText16TE) (DrawablePtr, GCPtr, int, int, int, unsigned short *);
+    void (*ImageText8TE) (DrawablePtr, GCPtr, int, int, int, char *);
+    void (*ImageText16TE) (DrawablePtr, GCPtr, int, int, int, unsigned short *);
+    void (*ImageGlyphBltTE) (DrawablePtr, GCPtr, int, int, unsigned int,
+                             CharInfoPtr *, void*);
+    void (*PolyGlyphBltTE) (DrawablePtr, GCPtr, int, int, unsigned int,
+                            CharInfoPtr *, void*);
+    int (*PolyText8NonTE) (DrawablePtr, GCPtr, int, int, int, char *);
+    int (*PolyText16NonTE) (DrawablePtr, GCPtr, int, int, int,
+                            unsigned short *);
+    void (*ImageText8NonTE) (DrawablePtr, GCPtr, int, int, int, char *);
+    void (*ImageText16NonTE) (DrawablePtr, GCPtr, int, int, int,
+                              unsigned short *);
+    void (*ImageGlyphBltNonTE) (DrawablePtr, GCPtr, int, int, unsigned int,
+                                CharInfoPtr *, void*);
+    void (*PolyGlyphBltNonTE) (DrawablePtr, GCPtr, int, int, unsigned int,
+                               CharInfoPtr *, void*);
+    void (*PolyRectangleThinSolid) (DrawablePtr, GCPtr, int, xRectangle *);
+    void (*PolylinesWideSolid) (DrawablePtr, GCPtr, int, int, DDXPointPtr);
+
+    void (*PolylinesThinSolid) (DrawablePtr, GCPtr, int, int, DDXPointPtr);
+    void (*PolySegmentThinSolid) (DrawablePtr, GCPtr, int, xSegment *);
+    void (*PolylinesThinDashed) (DrawablePtr, GCPtr, int, int, DDXPointPtr);
+    void (*PolySegmentThinDashed) (DrawablePtr, GCPtr, int, xSegment *);
+    void (*FillPolygonSolid) (DrawablePtr, GCPtr, int, int, int, DDXPointPtr);
+    void (*FillPolygonStippled) (DrawablePtr, GCPtr, int, int, int,
+                                 DDXPointPtr);
+    void (*FillPolygonOpaqueStippled) (DrawablePtr, GCPtr, int, int, int,
+                                       DDXPointPtr);
+    void (*FillPolygonTiled) (DrawablePtr, GCPtr, int, int, int, DDXPointPtr);
+    void (*PolyFillArcSolid) (DrawablePtr, GCPtr, int, xArc *);
+    void (*PutImage) (DrawablePtr, GCPtr, int, int, int, int, int, int,
+                      int, char *);
+    int (*StippledFillChooser) (GCPtr);
+    int (*OpaqueStippledFillChooser) (GCPtr);
+    int (*TiledFillChooser) (GCPtr);
+} XAAOverlayRec, *XAAOverlayPtr;
+
+static DevPrivateKeyRec XAAOverlayKeyRec;
+
+#define XAAOverlayKey (&XAAOverlayKeyRec)
+
+#define GET_OVERLAY_PRIV(pScreen) \
+    (XAAOverlayPtr)dixLookupPrivate(&(pScreen)->devPrivates, XAAOverlayKey)
+
+#define SWITCH_DEPTH(d) \
+   if(pOverPriv->currentDepth != d) { \
+	(*pOverPriv->callback)(pOverPriv->pScrn, d); \
+	pOverPriv->currentDepth = d; \
+   }
+
+Bool
+XAAInitDualFramebufferOverlay(ScreenPtr pScreen, DepthChangeFuncPtr callback)
+{
+    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
+    XAAOverlayPtr pOverPriv;
+
+    if (!dixRegisterPrivateKey(&XAAOverlayKeyRec, PRIVATE_SCREEN, 0))
+        return FALSE;
+
+    if (!(pOverPriv = malloc(sizeof(XAAOverlayRec))))
+        return FALSE;
+
+    dixSetPrivate(&pScreen->devPrivates, XAAOverlayKey, pOverPriv);
+
+    pOverPriv->pScrn = pScrn;
+    pOverPriv->callback = callback;
+    pOverPriv->currentDepth = -1;
+
+    /* Overwrite key screen functions.  The XAA core will clean up */
+
+    pScreen->CopyWindow = XAAOverCopyWindow;
+    pScreen->WindowExposures = XAAOverWindowExposures;
+
+    pOverPriv->StippledFillChooser = infoRec->StippledFillChooser;
+    pOverPriv->OpaqueStippledFillChooser = infoRec->OpaqueStippledFillChooser;
+    pOverPriv->TiledFillChooser = infoRec->TiledFillChooser;
+
+    infoRec->StippledFillChooser = XAAOverStippledFillChooser;
+    infoRec->OpaqueStippledFillChooser = XAAOverOpaqueStippledFillChooser;
+    infoRec->TiledFillChooser = XAAOverTiledFillChooser;
+
+    /* wrap all XAA GC rendering */
+
+    pOverPriv->CopyArea = infoRec->CopyArea;
+    pOverPriv->CopyPlane = infoRec->CopyPlane;
+    pOverPriv->PushPixelsSolid = infoRec->PushPixelsSolid;
+    pOverPriv->PolyFillRectSolid = infoRec->PolyFillRectSolid;
+    pOverPriv->PolyFillRectStippled = infoRec->PolyFillRectStippled;
+    pOverPriv->PolyFillRectOpaqueStippled = infoRec->PolyFillRectOpaqueStippled;
+    pOverPriv->PolyFillRectTiled = infoRec->PolyFillRectTiled;
+    pOverPriv->FillSpansSolid = infoRec->FillSpansSolid;
+    pOverPriv->FillSpansStippled = infoRec->FillSpansStippled;
+    pOverPriv->FillSpansOpaqueStippled = infoRec->FillSpansOpaqueStippled;
+    pOverPriv->FillSpansTiled = infoRec->FillSpansTiled;
+    pOverPriv->PolyText8TE = infoRec->PolyText8TE;
+    pOverPriv->PolyText16TE = infoRec->PolyText16TE;
+    pOverPriv->ImageText8TE = infoRec->ImageText8TE;
+    pOverPriv->ImageText16TE = infoRec->ImageText16TE;
+    pOverPriv->ImageGlyphBltTE = infoRec->ImageGlyphBltTE;
+    pOverPriv->PolyGlyphBltTE = infoRec->PolyGlyphBltTE;
+    pOverPriv->PolyText8NonTE = infoRec->PolyText8NonTE;
+    pOverPriv->PolyText16NonTE = infoRec->PolyText16NonTE;
+    pOverPriv->ImageText8NonTE = infoRec->ImageText8NonTE;
+    pOverPriv->ImageText16NonTE = infoRec->ImageText16NonTE;
+    pOverPriv->ImageGlyphBltNonTE = infoRec->ImageGlyphBltNonTE;
+    pOverPriv->PolyGlyphBltNonTE = infoRec->PolyGlyphBltNonTE;
+    pOverPriv->PolyRectangleThinSolid = infoRec->PolyRectangleThinSolid;
+    pOverPriv->PolylinesWideSolid = infoRec->PolylinesWideSolid;
+    pOverPriv->PolylinesThinSolid = infoRec->PolylinesThinSolid;
+    pOverPriv->PolySegmentThinSolid = infoRec->PolySegmentThinSolid;
+    pOverPriv->PolylinesThinDashed = infoRec->PolylinesThinDashed;
+    pOverPriv->PolySegmentThinDashed = infoRec->PolySegmentThinDashed;
+    pOverPriv->FillPolygonSolid = infoRec->FillPolygonSolid;
+    pOverPriv->FillPolygonStippled = infoRec->FillPolygonStippled;
+    pOverPriv->FillPolygonOpaqueStippled = infoRec->FillPolygonOpaqueStippled;
+    pOverPriv->FillPolygonTiled = infoRec->FillPolygonTiled;
+    pOverPriv->PolyFillArcSolid = infoRec->PolyFillArcSolid;
+    pOverPriv->PutImage = infoRec->PutImage;
+
+    if (infoRec->CopyArea)
+        infoRec->CopyArea = XAAOverCopyArea;
+    if (infoRec->CopyPlane)
+        infoRec->CopyPlane = XAAOverCopyPlane;
+    if (infoRec->PushPixelsSolid)
+        infoRec->PushPixelsSolid = XAAOverPushPixelsSolid;
+    if (infoRec->PolyFillRectSolid)
+        infoRec->PolyFillRectSolid = XAAOverPolyFillRectSolid;
+    if (infoRec->PolyFillRectStippled)
+        infoRec->PolyFillRectStippled = XAAOverPolyFillRectStippled;
+    if (infoRec->PolyFillRectOpaqueStippled)
+        infoRec->PolyFillRectOpaqueStippled = XAAOverPolyFillRectOpaqueStippled;
+    if (infoRec->PolyFillRectTiled)
+        infoRec->PolyFillRectTiled = XAAOverPolyFillRectTiled;
+    if (infoRec->FillSpansSolid)
+        infoRec->FillSpansSolid = XAAOverFillSpansSolid;
+    if (infoRec->FillSpansStippled)
+        infoRec->FillSpansStippled = XAAOverFillSpansStippled;
+    if (infoRec->FillSpansOpaqueStippled)
+        infoRec->FillSpansOpaqueStippled = XAAOverFillSpansOpaqueStippled;
+    if (infoRec->FillSpansTiled)
+        infoRec->FillSpansTiled = XAAOverFillSpansTiled;
+    if (infoRec->PolyText8TE)
+        infoRec->PolyText8TE = XAAOverPolyText8TE;
+    if (infoRec->PolyText16TE)
+        infoRec->PolyText16TE = XAAOverPolyText16TE;
+    if (infoRec->ImageText8TE)
+        infoRec->ImageText8TE = XAAOverImageText8TE;
+    if (infoRec->ImageText16TE)
+        infoRec->ImageText16TE = XAAOverImageText16TE;
+    if (infoRec->ImageGlyphBltTE)
+        infoRec->ImageGlyphBltTE = XAAOverImageGlyphBltTE;
+    if (infoRec->PolyGlyphBltTE)
+        infoRec->PolyGlyphBltTE = XAAOverPolyGlyphBltTE;
+    if (infoRec->PolyText8NonTE)
+        infoRec->PolyText8NonTE = XAAOverPolyText8NonTE;
+    if (infoRec->PolyText16NonTE)
+        infoRec->PolyText16NonTE = XAAOverPolyText16NonTE;
+    if (infoRec->ImageText8NonTE)
+        infoRec->ImageText8NonTE = XAAOverImageText8NonTE;
+    if (infoRec->ImageText16NonTE)
+        infoRec->ImageText16NonTE = XAAOverImageText16NonTE;
+    if (infoRec->ImageGlyphBltNonTE)
+        infoRec->ImageGlyphBltNonTE = XAAOverImageGlyphBltNonTE;
+    if (infoRec->PolyGlyphBltNonTE)
+        infoRec->PolyGlyphBltNonTE = XAAOverPolyGlyphBltNonTE;
+    if (infoRec->PolyRectangleThinSolid)
+        infoRec->PolyRectangleThinSolid = XAAOverPolyRectangleThinSolid;
+    if (infoRec->PolylinesWideSolid)
+        infoRec->PolylinesWideSolid = XAAOverPolylinesWideSolid;
+    if (infoRec->PolylinesThinSolid)
+        infoRec->PolylinesThinSolid = XAAOverPolylinesThinSolid;
+    if (infoRec->PolySegmentThinSolid)
+        infoRec->PolySegmentThinSolid = XAAOverPolySegmentThinSolid;
+    if (infoRec->PolylinesThinDashed)
+        infoRec->PolylinesThinDashed = XAAOverPolylinesThinDashed;
+    if (infoRec->PolySegmentThinDashed)
+        infoRec->PolySegmentThinDashed = XAAOverPolySegmentThinDashed;
+    if (infoRec->FillPolygonSolid)
+        infoRec->FillPolygonSolid = XAAOverFillPolygonSolid;
+    if (infoRec->FillPolygonStippled)
+        infoRec->FillPolygonStippled = XAAOverFillPolygonStippled;
+    if (infoRec->FillPolygonOpaqueStippled)
+        infoRec->FillPolygonOpaqueStippled = XAAOverFillPolygonOpaqueStippled;
+    if (infoRec->FillPolygonTiled)
+        infoRec->FillPolygonTiled = XAAOverFillPolygonTiled;
+    if (infoRec->PolyFillArcSolid)
+        infoRec->PolyFillArcSolid = XAAOverPolyFillArcSolid;
+    if (infoRec->PutImage)
+        infoRec->PutImage = XAAOverPutImage;
+
+    return TRUE;
+}
+
+/***********************  Screen functions ************************/
+
+void
+XAAOverCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
+{
+    ScreenPtr pScreen = pWin->drawable.pScreen;
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pScreen);
+    ScrnInfoPtr pScrn = infoRec->pScrn;
+    DDXPointPtr ppt, pptSrc;
+    RegionRec rgnDst;
+    BoxPtr pbox;
+    int i, nbox, dx, dy;
+    WindowPtr pRoot = pScreen->root;
+
+    if (!pScrn->vtSema || !infoRec->ScreenToScreenBitBlt) {
+        XAA_SCREEN_PROLOGUE(pScreen, CopyWindow);
+        if (pScrn->vtSema && infoRec->NeedToSync) {
+            (*infoRec->Sync) (pScrn);
+            infoRec->NeedToSync = FALSE;
+        }
+        (*pScreen->CopyWindow) (pWin, ptOldOrg, prgnSrc);
+        XAA_SCREEN_EPILOGUE(pScreen, CopyWindow, XAAOverCopyWindow);
+        return;
+    }
+
+    infoRec->ScratchGC.alu = GXcopy;
+    infoRec->ScratchGC.planemask = ~0;
+
+    RegionNull(&rgnDst);
+
+    dx = ptOldOrg.x - pWin->drawable.x;
+    dy = ptOldOrg.y - pWin->drawable.y;
+    RegionTranslate(prgnSrc, -dx, -dy);
+    RegionIntersect(&rgnDst, &pWin->borderClip, prgnSrc);
+
+    nbox = RegionNumRects(&rgnDst);
+    if (nbox && (pptSrc = (DDXPointPtr) malloc(nbox * sizeof(DDXPointRec)))) {
+
+        pbox = RegionRects(&rgnDst);
+        for (i = nbox, ppt = pptSrc; i--; ppt++, pbox++) {
+            ppt->x = pbox->x1 + dx;
+            ppt->y = pbox->y1 + dy;
+        }
+
+        SWITCH_DEPTH(8);
+        XAADoBitBlt((DrawablePtr) pRoot, (DrawablePtr) pRoot,
+                    &(infoRec->ScratchGC), &rgnDst, pptSrc);
+
+        if (pWin->drawable.bitsPerPixel != 8) {
+            SWITCH_DEPTH(pScrn->depth);
+            XAADoBitBlt((DrawablePtr) pRoot, (DrawablePtr) pRoot,
+                        &(infoRec->ScratchGC), &rgnDst, pptSrc);
+        }
+
+        free(pptSrc);
+    }
+
+    RegionUninit(&rgnDst);
+
+    if (pWin->drawable.depth == 8) {
+        RegionNull(&rgnDst);
+        miSegregateChildren(pWin, &rgnDst, pScrn->depth);
+        if (RegionNotEmpty(&rgnDst)) {
+            RegionIntersect(&rgnDst, &rgnDst, prgnSrc);
+            nbox = RegionNumRects(&rgnDst);
+            if (nbox &&
+                (pptSrc = (DDXPointPtr) malloc(nbox * sizeof(DDXPointRec)))) {
+
+                pbox = RegionRects(&rgnDst);
+                for (i = nbox, ppt = pptSrc; i--; ppt++, pbox++) {
+                    ppt->x = pbox->x1 + dx;
+                    ppt->y = pbox->y1 + dy;
+                }
+
+                SWITCH_DEPTH(pScrn->depth);
+                XAADoBitBlt((DrawablePtr) pRoot, (DrawablePtr) pRoot,
+                            &(infoRec->ScratchGC), &rgnDst, pptSrc);
+                free(pptSrc);
+            }
+        }
+        RegionUninit(&rgnDst);
+    }
+}
+
+void
+XAAOverWindowExposures(WindowPtr pWin, RegionPtr pReg)
+{
+    ScreenPtr pScreen = pWin->drawable.pScreen;
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
+
+    if ((pWin->drawable.bitsPerPixel != 8) && infoRec->pScrn->vtSema) {
+        if (RegionNumRects(pReg) && infoRec->FillSolidRects) {
+            XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pScreen);
+
+            SWITCH_DEPTH(8);
+            (*infoRec->FillSolidRects) (infoRec->pScrn,
+                                        infoRec->pScrn->colorKey, GXcopy, ~0,
+                                        RegionNumRects(pReg),
+                                        RegionRects(pReg));
+            miWindowExposures(pWin, pReg);
+            return;
+        }
+        else if (infoRec->NeedToSync) {
+            (*infoRec->Sync) (infoRec->pScrn);
+            infoRec->NeedToSync = FALSE;
+        }
+    }
+
+    XAA_SCREEN_PROLOGUE(pScreen, WindowExposures);
+    (*pScreen->WindowExposures) (pWin, pReg);
+    XAA_SCREEN_EPILOGUE(pScreen, WindowExposures, XAAOverWindowExposures);
+}
+
+/*********************  Choosers *************************/
+
+static int
+XAAOverStippledFillChooser(GCPtr pGC)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+    int ret;
+
+    ret = (*pOverPriv->StippledFillChooser) (pGC);
+
+    if ((pGC->depth == 8) && ((ret == DO_COLOR_8x8) || (ret == DO_CACHE_BLT))) {
+        ret = 0;
+    }
+
+    return ret;
+}
+
+static int
+XAAOverOpaqueStippledFillChooser(GCPtr pGC)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+    int ret;
+
+    ret = (*pOverPriv->OpaqueStippledFillChooser) (pGC);
+
+    if ((pGC->depth == 8) && ((ret == DO_COLOR_8x8) || (ret == DO_CACHE_BLT))) {
+        ret = 0;
+    }
+
+    return ret;
+}
+
+static int
+XAAOverTiledFillChooser(GCPtr pGC)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+    int ret;
+
+    ret = (*pOverPriv->TiledFillChooser) (pGC);
+
+    if ((pGC->depth == 8) && ((ret == DO_COLOR_8x8) || (ret == DO_CACHE_BLT))) {
+        ret = 0;
+    }
+
+    return ret;
+}
+
+/**************************** GC Functions **************************/
+
+static RegionPtr
+XAAOverCopyArea(DrawablePtr pSrc,
+                DrawablePtr pDst,
+                GC * pGC,
+                int srcx, int srcy, int width, int height, int dstx, int dsty)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    return (*pOverPriv->CopyArea) (pSrc, pDst,
+                                   pGC, srcx, srcy, width, height, dstx, dsty);
+}
+
+static RegionPtr
+XAAOverCopyPlane(DrawablePtr pSrc,
+                 DrawablePtr pDst,
+                 GCPtr pGC,
+                 int srcx, int srcy,
+                 int width, int height,
+                 int dstx, int dsty, unsigned long bitPlane)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    return (*pOverPriv->CopyPlane) (pSrc, pDst,
+                                    pGC, srcx, srcy, width, height, dstx, dsty,
+                                    bitPlane);
+
+}
+
+static void
+XAAOverPushPixelsSolid(GCPtr pGC,
+                       PixmapPtr pBitMap,
+                       DrawablePtr pDraw, int dx, int dy, int xOrg, int yOrg)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->PushPixelsSolid) (pGC, pBitMap, pDraw, dx, dy, xOrg, yOrg);
+}
+
+static void
+XAAOverPolyFillRectSolid(DrawablePtr pDraw,
+                         GCPtr pGC, int nrectFill, xRectangle *prectInit)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->PolyFillRectSolid) (pDraw, pGC, nrectFill, prectInit);
+}
+
+static void
+XAAOverPolyFillRectStippled(DrawablePtr pDraw,
+                            GCPtr pGC, int nrectFill, xRectangle *prectInit)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->PolyFillRectStippled) (pDraw, pGC, nrectFill, prectInit);
+}
+
+static void
+XAAOverPolyFillRectOpaqueStippled(DrawablePtr pDraw,
+                                  GCPtr pGC,
+                                  int nrectFill, xRectangle *prectInit)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->PolyFillRectOpaqueStippled) (pDraw, pGC, nrectFill, prectInit);
+}
+
+static void
+XAAOverPolyFillRectTiled(DrawablePtr pDraw,
+                         GCPtr pGC, int nrectFill, xRectangle *prectInit)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->PolyFillRectTiled) (pDraw, pGC, nrectFill, prectInit);
+}
+
+static void
+XAAOverFillSpansSolid(DrawablePtr pDraw,
+                      GCPtr pGC,
+                      int nInit, DDXPointPtr ppt, int *pwidth, int fSorted)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->FillSpansSolid) (pDraw, pGC, nInit, ppt, pwidth, fSorted);
+}
+
+static void
+XAAOverFillSpansStippled(DrawablePtr pDraw,
+                         GCPtr pGC,
+                         int nInit, DDXPointPtr ppt, int *pwidth, int fSorted)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->FillSpansStippled) (pDraw, pGC, nInit, ppt, pwidth, fSorted);
+}
+
+static void
+XAAOverFillSpansOpaqueStippled(DrawablePtr pDraw,
+                               GCPtr pGC,
+                               int nInit,
+                               DDXPointPtr ppt, int *pwidth, int fSorted)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->FillSpansOpaqueStippled) (pDraw, pGC, nInit, ppt, pwidth,
+                                           fSorted);
+}
+
+static void
+XAAOverFillSpansTiled(DrawablePtr pDraw,
+                      GCPtr pGC,
+                      int nInit, DDXPointPtr ppt, int *pwidth, int fSorted)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->FillSpansTiled) (pDraw, pGC, nInit, ppt, pwidth, fSorted);
+}
+
+static int
+XAAOverPolyText8TE(DrawablePtr pDraw,
+                   GCPtr pGC, int x, int y, int count, char *chars)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    return (*pOverPriv->PolyText8TE) (pDraw, pGC, x, y, count, chars);
+}
+
+static int
+XAAOverPolyText16TE(DrawablePtr pDraw,
+                    GCPtr pGC, int x, int y, int count, unsigned short *chars)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    return (*pOverPriv->PolyText16TE) (pDraw, pGC, x, y, count, chars);
+}
+
+static void
+XAAOverImageText8TE(DrawablePtr pDraw,
+                    GCPtr pGC, int x, int y, int count, char *chars)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->ImageText8TE) (pDraw, pGC, x, y, count, chars);
+}
+
+static void
+XAAOverImageText16TE(DrawablePtr pDraw,
+                     GCPtr pGC, int x, int y, int count, unsigned short *chars)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->ImageText16TE) (pDraw, pGC, x, y, count, chars);
+}
+
+static void
+XAAOverImageGlyphBltTE(DrawablePtr pDraw,
+                       GCPtr pGC,
+                       int xInit, int yInit,
+                       unsigned int nglyph,
+                       CharInfoPtr * ppci, void *pglyphBase)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->ImageGlyphBltTE) (pDraw, pGC, xInit, yInit, nglyph, ppci,
+                                   pglyphBase);
+}
+
+static void
+XAAOverPolyGlyphBltTE(DrawablePtr pDraw,
+                      GCPtr pGC,
+                      int xInit, int yInit,
+                      unsigned int nglyph,
+                      CharInfoPtr * ppci, void *pglyphBase)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->PolyGlyphBltTE) (pDraw, pGC, xInit, yInit, nglyph, ppci,
+                                  pglyphBase);
+}
+
+static int
+XAAOverPolyText8NonTE(DrawablePtr pDraw,
+                      GCPtr pGC, int x, int y, int count, char *chars)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    return (*pOverPriv->PolyText8NonTE) (pDraw, pGC, x, y, count, chars);
+}
+
+static int
+XAAOverPolyText16NonTE(DrawablePtr pDraw,
+                       GCPtr pGC,
+                       int x, int y, int count, unsigned short *chars)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    return (*pOverPriv->PolyText16NonTE) (pDraw, pGC, x, y, count, chars);
+}
+
+static void
+XAAOverImageText8NonTE(DrawablePtr pDraw,
+                       GCPtr pGC, int x, int y, int count, char *chars)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->ImageText8NonTE) (pDraw, pGC, x, y, count, chars);
+}
+
+static void
+XAAOverImageText16NonTE(DrawablePtr pDraw,
+                        GCPtr pGC,
+                        int x, int y, int count, unsigned short *chars)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->ImageText16NonTE) (pDraw, pGC, x, y, count, chars);
+}
+
+static void
+XAAOverImageGlyphBltNonTE(DrawablePtr pDraw,
+                          GCPtr pGC,
+                          int xInit, int yInit,
+                          unsigned int nglyph,
+                          CharInfoPtr * ppci, void *pglyphBase)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->ImageGlyphBltNonTE) (pDraw, pGC, xInit, yInit, nglyph, ppci,
+                                      pglyphBase);
+}
+
+static void
+XAAOverPolyGlyphBltNonTE(DrawablePtr pDraw,
+                         GCPtr pGC,
+                         int xInit, int yInit,
+                         unsigned int nglyph,
+                         CharInfoPtr * ppci, void *pglyphBase)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->PolyGlyphBltNonTE) (pDraw, pGC, xInit, yInit, nglyph, ppci,
+                                     pglyphBase);
+}
+
+static void
+XAAOverPolyRectangleThinSolid(DrawablePtr pDraw,
+                              GCPtr pGC, int nRectsInit, xRectangle *pRectsInit)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->PolyRectangleThinSolid) (pDraw, pGC, nRectsInit, pRectsInit);
+}
+
+static void
+XAAOverPolylinesWideSolid(DrawablePtr pDraw,
+                          GCPtr pGC, int mode, int npt, DDXPointPtr pPts)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->PolylinesWideSolid) (pDraw, pGC, mode, npt, pPts);
+}
+
+static void
+XAAOverPolylinesThinSolid(DrawablePtr pDraw,
+                          GCPtr pGC, int mode, int npt, DDXPointPtr pPts)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->PolylinesThinSolid) (pDraw, pGC, mode, npt, pPts);
+}
+
+static void
+XAAOverPolySegmentThinSolid(DrawablePtr pDraw,
+                            GCPtr pGC, int nseg, xSegment * pSeg)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->PolySegmentThinSolid) (pDraw, pGC, nseg, pSeg);
+}
+
+static void
+XAAOverPolylinesThinDashed(DrawablePtr pDraw,
+                           GCPtr pGC, int mode, int npt, DDXPointPtr pPts)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->PolylinesThinDashed) (pDraw, pGC, mode, npt, pPts);
+}
+
+static void
+XAAOverPolySegmentThinDashed(DrawablePtr pDraw,
+                             GCPtr pGC, int nseg, xSegment * pSeg)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->PolySegmentThinDashed) (pDraw, pGC, nseg, pSeg);
+}
+
+static void
+XAAOverFillPolygonSolid(DrawablePtr pDraw,
+                        GCPtr pGC,
+                        int shape, int mode, int count, DDXPointPtr ptsIn)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->FillPolygonSolid) (pDraw, pGC, shape, mode, count, ptsIn);
+}
+
+static void
+XAAOverFillPolygonStippled(DrawablePtr pDraw,
+                           GCPtr pGC,
+                           int shape, int mode, int count, DDXPointPtr ptsIn)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->FillPolygonStippled) (pDraw, pGC, shape, mode, count, ptsIn);
+}
+
+static void
+XAAOverFillPolygonOpaqueStippled(DrawablePtr pDraw,
+                                 GCPtr pGC,
+                                 int shape,
+                                 int mode, int count, DDXPointPtr ptsIn)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->FillPolygonOpaqueStippled) (pDraw, pGC, shape, mode, count,
+                                             ptsIn);
+}
+
+static void
+XAAOverFillPolygonTiled(DrawablePtr pDraw,
+                        GCPtr pGC,
+                        int shape, int mode, int count, DDXPointPtr ptsIn)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->FillPolygonTiled) (pDraw, pGC, shape, mode, count, ptsIn);
+}
+
+static void
+XAAOverPolyFillArcSolid(DrawablePtr pDraw, GCPtr pGC, int narcs, xArc * parcs)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->PolyFillArcSolid) (pDraw, pGC, narcs, parcs);
+}
+
+static void
+XAAOverPutImage(DrawablePtr pDraw,
+                GCPtr pGC,
+                int depth,
+                int x,
+                int y, int w, int h, int leftPad, int format, char *pImage)
+{
+    XAAOverlayPtr pOverPriv = GET_OVERLAY_PRIV(pGC->pScreen);
+
+    SWITCH_DEPTH(pGC->depth);
+
+    (*pOverPriv->PutImage) (pDraw, pGC, depth, x, y, w, h,
+                            leftPad, format, pImage);
+}
diff --git a/hw/xfree86/xaa/xaaPCache.c b/hw/xfree86/xaa/xaaPCache.c
new file mode 100644
index 000000000..e75ebfa6f
--- /dev/null
+++ b/hw/xfree86/xaa/xaaPCache.c
@@ -0,0 +1,2527 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <string.h>
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include "gc.h"
+#include "mi.h"
+#include "pixmapstr.h"
+#include "windowstr.h"
+#include "regionstr.h"
+#include "servermd.h"
+#include "xf86str.h"
+#include "xaa.h"
+#include "xaacexp.h"
+#include "xaalocal.h"
+#include "xaawrap.h"
+
+#define MAX_COLOR	32
+#define MAX_MONO	32
+#define MAX_8		32
+#define MAX_128		32
+#define MAX_256		32
+#define MAX_512		16
+
+static int CacheInitIndex = -1;
+
+#define CACHEINIT(p) ((p)->privates[CacheInitIndex].val)
+
+typedef struct _CacheLink {
+    int x;
+    int y;
+    int w;
+    int h;
+    struct _CacheLink *next;
+} CacheLink, *CacheLinkPtr;
+
+static void
+TransferList(CacheLinkPtr list, XAACacheInfoPtr array, int num)
+{
+    while (num--) {
+        array->x = list->x;
+        array->y = list->y;
+        array->w = list->w;
+        array->h = list->h;
+        array->serialNumber = 0;
+        array->fg = array->bg = -1;
+        list = list->next;
+        array++;
+    }
+}
+
+static CacheLinkPtr
+Enlist(CacheLinkPtr link, int x, int y, int w, int h)
+{
+    CacheLinkPtr newLink;
+
+    newLink = malloc(sizeof(CacheLink));
+    newLink->next = link;
+    newLink->x = x;
+    newLink->y = y;
+    newLink->w = w;
+    newLink->h = h;
+    return newLink;
+}
+
+static CacheLinkPtr
+Delist(CacheLinkPtr link)
+{
+    CacheLinkPtr ret = NULL;
+
+    if (link) {
+        ret = link->next;
+        free(link);
+    }
+    return ret;
+}
+
+static void
+FreeList(CacheLinkPtr link)
+{
+    CacheLinkPtr tmp;
+
+    while (link) {
+        tmp = link;
+        link = link->next;
+        free(tmp);
+    }
+}
+
+static CacheLinkPtr
+QuadLinks(CacheLinkPtr big, CacheLinkPtr little)
+{
+    /* CAUTION: This doesn't free big */
+    int w1, w2, h1, h2;
+
+    while (big) {
+        w1 = big->w >> 1;
+        w2 = big->w - w1;
+        h1 = big->h >> 1;
+        h2 = big->h - h1;
+
+        little = Enlist(little, big->x, big->y, w1, h1);
+        little = Enlist(little, big->x + w1, big->y, w2, h1);
+        little = Enlist(little, big->x, big->y + h1, w1, h2);
+        little = Enlist(little, big->x + w1, big->y + h1, w2, h2);
+
+        big = big->next;
+    }
+    return little;
+}
+
+static void
+SubdivideList(CacheLinkPtr * large, CacheLinkPtr * small)
+{
+    CacheLinkPtr big = *large;
+    CacheLinkPtr little = *small;
+    int size = big->w >> 1;
+
+    little = Enlist(little, big->x, big->y, size, size);
+    little = Enlist(little, big->x + size, big->y, size, size);
+    little = Enlist(little, big->x, big->y + size, size, size);
+    little = Enlist(little, big->x + size, big->y + size, size, size);
+    *small = little;
+    big = Delist(big);
+    *large = big;
+}
+
+static void
+FreePixmapCachePrivate(XAAPixmapCachePrivatePtr pPriv)
+{
+    if (!pPriv)
+        return;
+
+    free(pPriv->Info512);
+    free(pPriv->Info256);
+    free(pPriv->Info128);
+    free(pPriv->InfoColor);
+    free(pPriv->InfoMono);
+    free(pPriv->InfoPartial);
+
+    free(pPriv);
+}
+
+void
+XAAClosePixmapCache(ScreenPtr pScreen)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
+
+    if (infoRec->PixmapCachePrivate)
+        FreePixmapCachePrivate((XAAPixmapCachePrivatePtr) infoRec->
+                               PixmapCachePrivate);
+
+    infoRec->PixmapCachePrivate = NULL;
+}
+
+static CacheLinkPtr
+ThinOutPartials(CacheLinkPtr ListPartial, int *num, int *maxw, int *maxh)
+{
+/* This guy's job is to get at least 4 big slots out of a list of fragments */
+
+    CacheLinkPtr List64, List32, List16, List8, pCur, next, ListKeepers;
+    int Num64, Num32, Num16, Num8, NumKeepers;
+    int w, h;
+
+    List64 = List32 = List16 = List8 = ListKeepers = NULL;
+    Num64 = Num32 = Num16 = Num8 = NumKeepers = 0;
+    w = h = 0;
+
+    /* We sort partials by how large a square tile they can cache.
+       If a partial can't store a 64x64, 32x32, 16x16 or 8x8 tile,
+       we free it.  */
+
+    pCur = ListPartial;
+    while (pCur) {
+        next = pCur->next;
+        if ((pCur->w >= 64) && (pCur->h >= 64)) {
+            pCur->next = List64;
+            List64 = pCur;
+            Num64++;
+        }
+        else if ((pCur->w >= 32) && (pCur->h >= 32)) {
+            pCur->next = List32;
+            List32 = pCur;
+            Num32++;
+        }
+        else if ((pCur->w >= 16) && (pCur->h >= 16)) {
+            pCur->next = List16;
+            List16 = pCur;
+            Num16++;
+        }
+        else if ((pCur->w >= 8) && (pCur->h >= 8)) {
+            pCur->next = List8;
+            List8 = pCur;
+            Num8++;
+        }
+        else {
+            free(pCur);
+        }
+
+        pCur = next;
+    }
+
+    /* We save all the tiles from the largest bin that we can get
+       at least 4 of.  If there are too few of a bigger slot, we
+       cut it in fourths to make smaller slots. */
+
+    if (Num64 >= 4) {
+        ListKeepers = List64;
+        List64 = NULL;
+        NumKeepers = Num64;
+        goto GOT_EM;
+    }
+    else if (Num64) {
+        List32 = QuadLinks(List64, List32);
+        Num32 += Num64 * 4;
+        Num64 = 0;
+    }
+
+    if (Num32 >= 4) {
+        ListKeepers = List32;
+        List32 = NULL;
+        NumKeepers = Num32;
+        goto GOT_EM;
+    }
+    else if (Num32) {
+        List16 = QuadLinks(List32, List16);
+        Num16 += Num32 * 4;
+        Num32 = 0;
+    }
+
+    if (Num16 >= 4) {
+        ListKeepers = List16;
+        List16 = NULL;
+        NumKeepers = Num16;
+        goto GOT_EM;
+    }
+    else if (Num16) {
+        List8 = QuadLinks(List16, List8);
+        Num8 += Num16 * 4;
+        Num16 = 0;
+    }
+
+    if (Num8 >= 4) {
+        ListKeepers = List8;
+        List8 = NULL;
+        NumKeepers = Num8;
+        goto GOT_EM;
+    }
+
+ GOT_EM:
+
+    /* Free the ones we aren't using */
+
+    if (List64)
+        FreeList(List64);
+    if (List32)
+        FreeList(List32);
+    if (List16)
+        FreeList(List16);
+    if (List8)
+        FreeList(List8);
+
+    /* Enlarge the slots if we can */
+
+    if (ListKeepers) {
+        CacheLinkPtr pLink = ListKeepers;
+
+        w = h = 128;
+
+        while (pLink) {
+            if (pLink->w < w)
+                w = pLink->w;
+            if (pLink->h < h)
+                h = pLink->h;
+            pLink = pLink->next;
+        }
+    }
+
+    *maxw = w;
+    *maxh = h;
+    *num = NumKeepers;
+    return ListKeepers;
+}
+
+static void
+ConvertColorToMono(CacheLinkPtr * ColorList,
+                   int ColorW, int ColorH,
+                   CacheLinkPtr * MonoList, int MonoW, int MonoH)
+{
+    int x, y, w;
+
+    x = (*ColorList)->x;
+    y = (*ColorList)->y;
+    *ColorList = Delist(*ColorList);
+
+    while (ColorH) {
+        ColorH -= MonoH;
+        for (w = 0; w <= (ColorW - MonoW); w += MonoW)
+            *MonoList = Enlist(*MonoList, x + w, y + ColorH, MonoW, MonoH);
+    }
+}
+
+static void
+ConvertAllPartialsTo8x8(int *NumMono, int *NumColor,
+                        CacheLinkPtr ListPartial,
+                        CacheLinkPtr * ListMono,
+                        CacheLinkPtr * ListColor, XAAInfoRecPtr infoRec)
+{
+/* This guy extracts as many 8x8 slots as it can out of fragments */
+
+    int ColorH = infoRec->CacheHeightColor8x8Pattern;
+    int ColorW = infoRec->CacheWidthColor8x8Pattern;
+    int MonoH = infoRec->CacheHeightMono8x8Pattern;
+    int MonoW = infoRec->CacheWidthMono8x8Pattern;
+    int x, y, w, Height, Width;
+    Bool DoColor = (infoRec->PixmapCacheFlags & CACHE_COLOR_8x8);
+    Bool DoMono = (infoRec->PixmapCacheFlags & CACHE_MONO_8x8);
+    CacheLinkPtr pLink = ListPartial;
+    CacheLinkPtr MonoList = *ListMono, ColorList = *ListColor;
+
+    if (DoColor && DoMono) {
+        /* we assume color patterns take more space than color ones */
+        if (MonoH > ColorH)
+            ColorH = MonoH;
+        if (MonoW > ColorW)
+            ColorW = MonoW;
+    }
+
+    /* Break up the area into as many Color and Mono slots as we can */
+
+    while (pLink) {
+        Height = pLink->h;
+        Width = pLink->w;
+        x = pLink->x;
+        y = pLink->y;
+
+        if (DoColor) {
+            while (Height >= ColorH) {
+                Height -= ColorH;
+                for (w = 0; w <= (Width - ColorW); w += ColorW) {
+                    ColorList =
+                        Enlist(ColorList, x + w, y + Height, ColorW, ColorH);
+                    (*NumColor)++;
+                }
+            }
+        }
+
+        if (DoMono && (Height >= MonoH)) {
+            while (Height >= MonoH) {
+                Height -= MonoH;
+                for (w = 0; w <= (Width - MonoW); w += MonoW) {
+                    MonoList =
+                        Enlist(MonoList, x + w, y + Height, MonoW, MonoH);
+                    (*NumMono)++;
+                }
+            }
+        }
+
+        pLink = pLink->next;
+    }
+
+    *ListMono = MonoList;
+    *ListColor = ColorList;
+    FreeList(ListPartial);
+}
+
+static CacheLinkPtr
+ExtractOneThatFits(CacheLinkPtr * initList, int w, int h)
+{
+    CacheLinkPtr list = *initList;
+    CacheLinkPtr prev = NULL;
+
+    while (list) {
+        if ((list->w >= w) && (list->h >= h))
+            break;
+        prev = list;
+        list = list->next;
+    }
+
+    if (list) {
+        if (prev)
+            prev->next = list->next;
+        else
+            *initList = list->next;
+
+        list->next = NULL;
+    }
+
+    return list;
+}
+
+static CacheLinkPtr
+ConvertSomePartialsTo8x8(int *NumMono, int *NumColor, int *NumPartial,
+                         CacheLinkPtr ListPartial,
+                         CacheLinkPtr * ListMono,
+                         CacheLinkPtr * ListColor,
+                         int *maxw, int *maxh, XAAInfoRecPtr infoRec)
+{
+/* This guy tries to get 4 of each type of 8x8 slot requested out of
+   a list of fragments all while trying to retain some big fragments
+   for the cache blits */
+
+    int ColorH = infoRec->CacheHeightColor8x8Pattern;
+    int ColorW = infoRec->CacheWidthColor8x8Pattern;
+    int MonoH = infoRec->CacheHeightMono8x8Pattern;
+    int MonoW = infoRec->CacheWidthMono8x8Pattern;
+    Bool DoColor = (infoRec->PixmapCacheFlags & CACHE_COLOR_8x8);
+    Bool DoMono = (infoRec->PixmapCacheFlags & CACHE_MONO_8x8);
+    CacheLinkPtr List64, List32, List16, List8, pCur, next, ListKeepers;
+    CacheLinkPtr MonoList = *ListMono, ColorList = *ListColor;
+    int Num64, Num32, Num16, Num8, NumKeepers;
+    int w, h, Width, Height;
+    int MonosPerColor = 1;
+
+    if (DoColor && DoMono) {
+        /* we assume color patterns take more space than color ones */
+        if (MonoH > ColorH)
+            ColorH = MonoH;
+        if (MonoW > ColorW)
+            ColorW = MonoW;
+        MonosPerColor = (ColorH / MonoH) * (ColorW / MonoW);
+    }
+
+    List64 = List32 = List16 = List8 = ListKeepers = MonoList = ColorList =
+        NULL;
+    Num64 = Num32 = Num16 = Num8 = NumKeepers = 0;
+    Width = Height = 0;
+
+    /* We sort partials by how large a square tile they can cache.
+       We make 8x8 patterns from the leftovers if we can. */
+
+    pCur = ListPartial;
+    while (pCur) {
+        next = pCur->next;
+        if ((pCur->w >= 64) && (pCur->h >= 64)) {
+            pCur->next = List64;
+            List64 = pCur;
+            Num64++;
+        }
+        else if ((pCur->w >= 32) && (pCur->h >= 32)) {
+            pCur->next = List32;
+            List32 = pCur;
+            Num32++;
+        }
+        else if ((pCur->w >= 16) && (pCur->h >= 16)) {
+            pCur->next = List16;
+            List16 = pCur;
+            Num16++;
+        }
+        else if ((pCur->w >= 8) && (pCur->h >= 8)) {
+            pCur->next = List8;
+            List8 = pCur;
+            Num8++;
+        }
+        else {
+            h = pCur->h;
+            if (DoColor && (pCur->w >= ColorW) && (h >= ColorH)) {
+                while (h >= ColorH) {
+                    h -= ColorH;
+                    for (w = 0; w <= (pCur->w - ColorW); w += ColorW) {
+                        ColorList = Enlist(ColorList,
+                                           pCur->x + w, pCur->y + h, ColorW,
+                                           ColorH);
+                        (*NumColor)++;
+                    }
+                }
+            }
+            if (DoMono && (pCur->w >= MonoW) && (h >= MonoH)) {
+                while (h >= MonoH) {
+                    h -= MonoH;
+                    for (w = 0; w <= (pCur->w - MonoW); w += MonoW) {
+                        MonoList = Enlist(MonoList,
+                                          pCur->x + w, pCur->y + h, MonoW,
+                                          MonoH);
+                        (*NumMono)++;
+                    }
+                }
+            }
+            free(pCur);
+        }
+
+        pCur = next;
+    }
+
+    /* Try to extract at least 4 of each type of 8x8 slot that we need */
+
+    if (DoColor) {
+        CacheLinkPtr theOne;
+
+        while (*NumColor < 4) {
+            theOne = NULL;
+            if (Num8) {
+                if ((theOne = ExtractOneThatFits(&List8, ColorW, ColorH)))
+                    Num8--;
+            }
+            if (Num16 && !theOne) {
+                if ((theOne = ExtractOneThatFits(&List16, ColorW, ColorH)))
+                    Num16--;
+            }
+            if (Num32 && !theOne) {
+                if ((theOne = ExtractOneThatFits(&List32, ColorW, ColorH)))
+                    Num32--;
+            }
+            if (Num64 && !theOne) {
+                if ((theOne = ExtractOneThatFits(&List64, ColorW, ColorH)))
+                    Num64--;
+            }
+
+            if (!theOne)
+                break;
+
+            ConvertAllPartialsTo8x8(NumMono, NumColor, theOne,
+                                    &MonoList, &ColorList, infoRec);
+
+            if (DoMono) {
+                while (*NumColor && (*NumMono < 4)) {
+                    ConvertColorToMono(&ColorList, ColorW, ColorH,
+                                       &MonoList, MonoW, MonoH);
+                    (*NumColor)--;
+                    *NumMono += MonosPerColor;
+                }
+            }
+        }
+    }
+
+    if (DoMono) {
+        CacheLinkPtr theOne;
+
+        while (*NumMono < 4) {
+            theOne = NULL;
+            if (Num8) {
+                if ((theOne = ExtractOneThatFits(&List8, MonoW, MonoH)))
+                    Num8--;
+            }
+            if (Num16 && !theOne) {
+                if ((theOne = ExtractOneThatFits(&List16, MonoW, MonoH)))
+                    Num16--;
+            }
+            if (Num32 && !theOne) {
+                if ((theOne = ExtractOneThatFits(&List32, MonoW, MonoH)))
+                    Num32--;
+            }
+            if (Num64 && !theOne) {
+                if ((theOne = ExtractOneThatFits(&List64, MonoW, MonoH)))
+                    Num64--;
+            }
+
+            if (!theOne)
+                break;
+
+            ConvertAllPartialsTo8x8(NumMono, NumColor, theOne,
+                                    &MonoList, &ColorList, infoRec);
+        }
+    }
+
+    /* We save all the tiles from the largest bin that we can get
+       at least 4 of.  If there are too few of a bigger slot, we
+       cut it in fourths to make smaller slots. */
+
+    if (Num64 >= 4) {
+        ListKeepers = List64;
+        List64 = NULL;
+        NumKeepers = Num64;
+        goto GOT_EM;
+    }
+    else if (Num64) {
+        List32 = QuadLinks(List64, List32);
+        Num32 += Num64 * 4;
+        Num64 = 0;
+    }
+
+    if (Num32 >= 4) {
+        ListKeepers = List32;
+        List32 = NULL;
+        NumKeepers = Num32;
+        goto GOT_EM;
+    }
+    else if (Num32) {
+        List16 = QuadLinks(List32, List16);
+        Num16 += Num32 * 4;
+        Num32 = 0;
+    }
+
+    if (Num16 >= 4) {
+        ListKeepers = List16;
+        List16 = NULL;
+        NumKeepers = Num16;
+        goto GOT_EM;
+    }
+    else if (Num16) {
+        List8 = QuadLinks(List16, List8);
+        Num8 += Num16 * 4;
+        Num16 = 0;
+    }
+
+    if (Num8 >= 4) {
+        ListKeepers = List8;
+        List8 = NULL;
+        NumKeepers = Num8;
+        goto GOT_EM;
+    }
+
+ GOT_EM:
+
+    /* Free the ones we aren't using */
+
+    if (List64)
+        ConvertAllPartialsTo8x8(NumMono, NumColor, List64,
+                                &MonoList, &ColorList, infoRec);
+    if (List32)
+        ConvertAllPartialsTo8x8(NumMono, NumColor, List32,
+                                &MonoList, &ColorList, infoRec);
+    if (List16)
+        ConvertAllPartialsTo8x8(NumMono, NumColor, List16,
+                                &MonoList, &ColorList, infoRec);
+    if (List8)
+        ConvertAllPartialsTo8x8(NumMono, NumColor, List8,
+                                &MonoList, &ColorList, infoRec);
+
+    /* Enlarge the slots if we can */
+
+    if (ListKeepers) {
+        CacheLinkPtr pLink = ListKeepers;
+
+        Width = Height = 128;
+
+        while (pLink) {
+            if (pLink->w < Width)
+                Width = pLink->w;
+            if (pLink->h < Height)
+                Height = pLink->h;
+            pLink = pLink->next;
+        }
+    }
+
+    *ListMono = MonoList;
+    *ListColor = ColorList;
+    *maxw = Width;
+    *maxh = Height;
+    *NumPartial = NumKeepers;
+    return ListKeepers;
+}
+
+void
+XAAInitPixmapCache(ScreenPtr pScreen, RegionPtr areas, void *data)
+{
+    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
+    XAAInfoRecPtr infoRec = (XAAInfoRecPtr) data;
+    XAAPixmapCachePrivatePtr pCachePriv;
+    BoxPtr pBox = RegionRects(areas);
+    int nBox = RegionNumRects(areas);
+    int Num512, Num256, Num128, NumPartial, NumColor, NumMono;
+    int Target512, Target256;
+    CacheLinkPtr List512, List256, List128, ListPartial, ListColor, ListMono;
+    int x, y, w, h, ntotal, granularity, width, height, i;
+    int MaxPartialWidth, MaxPartialHeight;
+
+    infoRec->MaxCacheableTileWidth = 0;
+    infoRec->MaxCacheableTileHeight = 0;
+    infoRec->MaxCacheableStippleHeight = 0;
+    infoRec->MaxCacheableStippleWidth = 0;
+    infoRec->UsingPixmapCache = FALSE;
+
+    if (!nBox || !pBox || !(infoRec->Flags & PIXMAP_CACHE))
+        return;
+
+    /* Allocate a persistent per-screen init flag to control messages */
+    if (CacheInitIndex < 0)
+        CacheInitIndex = xf86AllocateScrnInfoPrivateIndex();
+
+    /* free the old private data if it exists */
+    if (infoRec->PixmapCachePrivate) {
+        FreePixmapCachePrivate((XAAPixmapCachePrivatePtr) infoRec->
+                               PixmapCachePrivate);
+        infoRec->PixmapCachePrivate = NULL;
+    }
+
+    Num512 = Num256 = Num128 = NumPartial = NumMono = NumColor = 0;
+    List512 = List256 = List128 = ListPartial = ListMono = ListColor = NULL;
+    granularity = infoRec->CachePixelGranularity;
+    if (granularity <= 1)
+        granularity = 0;
+
+    /* go through the boxes and break it into as many pieces as we can fit */
+
+    while (nBox--) {
+        x = pBox->x1;
+        if (granularity) {
+            int tmp = x % granularity;
+
+            if (tmp)
+                x += (granularity - tmp);
+        }
+        width = pBox->x2 - x;
+        if (width <= 0) {
+            pBox++;
+            continue;
+        }
+
+        y = pBox->y1;
+        height = pBox->y2 - y;
+
+        for (h = 0; h <= (height - 512); h += 512) {
+            for (w = 0; w <= (width - 512); w += 512) {
+                List512 = Enlist(List512, x + w, y + h, 512, 512);
+                Num512++;
+            }
+            for (; w <= (width - 256); w += 256) {
+                List256 = Enlist(List256, x + w, y + h, 256, 256);
+                List256 = Enlist(List256, x + w, y + h + 256, 256, 256);
+                Num256 += 2;
+            }
+            for (; w <= (width - 128); w += 128) {
+                List128 = Enlist(List128, x + w, y + h, 128, 128);
+                List128 = Enlist(List128, x + w, y + h + 128, 128, 128);
+                List128 = Enlist(List128, x + w, y + h + 256, 128, 128);
+                List128 = Enlist(List128, x + w, y + h + 384, 128, 128);
+                Num128 += 4;
+            }
+            if (w < width) {
+                int d = width - w;
+
+                ListPartial = Enlist(ListPartial, x + w, y + h, d, 128);
+                ListPartial = Enlist(ListPartial, x + w, y + h + 128, d, 128);
+                ListPartial = Enlist(ListPartial, x + w, y + h + 256, d, 128);
+                ListPartial = Enlist(ListPartial, x + w, y + h + 384, d, 128);
+                NumPartial += 4;
+            }
+        }
+        for (; h <= (height - 256); h += 256) {
+            for (w = 0; w <= (width - 256); w += 256) {
+                List256 = Enlist(List256, x + w, y + h, 256, 256);
+                Num256++;
+            }
+            for (; w <= (width - 128); w += 128) {
+                List128 = Enlist(List128, x + w, y + h, 128, 128);
+                List128 = Enlist(List128, x + w, y + h + 128, 128, 128);
+                Num128 += 2;
+            }
+            if (w < width) {
+                int d = width - w;
+
+                ListPartial = Enlist(ListPartial, x + w, y + h, d, 128);
+                ListPartial = Enlist(ListPartial, x + w, y + h + 128, d, 128);
+                NumPartial += 2;
+            }
+        }
+        for (; h <= (height - 128); h += 128) {
+            for (w = 0; w <= (width - 128); w += 128) {
+                List128 = Enlist(List128, x + w, y + h, 128, 128);
+                Num128++;
+            }
+            if (w < width) {
+                ListPartial = Enlist(ListPartial, x + w, y + h, width - w, 128);
+                NumPartial++;
+            }
+        }
+        if (h < height) {
+            int d = height - h;
+
+            for (w = 0; w <= (width - 128); w += 128) {
+                ListPartial = Enlist(ListPartial, x + w, y + h, 128, d);
+                NumPartial++;
+            }
+            if (w < width) {
+                ListPartial = Enlist(ListPartial, x + w, y + h, width - w, d);
+                NumPartial++;
+            }
+        }
+        pBox++;
+    }
+
+/* 
+   by this point we've carved the space into as many 512x512, 256x256
+	and 128x128 blocks as we could fit.  We will then break larger
+	blocks into smaller ones if we need to.  The rules are as follows:
+
+     512x512 -
+	1) Don't take up more than half the memory.
+	2) Don't bother if you can't get at least four.
+	3) Don't make more than MAX_512.
+	4) Don't have any of there are no 256x256s.
+
+     256x256 -
+	1) Don't take up more than a quarter of the memory enless there
+		aren't any 512x512s.  Then we can take up to half.
+	2) Don't bother if you can't get at least four.
+	3) Don't make more than MAX_256.
+
+     128x128 -
+	1) Don't make more than MAX_128.
+
+     We don't bother with the partial blocks unless we can use them
+     for 8x8 pattern fills or we are short on larger blocks.
+
+*/
+
+    ntotal = Num128 + (Num256 << 2) + (Num512 << 4);
+
+    Target512 = ntotal >> 5;
+    if (Target512 < 4)
+        Target512 = 0;
+    if (!Target512)
+        Target256 = ntotal >> 3;
+    else
+        Target256 = ntotal >> 4;
+    if (Target256 < 4)
+        Target256 = 0;
+
+    if (Num512 && Num256 < 4) {
+        while (Num512 && Num256 < Target256) {
+            SubdivideList(&List512, &List256);
+            Num256 += 4;
+            Num512--;
+        }
+    }
+
+    if (!Num512) {              /* no room */
+    }
+    else if ((Num512 < 4) || (!Target512)) {
+        while (Num512) {
+            SubdivideList(&List512, &List256);
+            Num256 += 4;
+            Num512--;
+        }
+    }
+    else if ((Num512 > MAX_512) || (Num512 > Target512)) {
+        while (Num512 > MAX_512) {
+            SubdivideList(&List512, &List256);
+            Num256 += 4;
+            Num512--;
+        }
+        while (Num512 > Target512) {
+            if (Num256 < MAX_256) {
+                SubdivideList(&List512, &List256);
+                Num256 += 4;
+                Num512--;
+            }
+            else
+                break;
+        }
+    }
+
+    if (!Num256) {              /* no room */
+    }
+    else if ((Num256 < 4) || (!Target256)) {
+        while (Num256) {
+            SubdivideList(&List256, &List128);
+            Num128 += 4;
+            Num256--;
+        }
+    }
+    else if ((Num256 > MAX_256) || (Num256 > Target256)) {
+        while (Num256 > MAX_256) {
+            SubdivideList(&List256, &List128);
+            Num128 += 4;
+            Num256--;
+        }
+        while (Num256 > Target256) {
+            if (Num128 < MAX_128) {
+                SubdivideList(&List256, &List128);
+                Num128 += 4;
+                Num256--;
+            }
+            else
+                break;
+        }
+    }
+
+    if (Num128 && ((Num128 < 4) || (Num128 > MAX_128))) {
+        CacheLinkPtr next;
+        int max = (Num128 > MAX_128) ? MAX_128 : 0;
+
+        /*
+         * Note: next is set in this way to work around a code generation
+         * bug in gcc 2.7.2.3.
+         */
+        next = List128->next;
+        while (Num128 > max) {
+            List128->next = ListPartial;
+            ListPartial = List128;
+            if ((List128 = next))
+                next = List128->next;
+            NumPartial++;
+            Num128--;
+        }
+    }
+
+    MaxPartialHeight = MaxPartialWidth = 0;
+
+    /* at this point we have as many 512x512 and 256x256 slots as we
+       want but may have an excess of 128x128 slots.  We still need
+       to find out if we need 8x8 slots.  We take these from the
+       partials if we have them.  Otherwise, we break some 128x128's */
+
+    if (!(infoRec->PixmapCacheFlags & (CACHE_MONO_8x8 | CACHE_COLOR_8x8))) {
+        if (NumPartial) {
+            if (Num128) {       /* don't bother with partials */
+                FreeList(ListPartial);
+                NumPartial = 0;
+                ListPartial = NULL;
+            }
+            else {
+                /* We have no big slots.  Weed out the unusable partials */
+                ListPartial = ThinOutPartials(ListPartial, &NumPartial,
+                                              &MaxPartialWidth,
+                                              &MaxPartialHeight);
+            }
+        }
+    }
+    else {
+        int MonosPerColor = 1;
+        int ColorH = infoRec->CacheHeightColor8x8Pattern;
+        int ColorW = infoRec->CacheWidthColor8x8Pattern;
+        int MonoH = infoRec->CacheHeightMono8x8Pattern;
+        int MonoW = infoRec->CacheWidthMono8x8Pattern;
+        Bool DoColor = (infoRec->PixmapCacheFlags & CACHE_COLOR_8x8);
+        Bool DoMono = (infoRec->PixmapCacheFlags & CACHE_MONO_8x8);
+
+        if (DoColor)
+            infoRec->CanDoColor8x8 = FALSE;
+        if (DoMono)
+            infoRec->CanDoMono8x8 = FALSE;
+
+        if (DoColor && DoMono) {
+            /* we assume color patterns take more space than color ones */
+            if (MonoH > ColorH)
+                ColorH = MonoH;
+            if (MonoW > ColorW)
+                ColorW = MonoW;
+            MonosPerColor = (ColorH / MonoH) * (ColorW / MonoW);
+        }
+
+        if (Num128) {
+            if (NumPartial) {   /* use all for 8x8 slots */
+                ConvertAllPartialsTo8x8(&NumMono, &NumColor,
+                                        ListPartial, &ListMono, &ListColor,
+                                        infoRec);
+                NumPartial = 0;
+                ListPartial = NULL;
+            }
+
+            /* Get some 8x8 slots from the 128 slots */
+            while ((Num128 > 4) &&
+                   ((NumMono < MAX_MONO) && (NumColor < MAX_COLOR))) {
+                CacheLinkPtr tmp = NULL;
+
+                tmp = Enlist(tmp, List128->x, List128->y,
+                             List128->w, List128->h);
+                List128 = Delist(List128);
+                Num128--;
+
+                ConvertAllPartialsTo8x8(&NumMono, &NumColor,
+                                        tmp, &ListMono, &ListColor, infoRec);
+            }
+        }
+        else if (NumPartial) {
+            /* We have share partials between 8x8 slots and tiles. */
+            ListPartial = ConvertSomePartialsTo8x8(&NumMono, &NumColor,
+                                                   &NumPartial, ListPartial,
+                                                   &ListMono, &ListColor,
+                                                   &MaxPartialWidth,
+                                                   &MaxPartialHeight, infoRec);
+        }
+
+        if (DoMono && DoColor) {
+            if (NumColor && ((NumColor > MAX_COLOR) || (NumColor < 4))) {
+                int max = (NumColor > MAX_COLOR) ? MAX_COLOR : 0;
+
+                while (NumColor > max) {
+                    ConvertColorToMono(&ListColor, ColorW, ColorH,
+                                       &ListMono, MonoW, MonoH);
+                    NumColor--;
+                    NumMono += MonosPerColor;
+                }
+            }
+
+            /* favor Mono slots over Color ones */
+            while ((NumColor > 4) && (NumMono < MAX_MONO)) {
+                ConvertColorToMono(&ListColor, ColorW, ColorH,
+                                   &ListMono, MonoW, MonoH);
+                NumColor--;
+                NumMono += MonosPerColor;
+            }
+        }
+
+        if (NumMono && ((NumMono > MAX_MONO) || (NumMono < 4))) {
+            int max = (NumMono > MAX_MONO) ? MAX_MONO : 0;
+
+            while (NumMono > max) {
+                ListMono = Delist(ListMono);
+                NumMono--;
+            }
+        }
+        if (NumColor && ((NumColor > MAX_COLOR) || (NumColor < 4))) {
+            int max = (NumColor > MAX_COLOR) ? MAX_COLOR : 0;
+
+            while (NumColor > max) {
+                ListColor = Delist(ListColor);
+                NumColor--;
+            }
+        }
+    }
+
+    pCachePriv = calloc(1, sizeof(XAAPixmapCachePrivate));
+    if (!pCachePriv) {
+        if (Num512)
+            FreeList(List512);
+        if (Num256)
+            FreeList(List256);
+        if (Num128)
+            FreeList(List128);
+        if (NumPartial)
+            FreeList(ListPartial);
+        if (NumColor)
+            FreeList(ListColor);
+        if (NumMono)
+            FreeList(ListMono);
+        return;
+    }
+
+    infoRec->PixmapCachePrivate = (char *) pCachePriv;
+
+    if (Num512) {
+        pCachePriv->Info512 = calloc(Num512, sizeof(XAACacheInfoRec));
+        if (!pCachePriv->Info512)
+            Num512 = 0;
+        if (Num512)
+            TransferList(List512, pCachePriv->Info512, Num512);
+        FreeList(List512);
+        pCachePriv->Num512x512 = Num512;
+    }
+    if (Num256) {
+        pCachePriv->Info256 = calloc(Num256, sizeof(XAACacheInfoRec));
+        if (!pCachePriv->Info256)
+            Num256 = 0;
+        if (Num256)
+            TransferList(List256, pCachePriv->Info256, Num256);
+        FreeList(List256);
+        pCachePriv->Num256x256 = Num256;
+    }
+    if (Num128) {
+        pCachePriv->Info128 = calloc(Num128, sizeof(XAACacheInfoRec));
+        if (!pCachePriv->Info128)
+            Num128 = 0;
+        if (Num128)
+            TransferList(List128, pCachePriv->Info128, Num128);
+        FreeList(List128);
+        pCachePriv->Num128x128 = Num128;
+    }
+
+    if (NumPartial) {
+        pCachePriv->InfoPartial = calloc(NumPartial, sizeof(XAACacheInfoRec));
+        if (!pCachePriv->InfoPartial)
+            NumPartial = 0;
+        if (NumPartial)
+            TransferList(ListPartial, pCachePriv->InfoPartial, NumPartial);
+        FreeList(ListPartial);
+        pCachePriv->NumPartial = NumPartial;
+    }
+
+    if (NumColor) {
+        pCachePriv->InfoColor = calloc(NumColor, sizeof(XAACacheInfoRec));
+        if (!pCachePriv->InfoColor)
+            NumColor = 0;
+        if (NumColor)
+            TransferList(ListColor, pCachePriv->InfoColor, NumColor);
+        FreeList(ListColor);
+        pCachePriv->NumColor = NumColor;
+    }
+
+    if (NumMono) {
+        pCachePriv->InfoMono = calloc(NumMono, sizeof(XAACacheInfoRec));
+        if (!pCachePriv->InfoMono)
+            NumMono = 0;
+        if (NumMono)
+            TransferList(ListMono, pCachePriv->InfoMono, NumMono);
+        FreeList(ListMono);
+        pCachePriv->NumMono = NumMono;
+    }
+
+    if (NumPartial) {
+        infoRec->MaxCacheableTileWidth = MaxPartialWidth;
+        infoRec->MaxCacheableTileHeight = MaxPartialHeight;
+    }
+    if (Num128)
+        infoRec->MaxCacheableTileWidth = infoRec->MaxCacheableTileHeight = 128;
+    if (Num256)
+        infoRec->MaxCacheableTileWidth = infoRec->MaxCacheableTileHeight = 256;
+    if (Num512)
+        infoRec->MaxCacheableTileWidth = infoRec->MaxCacheableTileHeight = 512;
+
+    infoRec->MaxCacheableStippleHeight = infoRec->MaxCacheableTileHeight;
+    infoRec->MaxCacheableStippleWidth =
+        infoRec->MaxCacheableTileWidth * pScrn->bitsPerPixel;
+    if (infoRec->ScreenToScreenColorExpandFillFlags & TRIPLE_BITS_24BPP)
+        infoRec->MaxCacheableStippleWidth /= 3;
+
+    if (NumMono) {
+        if (!(infoRec->Mono8x8PatternFillFlags &
+              (HARDWARE_PATTERN_PROGRAMMED_ORIGIN |
+               HARDWARE_PATTERN_PROGRAMMED_BITS))) {
+            int numPerLine =
+                infoRec->CacheWidthMono8x8Pattern / infoRec->MonoPatternPitch;
+
+            for (i = 0; i < 64; i++) {
+                pCachePriv->MonoOffsets[i].y = i / numPerLine;
+                pCachePriv->MonoOffsets[i].x = (i % numPerLine) *
+                    infoRec->MonoPatternPitch;
+            }
+        }
+        infoRec->CanDoMono8x8 = TRUE;
+    }
+    if (NumColor) {
+        if (!(infoRec->Color8x8PatternFillFlags &
+              HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
+
+            for (i = 0; i < 64; i++) {
+                pCachePriv->ColorOffsets[i].y = i & 0x07;
+                pCachePriv->ColorOffsets[i].x = i & ~0x07;
+            }
+        }
+        infoRec->CanDoColor8x8 = TRUE;
+    }
+
+    if (!CACHEINIT(pScrn)) {
+        xf86ErrorF("\tSetting up tile and stipple cache:\n");
+        if (NumPartial)
+            xf86ErrorF("\t\t%i %ix%i slots\n",
+                       NumPartial, MaxPartialWidth, MaxPartialHeight);
+        if (Num128)
+            xf86ErrorF("\t\t%i 128x128 slots\n", Num128);
+        if (Num256)
+            xf86ErrorF("\t\t%i 256x256 slots\n", Num256);
+        if (Num512)
+            xf86ErrorF("\t\t%i 512x512 slots\n", Num512);
+        if (NumColor)
+            xf86ErrorF("\t\t%i 8x8 color pattern slots\n", NumColor);
+        if (NumMono)
+            xf86ErrorF("\t\t%i 8x8 color expansion slots\n", NumMono);
+    }
+
+    if (!(NumPartial | Num128 | Num256 | Num512 | NumColor | NumMono)) {
+        if (!CACHEINIT(pScrn))
+            xf86ErrorF("\t\tNot enough video memory for pixmap cache\n");
+    }
+    else
+        infoRec->UsingPixmapCache = TRUE;
+
+    CACHEINIT(pScrn) = 1;
+}
+
+#if X_BYTE_ORDER == X_BIG_ENDIAN
+static CARD32 StippleMasks[4] = {
+    0x80808080,
+    0xC0C0C0C0,
+    0x00000000,
+    0xF0F0F0F0
+};
+#else
+static CARD32 StippleMasks[4] = {
+    0x01010101,
+    0x03030303,
+    0x00000000,
+    0x0F0F0F0F
+};
+#endif
+
+Bool
+XAACheckStippleReducibility(PixmapPtr pPixmap)
+{
+    XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pPixmap);
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_DRAWABLE(&pPixmap->drawable);
+    CARD32 *IntPtr = (CARD32 *) pPixmap->devPrivate.ptr;
+    int w = pPixmap->drawable.width;
+    int h = pPixmap->drawable.height;
+    int i;
+    CARD32 bits[8];
+    CARD32 mask = SHIFT_R(0xFFFFFFFF, 24);
+
+    pPriv->flags |= REDUCIBILITY_CHECKED | REDUCIBLE_TO_2_COLOR;
+    pPriv->flags &= ~REDUCIBLE_TO_8x8;
+
+    if ((w > 32) || (h > 32) || (w & (w - 1)) || (h & (h - 1)))
+        return FALSE;
+
+    i = (h > 8) ? 8 : h;
+
+    switch (w) {
+    case 32:
+        while (i--) {
+            bits[i] = IntPtr[i] & mask;
+            if ((bits[i] != SHIFT_R((IntPtr[i] & SHIFT_L(mask, 8)), 8)) ||
+                (bits[i] != SHIFT_R((IntPtr[i] & SHIFT_L(mask, 16)), 16)) ||
+                (bits[i] != SHIFT_R((IntPtr[i] & SHIFT_L(mask, 24)), 24)))
+                return FALSE;
+        }
+        break;
+    case 16:
+        while (i--) {
+            bits[i] = IntPtr[i] & mask;
+            if (bits[i] != ((IntPtr[i] & SHIFT_R(SHIFT_L(mask, 8), 8))))
+                return FALSE;
+        }
+        break;
+    default:
+        while (i--)
+            bits[i] = IntPtr[i] & mask;
+        break;
+    }
+
+    switch (h) {
+    case 32:
+        if ((IntPtr[8] != IntPtr[16]) || (IntPtr[9] != IntPtr[17]) ||
+            (IntPtr[10] != IntPtr[18]) || (IntPtr[11] != IntPtr[19]) ||
+            (IntPtr[12] != IntPtr[20]) || (IntPtr[13] != IntPtr[21]) ||
+            (IntPtr[14] != IntPtr[22]) || (IntPtr[15] != IntPtr[23]) ||
+            (IntPtr[16] != IntPtr[24]) || (IntPtr[17] != IntPtr[25]) ||
+            (IntPtr[18] != IntPtr[26]) || (IntPtr[19] != IntPtr[27]) ||
+            (IntPtr[20] != IntPtr[28]) || (IntPtr[21] != IntPtr[29]) ||
+            (IntPtr[22] != IntPtr[30]) || (IntPtr[23] != IntPtr[31]))
+            return FALSE;
+        /* fall through */
+    case 16:
+        if ((IntPtr[0] != IntPtr[8]) || (IntPtr[1] != IntPtr[9]) ||
+            (IntPtr[2] != IntPtr[10]) || (IntPtr[3] != IntPtr[11]) ||
+            (IntPtr[4] != IntPtr[12]) || (IntPtr[5] != IntPtr[13]) ||
+            (IntPtr[6] != IntPtr[14]) || (IntPtr[7] != IntPtr[15]))
+            return FALSE;
+    case 8:
+        break;
+    case 1:
+        bits[1] = bits[0];
+    case 2:
+        bits[2] = bits[0];
+        bits[3] = bits[1];
+    case 4:
+        bits[4] = bits[0];
+        bits[5] = bits[1];
+        bits[6] = bits[2];
+        bits[7] = bits[3];
+        break;
+    }
+
+    pPriv->flags |= REDUCIBLE_TO_8x8;
+
+    pPriv->pattern0 =
+        bits[0] | SHIFT_L(bits[1], 8) | SHIFT_L(bits[2], 16) | SHIFT_L(bits[3],
+                                                                       24);
+    pPriv->pattern1 =
+        bits[4] | SHIFT_L(bits[5], 8) | SHIFT_L(bits[6], 16) | SHIFT_L(bits[7],
+                                                                       24);
+
+    if (w < 8) {
+        pPriv->pattern0 &= StippleMasks[w - 1];
+        pPriv->pattern1 &= StippleMasks[w - 1];
+
+        switch (w) {
+        case 1:
+            pPriv->pattern0 |= SHIFT_L(pPriv->pattern0, 1);
+            pPriv->pattern1 |= SHIFT_L(pPriv->pattern1, 1);
+        case 2:
+            pPriv->pattern0 |= SHIFT_L(pPriv->pattern0, 2);
+            pPriv->pattern1 |= SHIFT_L(pPriv->pattern1, 2);
+        case 4:
+            pPriv->pattern0 |= SHIFT_L(pPriv->pattern0, 4);
+            pPriv->pattern1 |= SHIFT_L(pPriv->pattern1, 4);
+        }
+    }
+
+    if (infoRec->Mono8x8PatternFillFlags & BIT_ORDER_IN_BYTE_MSBFIRST) {
+        pPriv->pattern0 = SWAP_BITS_IN_BYTES(pPriv->pattern0);
+        pPriv->pattern1 = SWAP_BITS_IN_BYTES(pPriv->pattern1);
+    }
+
+    return TRUE;
+}
+
+Bool
+XAACheckTileReducibility(PixmapPtr pPixmap, Bool checkMono)
+{
+    XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pPixmap);
+    CARD32 *IntPtr;
+    int w = pPixmap->drawable.width;
+    int h = pPixmap->drawable.height;
+    int pitch = pPixmap->devKind >> 2;
+    int dwords, i, j;
+
+    pPriv->flags |= REDUCIBILITY_CHECKED;
+    pPriv->flags &= ~(REDUCIBILITY_CHECKED | REDUCIBLE_TO_2_COLOR);
+
+    if ((w > 32) || (h > 32) || (w & (w - 1)) || (h & (h - 1)))
+        return FALSE;
+
+    dwords = ((w * pPixmap->drawable.bitsPerPixel) + 31) >> 5;
+    i = (h > 8) ? 8 : h;
+
+    if (w > 8) {
+        IntPtr = (CARD32 *) pPixmap->devPrivate.ptr;
+        switch (pPixmap->drawable.bitsPerPixel) {
+        case 8:
+            while (i--) {
+                for (j = 2; j < dwords; j++)
+                    if (IntPtr[j] != IntPtr[j & 0x01])
+                        return FALSE;
+                IntPtr += pitch;
+            }
+            break;
+        case 16:
+            while (i--) {
+                for (j = 4; j < dwords; j++)
+                    if (IntPtr[j] != IntPtr[j & 0x03])
+                        return FALSE;
+                IntPtr += pitch;
+            }
+            break;
+        case 24:
+            while (i--) {
+                for (j = 6; j < dwords; j++)
+                    if (IntPtr[j] != IntPtr[j % 6])
+                        return FALSE;
+                IntPtr += pitch;
+            }
+            break;
+        case 32:
+            while (i--) {
+                for (j = 8; j < dwords; j++)
+                    if (IntPtr[j] != IntPtr[j & 0x07])
+                        return FALSE;
+                IntPtr += pitch;
+            }
+            break;
+        default:
+            return FALSE;
+        }
+
+    }
+
+    if (h == 32) {
+        CARD32 *IntPtr2, *IntPtr3, *IntPtr4;
+
+        i = 8;
+        IntPtr = (CARD32 *) pPixmap->devPrivate.ptr;
+        IntPtr2 = IntPtr + (pitch << 3);
+        IntPtr3 = IntPtr2 + (pitch << 3);
+        IntPtr4 = IntPtr3 + (pitch << 3);
+        while (i--) {
+            for (j = 0; j < dwords; j++)
+                if ((IntPtr[j] != IntPtr2[j]) || (IntPtr[j] != IntPtr3[j]) ||
+                    (IntPtr[j] != IntPtr4[j]))
+                    return FALSE;
+            IntPtr += pitch;
+            IntPtr2 += pitch;
+            IntPtr3 += pitch;
+            IntPtr4 += pitch;
+        }
+    }
+    else if (h == 16) {
+        CARD32 *IntPtr2;
+
+        i = 8;
+        IntPtr = (CARD32 *) pPixmap->devPrivate.ptr;
+        IntPtr2 = IntPtr + (pitch << 3);
+        while (i--) {
+            for (j = 0; j < dwords; j++)
+                if (IntPtr[j] != IntPtr2[j])
+                    return FALSE;
+            IntPtr += pitch;
+            IntPtr2 += pitch;
+        }
+    }
+
+    pPriv->flags |= REDUCIBLE_TO_8x8;
+
+    if (checkMono) {
+        XAAInfoRecPtr infoRec =
+            GET_XAAINFORECPTR_FROM_DRAWABLE(&pPixmap->drawable);
+        unsigned char bits[8];
+        int fg, bg = -1, x, y;
+
+        i = (h > 8) ? 8 : h;
+        j = (w > 8) ? 8 : w;
+
+        if (pPixmap->drawable.bitsPerPixel == 8) {
+            unsigned char *srcp = pPixmap->devPrivate.ptr;
+
+            fg = srcp[0];
+            pitch = pPixmap->devKind;
+            for (y = 0; y < i; y++) {
+                bits[y] = 0;
+                for (x = 0; x < j; x++) {
+                    if (srcp[x] != fg) {
+                        if (bg == -1)
+                            bg = srcp[x];
+                        else if (bg != srcp[x])
+                            return TRUE;
+                    }
+                    else
+                        bits[y] |= 1 << x;
+                }
+                srcp += pitch;
+            }
+        }
+        else if (pPixmap->drawable.bitsPerPixel == 16) {
+            unsigned short *srcp = (unsigned short *) pPixmap->devPrivate.ptr;
+
+            fg = srcp[0];
+            pitch = pPixmap->devKind >> 1;
+            for (y = 0; y < i; y++) {
+                bits[y] = 0;
+                for (x = 0; x < j; x++) {
+                    if (srcp[x] != fg) {
+                        if (bg == -1)
+                            bg = srcp[x];
+                        else if (bg != srcp[x])
+                            return TRUE;
+                    }
+                    else
+                        bits[y] |= 1 << x;
+                }
+                srcp += pitch;
+            }
+        }
+        else if (pPixmap->drawable.bitsPerPixel == 24) {
+            CARD32 val;
+            unsigned char *srcp = pPixmap->devPrivate.ptr;
+
+            fg = *((CARD32 *) srcp) & 0x00FFFFFF;
+            pitch = pPixmap->devKind;
+            j *= 3;
+            for (y = 0; y < i; y++) {
+                bits[y] = 0;
+                for (x = 0; x < j; x += 3) {
+                    val = *((CARD32 *) (srcp + x)) & 0x00FFFFFF;
+                    if (val != fg) {
+                        if (bg == -1)
+                            bg = val;
+                        else if (bg != val)
+                            return TRUE;
+                    }
+                    else
+                        bits[y] |= 1 << (x / 3);
+                }
+                srcp += pitch;
+            }
+        }
+        else if (pPixmap->drawable.bitsPerPixel == 32) {
+            IntPtr = (CARD32 *) pPixmap->devPrivate.ptr;
+            fg = IntPtr[0];
+            for (y = 0; y < i; y++) {
+                bits[y] = 0;
+                for (x = 0; x < j; x++) {
+                    if (IntPtr[x] != fg) {
+                        if (bg == -1)
+                            bg = IntPtr[x];
+                        else if (bg != IntPtr[x])
+                            return TRUE;
+                    }
+                    else
+                        bits[y] |= 1 << x;
+                }
+                IntPtr += pitch;
+            }
+        }
+        else
+            return TRUE;
+
+        pPriv->fg = fg;
+        if (bg == -1)
+            pPriv->bg = fg;
+        else
+            pPriv->bg = bg;
+
+        if (h < 8) {
+            switch (h) {
+            case 1:
+                bits[1] = bits[0];
+            case 2:
+                bits[2] = bits[0];
+                bits[3] = bits[1];
+            case 4:
+                bits[4] = bits[0];
+                bits[5] = bits[1];
+                bits[6] = bits[2];
+                bits[7] = bits[3];
+                break;
+            }
+        }
+
+        pPriv->pattern0 =
+            bits[0] | (bits[1] << 8) | (bits[2] << 16) | (bits[3] << 24);
+        pPriv->pattern1 =
+            bits[4] | (bits[5] << 8) | (bits[6] << 16) | (bits[7] << 24);
+
+        if (w < 8) {
+            switch (w) {
+            case 1:
+                pPriv->pattern0 |= (pPriv->pattern0 << 1);
+                pPriv->pattern1 |= (pPriv->pattern1 << 1);
+            case 2:
+                pPriv->pattern0 |= (pPriv->pattern0 << 2);
+                pPriv->pattern1 |= (pPriv->pattern1 << 2);
+            case 4:
+                pPriv->pattern0 |= (pPriv->pattern0 << 4);
+                pPriv->pattern1 |= (pPriv->pattern1 << 4);
+            }
+        }
+        pPriv->flags |= REDUCIBLE_TO_2_COLOR;
+
+        if (infoRec->Mono8x8PatternFillFlags & BIT_ORDER_IN_BYTE_MSBFIRST) {
+            pPriv->pattern0 = SWAP_BITS_IN_BYTES(pPriv->pattern0);
+            pPriv->pattern1 = SWAP_BITS_IN_BYTES(pPriv->pattern1);
+        }
+
+    }
+
+    return TRUE;
+}
+
+void
+XAATileCache(ScrnInfoPtr pScrn, XAACacheInfoPtr pCache, int w, int h)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+
+    (*infoRec->SetupForScreenToScreenCopy) (pScrn, 1, 1, GXcopy, ~0, -1);
+
+    while ((w << 1) <= pCache->w) {
+        (*infoRec->SubsequentScreenToScreenCopy) (pScrn, pCache->x, pCache->y,
+                                                  pCache->x + w, pCache->y, w,
+                                                  h);
+        w <<= 1;
+    }
+    if (w != pCache->w) {
+        (*infoRec->SubsequentScreenToScreenCopy) (pScrn, pCache->x, pCache->y,
+                                                  pCache->x + w, pCache->y,
+                                                  pCache->w - w, h);
+        w = pCache->w;
+    }
+
+    while ((h << 1) <= pCache->h) {
+        (*infoRec->SubsequentScreenToScreenCopy) (pScrn, pCache->x, pCache->y,
+                                                  pCache->x, pCache->y + h, w,
+                                                  h);
+        h <<= 1;
+    }
+    if (h != pCache->h) {
+        (*infoRec->SubsequentScreenToScreenCopy) (pScrn, pCache->x, pCache->y,
+                                                  pCache->x, pCache->y + h, w,
+                                                  pCache->h - h);
+    }
+    SET_SYNC_FLAG(infoRec);
+}
+
+XAACacheInfoPtr
+XAACacheTile(ScrnInfoPtr pScrn, PixmapPtr pPix)
+{
+    int w = pPix->drawable.width;
+    int h = pPix->drawable.height;
+    int size = max(w, h);
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    XAAPixmapCachePrivatePtr pCachePriv =
+        (XAAPixmapCachePrivatePtr) infoRec->PixmapCachePrivate;
+    XAACacheInfoPtr pCache, cacheRoot = NULL;
+    int i, max = 0;
+    int *current;
+
+    if (size <= 128) {
+        if (pCachePriv->Info128) {
+            cacheRoot = pCachePriv->Info128;
+            max = pCachePriv->Num128x128;
+            current = &pCachePriv->Current128;
+        }
+        else {
+            cacheRoot = pCachePriv->InfoPartial;
+            max = pCachePriv->NumPartial;
+            current = &pCachePriv->CurrentPartial;
+        }
+    }
+    else if (size <= 256) {
+        cacheRoot = pCachePriv->Info256;
+        max = pCachePriv->Num256x256;
+        current = &pCachePriv->Current256;
+    }
+    else if (size <= 512) {
+        cacheRoot = pCachePriv->Info512;
+        max = pCachePriv->Num512x512;
+        current = &pCachePriv->Current512;
+    }
+    else {                      /* something's wrong */
+        ErrorF("Something's wrong in XAACacheTile()\n");
+        return pCachePriv->Info128;
+    }
+
+    pCache = cacheRoot;
+
+    /* lets look for it */
+    for (i = 0; i < max; i++, pCache++) {
+        if (pCache->serialNumber == pPix->drawable.serialNumber) {
+            pCache->trans_color = -1;
+            return pCache;
+        }
+    }
+
+    pCache = &cacheRoot[(*current)++];
+    if (*current >= max)
+        *current = 0;
+
+    pCache->serialNumber = pPix->drawable.serialNumber;
+    pCache->trans_color = pCache->bg = pCache->fg = -1;
+    pCache->orig_w = w;
+    pCache->orig_h = h;
+    (*infoRec->WritePixmapToCache) (pScrn, pCache->x, pCache->y, w, h,
+                                    pPix->devPrivate.ptr, pPix->devKind,
+                                    pPix->drawable.bitsPerPixel,
+                                    pPix->drawable.depth);
+    if (!(infoRec->PixmapCacheFlags & DO_NOT_TILE_COLOR_DATA) &&
+        ((w != pCache->w) || (h != pCache->h)))
+        XAATileCache(pScrn, pCache, w, h);
+
+    return pCache;
+}
+
+XAACacheInfoPtr
+XAACacheMonoStipple(ScrnInfoPtr pScrn, PixmapPtr pPix)
+{
+    int w = pPix->drawable.width;
+    int h = pPix->drawable.height;
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    XAAPixmapCachePrivatePtr pCachePriv =
+        (XAAPixmapCachePrivatePtr) infoRec->PixmapCachePrivate;
+    XAACacheInfoPtr pCache, cacheRoot = NULL;
+    int i, max = 0, funcNo, pad, dwords, bpp = pScrn->bitsPerPixel;
+    int *current;
+    StippleScanlineProcPtr StippleFunc;
+    unsigned char *data, *srcPtr, *dstPtr;
+
+    if ((h <= 128) && (w <= 128 * bpp)) {
+        if (pCachePriv->Info128) {
+            cacheRoot = pCachePriv->Info128;
+            max = pCachePriv->Num128x128;
+            current = &pCachePriv->Current128;
+        }
+        else {
+            cacheRoot = pCachePriv->InfoPartial;
+            max = pCachePriv->NumPartial;
+            current = &pCachePriv->CurrentPartial;
+        }
+    }
+    else if ((h <= 256) && (w <= 256 * bpp)) {
+        cacheRoot = pCachePriv->Info256;
+        max = pCachePriv->Num256x256;
+        current = &pCachePriv->Current256;
+    }
+    else if ((h <= 512) && (w <= 526 * bpp)) {
+        cacheRoot = pCachePriv->Info512;
+        max = pCachePriv->Num512x512;
+        current = &pCachePriv->Current512;
+    }
+    else {                      /* something's wrong */
+        ErrorF("Something's wrong in XAACacheMonoStipple()\n");
+        return pCachePriv->Info128;
+    }
+
+    pCache = cacheRoot;
+
+    /* lets look for it */
+    for (i = 0; i < max; i++, pCache++) {
+        if ((pCache->serialNumber == pPix->drawable.serialNumber) &&
+            (pCache->fg == -1) && (pCache->bg == -1)) {
+            pCache->trans_color = -1;
+            return pCache;
+        }
+    }
+
+    pCache = &cacheRoot[(*current)++];
+    if (*current >= max)
+        *current = 0;
+
+    pCache->serialNumber = pPix->drawable.serialNumber;
+    pCache->trans_color = pCache->bg = pCache->fg = -1;
+    pCache->orig_w = w;
+    pCache->orig_h = h;
+
+    if (w <= 32) {
+        if (w & (w - 1))
+            funcNo = 1;
+        else
+            funcNo = 0;
+    }
+    else
+        funcNo = 2;
+
+    pad = BitmapBytePad(pCache->w * bpp);
+    dwords = bytes_to_int32(pad);
+    dstPtr = data = (unsigned char *) malloc(pad * pCache->h);
+    srcPtr = (unsigned char *) pPix->devPrivate.ptr;
+
+    if (infoRec->
+        ScreenToScreenColorExpandFillFlags & BIT_ORDER_IN_BYTE_MSBFIRST)
+        StippleFunc = XAAStippleScanlineFuncMSBFirst[funcNo];
+    else
+        StippleFunc = XAAStippleScanlineFuncLSBFirst[funcNo];
+
+    /* don't bother generating more than we'll ever use */
+    max = ((pScrn->displayWidth + w - 1) + 31) >> 5;
+    if (dwords > max)
+        dwords = max;
+
+    for (i = 0; i < h; i++) {
+        (*StippleFunc) ((CARD32 *) dstPtr, (CARD32 *) srcPtr, 0, w, dwords);
+        srcPtr += pPix->devKind;
+        dstPtr += pad;
+    }
+
+    while ((h << 1) <= pCache->h) {
+        memcpy(data + (pad * h), data, pad * h);
+        h <<= 1;
+    }
+
+    if (h < pCache->h)
+        memcpy(data + (pad * h), data, pad * (pCache->h - h));
+
+    (*infoRec->WritePixmapToCache) (pScrn, pCache->x, pCache->y, pCache->w,
+                                    pCache->h, data, pad, bpp, pScrn->depth);
+
+    free(data);
+
+    return pCache;
+}
+
+XAACacheInfoPtr
+XAACachePlanarMonoStipple(ScrnInfoPtr pScrn, PixmapPtr pPix)
+{
+    int w = pPix->drawable.width;
+    int h = pPix->drawable.height;
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    XAAPixmapCachePrivatePtr pCachePriv =
+        (XAAPixmapCachePrivatePtr) infoRec->PixmapCachePrivate;
+    XAACacheInfoPtr pCache, cacheRoot = NULL;
+    int i, max = 0;
+    int *current;
+
+    if ((h <= 128) && (w <= 128)) {
+        if (pCachePriv->Info128) {
+            cacheRoot = pCachePriv->Info128;
+            max = pCachePriv->Num128x128;
+            current = &pCachePriv->Current128;
+        }
+        else {
+            cacheRoot = pCachePriv->InfoPartial;
+            max = pCachePriv->NumPartial;
+            current = &pCachePriv->CurrentPartial;
+        }
+    }
+    else if ((h <= 256) && (w <= 256)) {
+        cacheRoot = pCachePriv->Info256;
+        max = pCachePriv->Num256x256;
+        current = &pCachePriv->Current256;
+    }
+    else if ((h <= 512) && (w <= 526)) {
+        cacheRoot = pCachePriv->Info512;
+        max = pCachePriv->Num512x512;
+        current = &pCachePriv->Current512;
+    }
+    else {                      /* something's wrong */
+        ErrorF("Something's wrong in XAACachePlanarMonoStipple()\n");
+        return pCachePriv->Info128;
+    }
+
+    pCache = cacheRoot;
+
+    /* lets look for it */
+    for (i = 0; i < max; i++, pCache++) {
+        if ((pCache->serialNumber == pPix->drawable.serialNumber) &&
+            (pCache->fg == -1) && (pCache->bg == -1)) {
+            pCache->trans_color = -1;
+            return pCache;
+        }
+    }
+
+    pCache = &cacheRoot[(*current)++];
+    if (*current >= max)
+        *current = 0;
+
+    pCache->serialNumber = pPix->drawable.serialNumber;
+    pCache->trans_color = pCache->bg = pCache->fg = -1;
+    pCache->orig_w = w;
+    pCache->orig_h = h;
+
+    /* Plane 0 holds the stipple. Plane 1 holds the inverted stipple */
+    (*infoRec->WriteBitmapToCache) (pScrn, pCache->x, pCache->y,
+                                    pPix->drawable.width, pPix->drawable.height,
+                                    pPix->devPrivate.ptr, pPix->devKind, 1, 2);
+    if (!(infoRec->PixmapCacheFlags & DO_NOT_TILE_MONO_DATA) &&
+        ((w != pCache->w) || (h != pCache->h)))
+        XAATileCache(pScrn, pCache, w, h);
+
+    return pCache;
+}
+
+XAACachePlanarMonoStippleProc
+XAAGetCachePlanarMonoStipple(void)
+{
+    return XAACachePlanarMonoStipple;
+}
+
+XAACacheInfoPtr
+XAACacheStipple(ScrnInfoPtr pScrn, PixmapPtr pPix, int fg, int bg)
+{
+    int w = pPix->drawable.width;
+    int h = pPix->drawable.height;
+    int size = max(w, h);
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    XAAPixmapCachePrivatePtr pCachePriv =
+        (XAAPixmapCachePrivatePtr) infoRec->PixmapCachePrivate;
+    XAACacheInfoPtr pCache, cacheRoot = NULL;
+    int i, max = 0;
+    int *current;
+
+    if (size <= 128) {
+        if (pCachePriv->Info128) {
+            cacheRoot = pCachePriv->Info128;
+            max = pCachePriv->Num128x128;
+            current = &pCachePriv->Current128;
+        }
+        else {
+            cacheRoot = pCachePriv->InfoPartial;
+            max = pCachePriv->NumPartial;
+            current = &pCachePriv->CurrentPartial;
+        }
+    }
+    else if (size <= 256) {
+        cacheRoot = pCachePriv->Info256;
+        max = pCachePriv->Num256x256;
+        current = &pCachePriv->Current256;
+    }
+    else if (size <= 512) {
+        cacheRoot = pCachePriv->Info512;
+        max = pCachePriv->Num512x512;
+        current = &pCachePriv->Current512;
+    }
+    else {                      /* something's wrong */
+        ErrorF("Something's wrong in XAACacheStipple()\n");
+        return pCachePriv->Info128;
+    }
+
+    pCache = cacheRoot;
+    /* lets look for it */
+    if (bg == -1)
+        for (i = 0; i < max; i++, pCache++) {
+            if ((pCache->serialNumber == pPix->drawable.serialNumber) &&
+                (fg == pCache->fg) && (pCache->fg != pCache->bg)) {
+                pCache->trans_color = pCache->bg;
+                return pCache;
+            }
+        }
+    else
+        for (i = 0; i < max; i++, pCache++) {
+            if ((pCache->serialNumber == pPix->drawable.serialNumber) &&
+                (fg == pCache->fg) && (bg == pCache->bg)) {
+                pCache->trans_color = -1;
+                return pCache;
+            }
+        }
+
+    pCache = &cacheRoot[(*current)++];
+    if (*current >= max)
+        *current = 0;
+
+    pCache->serialNumber = pPix->drawable.serialNumber;
+    pCache->fg = fg;
+    if (bg == -1)
+        pCache->trans_color = bg = fg ^ 1;
+    else
+        pCache->trans_color = -1;
+    pCache->bg = bg;
+
+    pCache->orig_w = w;
+    pCache->orig_h = h;
+    (*infoRec->WriteBitmapToCache) (pScrn, pCache->x, pCache->y,
+                                    pPix->drawable.width, pPix->drawable.height,
+                                    pPix->devPrivate.ptr, pPix->devKind, fg,
+                                    bg);
+    if (!(infoRec->PixmapCacheFlags & DO_NOT_TILE_COLOR_DATA) &&
+        ((w != pCache->w) || (h != pCache->h)))
+        XAATileCache(pScrn, pCache, w, h);
+
+    return pCache;
+}
+
+XAACacheInfoPtr
+XAACacheMono8x8Pattern(ScrnInfoPtr pScrn, int pat0, int pat1)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    XAAPixmapCachePrivatePtr pCachePriv =
+        (XAAPixmapCachePrivatePtr) infoRec->PixmapCachePrivate;
+    XAACacheInfoPtr pCache = pCachePriv->InfoMono;
+    int i;
+
+    for (i = 0; i < pCachePriv->NumMono; i++, pCache++) {
+        if (pCache->serialNumber &&
+            (pCache->pat0 == pat0) && (pCache->pat1 == pat1))
+            return pCache;
+    }
+
+    /* OK, let's cache it */
+    pCache = &pCachePriv->InfoMono[pCachePriv->CurrentMono++];
+    if (pCachePriv->CurrentMono >= pCachePriv->NumMono)
+        pCachePriv->CurrentMono = 0;
+
+    pCache->serialNumber = 1;   /* we don't care since we do lookups by pattern */
+    pCache->pat0 = pat0;
+    pCache->pat1 = pat1;
+
+    (*infoRec->WriteMono8x8PatternToCache) (pScrn, pCache);
+
+    return pCache;
+}
+
+XAACacheInfoPtr
+XAACacheColor8x8Pattern(ScrnInfoPtr pScrn, PixmapPtr pPix, int fg, int bg)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    XAAPixmapCachePrivatePtr pCachePriv =
+        (XAAPixmapCachePrivatePtr) infoRec->PixmapCachePrivate;
+    XAACacheInfoPtr pCache = pCachePriv->InfoColor;
+    XAAPixmapPtr pixPriv = XAA_GET_PIXMAP_PRIVATE(pPix);
+    int i;
+
+    if (!(pixPriv->flags & REDUCIBLE_TO_2_COLOR)) {
+        for (i = 0; i < pCachePriv->NumColor; i++, pCache++) {
+            if (pCache->serialNumber == pPix->drawable.serialNumber) {
+                pCache->trans_color = -1;
+                return pCache;
+            }
+        }
+        pCache = &pCachePriv->InfoColor[pCachePriv->CurrentColor++];
+        if (pCachePriv->CurrentColor >= pCachePriv->NumColor)
+            pCachePriv->CurrentColor = 0;
+
+        pCache->serialNumber = pPix->drawable.serialNumber;
+        pCache->trans_color = pCache->fg = pCache->bg = -1;
+    }
+    else {
+        int pat0 = pixPriv->pattern0;
+        int pat1 = pixPriv->pattern1;
+
+        if (fg == -1) {         /* it's a tile */
+            fg = pixPriv->fg;
+            bg = pixPriv->bg;
+        }
+
+        if (bg == -1) {         /* stipple */
+            for (i = 0; i < pCachePriv->NumColor; i++, pCache++) {
+                if (pCache->serialNumber &&
+                    (pCache->pat0 == pat0) && (pCache->pat1 == pat1) &&
+                    (pCache->fg == fg) && (pCache->bg != fg)) {
+                    pCache->trans_color = pCache->bg;
+                    return pCache;
+                }
+            }
+        }
+        else {                  /* opaque stipple */
+            for (i = 0; i < pCachePriv->NumColor; i++, pCache++) {
+                if (pCache->serialNumber &&
+                    (pCache->pat0 == pat0) && (pCache->pat1 == pat1) &&
+                    (pCache->fg == fg) && (pCache->bg == bg)) {
+                    pCache->trans_color = -1;
+                    return pCache;
+                }
+            }
+        }
+        pCache = &pCachePriv->InfoColor[pCachePriv->CurrentColor++];
+        if (pCachePriv->CurrentColor >= pCachePriv->NumColor)
+            pCachePriv->CurrentColor = 0;
+
+        if (bg == -1)
+            pCache->trans_color = bg = fg ^ 1;
+        else
+            pCache->trans_color = -1;
+
+        pCache->pat0 = pat0;
+        pCache->pat1 = pat1;
+        pCache->fg = fg;
+        pCache->bg = bg;
+        pCache->serialNumber = 1;
+    }
+
+    (*infoRec->WriteColor8x8PatternToCache) (pScrn, pPix, pCache);
+
+    return pCache;
+}
+
+void
+XAAWriteBitmapToCache(ScrnInfoPtr pScrn,
+                      int x, int y, int w, int h,
+                      unsigned char *src, int srcwidth, int fg, int bg)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+
+    (*infoRec->WriteBitmap) (pScrn, x, y, w, h, src, srcwidth,
+                             0, fg, bg, GXcopy, ~0);
+}
+
+void
+XAAWriteBitmapToCacheLinear(ScrnInfoPtr pScrn,
+                            int x, int y, int w, int h,
+                            unsigned char *src, int srcwidth, int fg, int bg)
+{
+    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
+    PixmapPtr pScreenPix, pDstPix;
+    ChangeGCVal gcvals[2];
+    GCPtr pGC;
+
+    pScreenPix = (*pScreen->GetScreenPixmap) (pScreen);
+
+    pDstPix = GetScratchPixmapHeader(pScreen, pScreenPix->drawable.width,
+                                     y + h, pScreenPix->drawable.depth,
+                                     pScreenPix->drawable.bitsPerPixel,
+                                     pScreenPix->devKind,
+                                     pScreenPix->devPrivate.ptr);
+
+    pGC = GetScratchGC(pScreenPix->drawable.depth, pScreen);
+    gcvals[0].val = fg;
+    gcvals[1].val = bg;
+    ChangeGC(NullClient, pGC, GCForeground | GCBackground, gcvals);
+    ValidateGC((DrawablePtr) pDstPix, pGC);
+
+    /* We've unwrapped already so these ops miss a sync */
+    SYNC_CHECK(pScrn);
+
+    (*pGC->ops->PutImage) ((DrawablePtr) pDstPix, pGC, 1, x, y, w, h, 0,
+                           XYBitmap, (void*) src);
+
+    FreeScratchGC(pGC);
+    FreeScratchPixmapHeader(pDstPix);
+}
+
+void
+XAAWritePixmapToCache(ScrnInfoPtr pScrn,
+                      int x, int y, int w, int h,
+                      unsigned char *src, int srcwidth, int bpp, int depth)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+
+    (*infoRec->WritePixmap) (pScrn, x, y, w, h, src, srcwidth,
+                             GXcopy, ~0, -1, bpp, depth);
+}
+
+void
+XAAWritePixmapToCacheLinear(ScrnInfoPtr pScrn,
+                            int x, int y, int w, int h,
+                            unsigned char *src,
+                            int srcwidth, int bpp, int depth)
+{
+    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
+    PixmapPtr pScreenPix, pDstPix;
+    GCPtr pGC;
+
+    pScreenPix = (*pScreen->GetScreenPixmap) (pScreen);
+
+    pDstPix = GetScratchPixmapHeader(pScreen, x + w, y + h,
+                                     depth, bpp, pScreenPix->devKind,
+                                     pScreenPix->devPrivate.ptr);
+
+    pGC = GetScratchGC(depth, pScreen);
+    ValidateGC((DrawablePtr) pDstPix, pGC);
+
+    /* We've unwrapped already so these ops miss a sync */
+    SYNC_CHECK(pScrn);
+
+    if (bpp == BitsPerPixel(depth))
+        (*pGC->ops->PutImage) ((DrawablePtr) pDstPix, pGC, depth, x, y, w,
+                               h, 0, ZPixmap, (void*) src);
+    else {
+        PixmapPtr pSrcPix;
+
+        pSrcPix = GetScratchPixmapHeader(pScreen, w, h, depth, bpp,
+                                         srcwidth, (void*) src);
+
+        (*pGC->ops->CopyArea) ((DrawablePtr) pSrcPix, (DrawablePtr) pDstPix,
+                               pGC, 0, 0, w, h, x, y);
+
+        FreeScratchPixmapHeader(pSrcPix);
+    }
+
+    FreeScratchGC(pGC);
+    FreeScratchPixmapHeader(pDstPix);
+}
+
+void
+XAAWriteMono8x8PatternToCache(ScrnInfoPtr pScrn, XAACacheInfoPtr pCache)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    XAAPixmapCachePrivatePtr pCachePriv =
+        (XAAPixmapCachePrivatePtr) infoRec->PixmapCachePrivate;
+    unsigned char *data;
+    int pad, Bpp = (pScrn->bitsPerPixel >> 3);
+
+    pCache->offsets = pCachePriv->MonoOffsets;
+
+    pad = BitmapBytePad(pCache->w * pScrn->bitsPerPixel);
+
+    data = (unsigned char *) malloc(pad * pCache->h);
+    if (!data)
+        return;
+
+    if (infoRec->Mono8x8PatternFillFlags & HARDWARE_PATTERN_PROGRAMMED_ORIGIN) {
+        CARD32 *ptr = (CARD32 *) data;
+
+        ptr[0] = pCache->pat0;
+        ptr[1] = pCache->pat1;
+    }
+    else {
+        CARD32 *ptr;
+        DDXPointPtr pPoint = pCache->offsets;
+        int patx, paty, i;
+
+        for (i = 0; i < 64; i++, pPoint++) {
+            patx = pCache->pat0;
+            paty = pCache->pat1;
+            XAARotateMonoPattern(&patx, &paty, i & 0x07, i >> 3,
+                                 (infoRec->Mono8x8PatternFillFlags &
+                                  BIT_ORDER_IN_BYTE_MSBFIRST));
+            ptr = (CARD32 *) (data + (pad * pPoint->y) + (Bpp * pPoint->x));
+            ptr[0] = patx;
+            ptr[1] = paty;
+        }
+    }
+
+    (*infoRec->WritePixmapToCache) (pScrn, pCache->x, pCache->y,
+                                    pCache->w, pCache->h, data, pad,
+                                    pScrn->bitsPerPixel, pScrn->depth);
+
+    free(data);
+}
+
+void
+XAAWriteColor8x8PatternToCache(ScrnInfoPtr pScrn,
+                               PixmapPtr pPix, XAACacheInfoPtr pCache)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    XAAPixmapPtr pixPriv = XAA_GET_PIXMAP_PRIVATE(pPix);
+    XAAPixmapCachePrivatePtr pCachePriv =
+        (XAAPixmapCachePrivatePtr) infoRec->PixmapCachePrivate;
+    int pad, i, w, h, nw, nh, Bpp;
+    unsigned char *data, *srcPtr, *dstPtr;
+
+    pCache->offsets = pCachePriv->ColorOffsets;
+
+    if (pixPriv->flags & REDUCIBLE_TO_2_COLOR) {
+        CARD32 *ptr;
+
+        pad = BitmapBytePad(pCache->w);
+        data = (unsigned char *) malloc(pad * pCache->h);
+        if (!data)
+            return;
+
+        if (infoRec->Color8x8PatternFillFlags &
+            HARDWARE_PATTERN_PROGRAMMED_ORIGIN) {
+            ptr = (CARD32 *) data;
+            ptr[0] = pCache->pat0;
+            ptr[1] = pCache->pat1;
+        }
+        else {
+            int patx, paty;
+
+            ptr = (CARD32 *) data;
+            ptr[0] = ptr[2] = pCache->pat0;
+            ptr[1] = ptr[3] = pCache->pat1;
+            for (i = 1; i < 8; i++) {
+                patx = pCache->pat0;
+                paty = pCache->pat1;
+                XAARotateMonoPattern(&patx, &paty, i, 0,
+                                     (infoRec->Mono8x8PatternFillFlags &
+                                      BIT_ORDER_IN_BYTE_MSBFIRST));
+                ptr = (CARD32 *) (data + (pad * i));
+                ptr[0] = ptr[2] = patx;
+                ptr[1] = ptr[3] = paty;
+            }
+        }
+
+        (*infoRec->WriteBitmapToCache) (pScrn, pCache->x, pCache->y,
+                                        pCache->w, pCache->h, data, pad,
+                                        pCache->fg, pCache->bg);
+
+        free(data);
+        return;
+    }
+
+    Bpp = pScrn->bitsPerPixel >> 3;
+    h = min(8, pPix->drawable.height);
+    w = min(8, pPix->drawable.width);
+    pad = BitmapBytePad(pCache->w * pScrn->bitsPerPixel);
+
+    data = (unsigned char *) malloc(pad * pCache->h);
+    if (!data)
+        return;
+
+    /* Write and expand horizontally. */
+    for (i = h, dstPtr = data, srcPtr = pPix->devPrivate.ptr; i--;
+         srcPtr += pPix->devKind, dstPtr += pScrn->bitsPerPixel) {
+        nw = w;
+        memcpy(dstPtr, srcPtr, w * Bpp);
+        while (nw != 8) {
+            memcpy(dstPtr + (nw * Bpp), dstPtr, nw * Bpp);
+            nw <<= 1;
+        }
+    }
+    nh = h;
+    /* Expand vertically. */
+    while (nh != 8) {
+        memcpy(data + (nh * pScrn->bitsPerPixel), data,
+               nh * pScrn->bitsPerPixel);
+        nh <<= 1;
+    }
+
+    if (!(infoRec->Color8x8PatternFillFlags &
+          HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
+        int j;
+        unsigned char *ptr = data + (128 * Bpp);
+
+        memcpy(data + (64 * Bpp), data, 64 * Bpp);
+        for (i = 1; i < 8; i++, ptr += (128 * Bpp)) {
+            for (j = 0; j < 8; j++) {
+                memcpy(ptr + (j * 8) * Bpp, data + (j * 8 + i) * Bpp,
+                       (8 - i) * Bpp);
+                memcpy(ptr + (j * 8 + 8 - i) * Bpp, data + j * 8 * Bpp,
+                       i * Bpp);
+            }
+            memcpy(ptr + (64 * Bpp), ptr, 64 * Bpp);
+        }
+    }
+
+    (*infoRec->WritePixmapToCache) (pScrn, pCache->x, pCache->y,
+                                    pCache->w, pCache->h, data, pad,
+                                    pScrn->bitsPerPixel, pScrn->depth);
+
+    free(data);
+}
+
+int
+XAAStippledFillChooser(GCPtr pGC)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    PixmapPtr pPixmap = pGC->stipple;
+    XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pPixmap);
+
+    if (!(pPriv->flags & REDUCIBILITY_CHECKED) &&
+        (infoRec->CanDoMono8x8 || infoRec->CanDoColor8x8)) {
+        XAACheckStippleReducibility(pPixmap);
+    }
+
+    if (pPriv->flags & REDUCIBLE_TO_8x8) {
+        if (infoRec->CanDoMono8x8 &&
+            !(infoRec->FillMono8x8PatternSpansFlags & NO_TRANSPARENCY) &&
+            ((pGC->alu == GXcopy) || !(infoRec->FillMono8x8PatternSpansFlags &
+                                       TRANSPARENCY_GXCOPY_ONLY)) &&
+            CHECK_ROP(pGC, infoRec->FillMono8x8PatternSpansFlags) &&
+            CHECK_ROPSRC(pGC, infoRec->FillMono8x8PatternSpansFlags) &&
+            CHECK_FG(pGC, infoRec->FillMono8x8PatternSpansFlags) &&
+            CHECK_PLANEMASK(pGC, infoRec->FillMono8x8PatternSpansFlags)) {
+
+            return DO_MONO_8x8;
+        }
+
+        if (infoRec->CanDoColor8x8 &&
+            !(infoRec->FillColor8x8PatternSpansFlags & NO_TRANSPARENCY) &&
+            ((pGC->alu == GXcopy) || !(infoRec->FillColor8x8PatternSpansFlags &
+                                       TRANSPARENCY_GXCOPY_ONLY)) &&
+            CHECK_ROP(pGC, infoRec->FillColor8x8PatternSpansFlags) &&
+            CHECK_ROPSRC(pGC, infoRec->FillColor8x8PatternSpansFlags) &&
+            CHECK_PLANEMASK(pGC, infoRec->FillColor8x8PatternSpansFlags)) {
+
+            return DO_COLOR_8x8;
+        }
+    }
+
+    if (infoRec->UsingPixmapCache && infoRec->FillCacheExpandSpans &&
+        (pPixmap->drawable.height <= infoRec->MaxCacheableStippleHeight) &&
+        (pPixmap->drawable.width <= infoRec->MaxCacheableStippleWidth /
+         infoRec->CacheColorExpandDensity) &&
+        !(infoRec->FillCacheExpandSpansFlags & NO_TRANSPARENCY) &&
+        ((pGC->alu == GXcopy) || !(infoRec->FillCacheExpandSpansFlags &
+                                   TRANSPARENCY_GXCOPY_ONLY)) &&
+        CHECK_ROP(pGC, infoRec->FillCacheExpandSpansFlags) &&
+        CHECK_ROPSRC(pGC, infoRec->FillCacheExpandSpansFlags) &&
+        CHECK_FG(pGC, infoRec->FillCacheExpandSpansFlags) &&
+        CHECK_PLANEMASK(pGC, infoRec->FillCacheExpandSpansFlags)) {
+
+        return DO_CACHE_EXPAND;
+    }
+
+    if (infoRec->UsingPixmapCache &&
+        !(infoRec->PixmapCacheFlags & DO_NOT_BLIT_STIPPLES) &&
+        infoRec->FillCacheBltSpans &&
+        (pPixmap->drawable.height <= infoRec->MaxCacheableTileHeight) &&
+        (pPixmap->drawable.width <= infoRec->MaxCacheableTileWidth) &&
+        !(infoRec->FillCacheBltSpansFlags & NO_TRANSPARENCY) &&
+        ((pGC->alu == GXcopy) || !(infoRec->FillCacheBltSpansFlags &
+                                   TRANSPARENCY_GXCOPY_ONLY)) &&
+        CHECK_ROP(pGC, infoRec->FillCacheBltSpansFlags) &&
+        CHECK_ROPSRC(pGC, infoRec->FillCacheBltSpansFlags) &&
+        CHECK_PLANEMASK(pGC, infoRec->FillCacheBltSpansFlags)) {
+
+        return DO_CACHE_BLT;
+    }
+
+    if (infoRec->FillColorExpandSpans &&
+        !(infoRec->FillColorExpandSpansFlags & NO_TRANSPARENCY) &&
+        ((pGC->alu == GXcopy) || !(infoRec->FillColorExpandSpansFlags &
+                                   TRANSPARENCY_GXCOPY_ONLY)) &&
+        CHECK_ROP(pGC, infoRec->FillColorExpandSpansFlags) &&
+        CHECK_ROPSRC(pGC, infoRec->FillColorExpandSpansFlags) &&
+        CHECK_FG(pGC, infoRec->FillColorExpandSpansFlags) &&
+        CHECK_PLANEMASK(pGC, infoRec->FillColorExpandSpansFlags)) {
+
+        return DO_COLOR_EXPAND;
+    }
+
+    return 0;
+}
+
+int
+XAAOpaqueStippledFillChooser(GCPtr pGC)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    PixmapPtr pPixmap = pGC->stipple;
+    XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pPixmap);
+
+    if (XAA_DEPTH_BUG(pGC))
+        return 0;
+
+    if (!(pPriv->flags & REDUCIBILITY_CHECKED) &&
+        (infoRec->CanDoMono8x8 || infoRec->CanDoColor8x8)) {
+        XAACheckStippleReducibility(pPixmap);
+    }
+
+    if (pPriv->flags & REDUCIBLE_TO_8x8) {
+        if (infoRec->CanDoMono8x8 &&
+            !(infoRec->FillMono8x8PatternSpansFlags & TRANSPARENCY_ONLY) &&
+            CHECK_ROP(pGC, infoRec->FillMono8x8PatternSpansFlags) &&
+            CHECK_ROPSRC(pGC, infoRec->FillMono8x8PatternSpansFlags) &&
+            CHECK_COLORS(pGC, infoRec->FillMono8x8PatternSpansFlags) &&
+            CHECK_PLANEMASK(pGC, infoRec->FillMono8x8PatternSpansFlags)) {
+
+            return DO_MONO_8x8;
+        }
+
+        if (infoRec->CanDoColor8x8 &&
+            CHECK_ROP(pGC, infoRec->FillColor8x8PatternSpansFlags) &&
+            CHECK_ROPSRC(pGC, infoRec->FillColor8x8PatternSpansFlags) &&
+            CHECK_PLANEMASK(pGC, infoRec->FillColor8x8PatternSpansFlags)) {
+
+            return DO_COLOR_8x8;
+        }
+    }
+
+    if (infoRec->UsingPixmapCache && infoRec->FillCacheExpandSpans &&
+        (pPixmap->drawable.height <= infoRec->MaxCacheableStippleHeight) &&
+        (pPixmap->drawable.width <= infoRec->MaxCacheableStippleWidth /
+         infoRec->CacheColorExpandDensity) &&
+        !(infoRec->FillCacheExpandSpansFlags & TRANSPARENCY_ONLY) &&
+        CHECK_ROP(pGC, infoRec->FillCacheExpandSpansFlags) &&
+        CHECK_ROPSRC(pGC, infoRec->FillCacheExpandSpansFlags) &&
+        CHECK_COLORS(pGC, infoRec->FillCacheExpandSpansFlags) &&
+        CHECK_PLANEMASK(pGC, infoRec->FillCacheExpandSpansFlags)) {
+
+        return DO_CACHE_EXPAND;
+    }
+
+    if (infoRec->UsingPixmapCache &&
+        !(infoRec->PixmapCacheFlags & DO_NOT_BLIT_STIPPLES) &&
+        infoRec->FillCacheBltSpans &&
+        (pPixmap->drawable.height <= infoRec->MaxCacheableTileHeight) &&
+        (pPixmap->drawable.width <= infoRec->MaxCacheableTileWidth) &&
+        CHECK_ROP(pGC, infoRec->FillCacheBltSpansFlags) &&
+        CHECK_ROPSRC(pGC, infoRec->FillCacheBltSpansFlags) &&
+        CHECK_PLANEMASK(pGC, infoRec->FillCacheBltSpansFlags)) {
+
+        return DO_CACHE_BLT;
+    }
+
+    if (infoRec->FillColorExpandSpans &&
+        !(infoRec->FillColorExpandSpansFlags & TRANSPARENCY_ONLY) &&
+        CHECK_ROP(pGC, infoRec->FillColorExpandSpansFlags) &&
+        CHECK_ROPSRC(pGC, infoRec->FillColorExpandSpansFlags) &&
+        CHECK_COLORS(pGC, infoRec->FillColorExpandSpansFlags) &&
+        CHECK_PLANEMASK(pGC, infoRec->FillColorExpandSpansFlags)) {
+
+        return DO_COLOR_EXPAND;
+    }
+
+    return 0;
+}
+
+int
+XAATiledFillChooser(GCPtr pGC)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    PixmapPtr pPixmap = pGC->tile.pixmap;
+    XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pPixmap);
+
+    if (IS_OFFSCREEN_PIXMAP(pPixmap) && infoRec->FillCacheBltSpans &&
+        CHECK_ROP(pGC, infoRec->FillCacheBltSpansFlags) &&
+        CHECK_ROPSRC(pGC, infoRec->FillCacheBltSpansFlags) &&
+        CHECK_PLANEMASK(pGC, infoRec->FillCacheBltSpansFlags)) {
+
+        return DO_PIXMAP_COPY;
+    }
+
+    if (!(pPriv->flags & REDUCIBILITY_CHECKED) &&
+        (infoRec->CanDoMono8x8 || infoRec->CanDoColor8x8)) {
+        XAACheckTileReducibility(pPixmap, infoRec->CanDoMono8x8);
+    }
+
+    if (pPriv->flags & REDUCIBLE_TO_8x8) {
+        if ((pPriv->flags & REDUCIBLE_TO_2_COLOR) && infoRec->CanDoMono8x8 &&
+            !(infoRec->FillMono8x8PatternSpansFlags & TRANSPARENCY_ONLY) &&
+            CHECK_ROP(pGC, infoRec->FillMono8x8PatternSpansFlags) &&
+            CHECK_ROPSRC(pGC, infoRec->FillMono8x8PatternSpansFlags) &&
+            (!(infoRec->FillMono8x8PatternSpansFlags & RGB_EQUAL) ||
+             (CHECK_RGB_EQUAL(pPriv->fg) && CHECK_RGB_EQUAL(pPriv->bg))) &&
+            CHECK_PLANEMASK(pGC, infoRec->FillMono8x8PatternSpansFlags)) {
+
+            return DO_MONO_8x8;
+        }
+
+        if (infoRec->CanDoColor8x8 &&
+            CHECK_ROP(pGC, infoRec->FillColor8x8PatternSpansFlags) &&
+            CHECK_ROPSRC(pGC, infoRec->FillColor8x8PatternSpansFlags) &&
+            CHECK_PLANEMASK(pGC, infoRec->FillColor8x8PatternSpansFlags)) {
+
+            return DO_COLOR_8x8;
+        }
+    }
+
+    if (infoRec->UsingPixmapCache && infoRec->FillCacheBltSpans &&
+        (pPixmap->drawable.height <= infoRec->MaxCacheableTileHeight) &&
+        (pPixmap->drawable.width <= infoRec->MaxCacheableTileWidth) &&
+        CHECK_ROP(pGC, infoRec->FillCacheBltSpansFlags) &&
+        CHECK_ROPSRC(pGC, infoRec->FillCacheBltSpansFlags) &&
+        CHECK_PLANEMASK(pGC, infoRec->FillCacheBltSpansFlags)) {
+
+        return DO_CACHE_BLT;
+    }
+
+    if (infoRec->FillImageWriteRects &&
+        CHECK_NO_GXCOPY(pGC, infoRec->FillImageWriteRectsFlags) &&
+        CHECK_ROP(pGC, infoRec->FillImageWriteRectsFlags) &&
+        CHECK_ROPSRC(pGC, infoRec->FillImageWriteRectsFlags) &&
+        CHECK_PLANEMASK(pGC, infoRec->FillImageWriteRectsFlags)) {
+
+        return DO_IMAGE_WRITE;
+    }
+
+    return 0;
+}
+
+static int RotateMasksX[8] = {
+    0xFFFFFFFF, 0x7F7F7F7F, 0x3F3F3F3F, 0x1F1F1F1F,
+    0x0F0F0F0F, 0x07070707, 0x03030303, 0x01010101
+};
+
+static int RotateMasksY[4] = {
+    0xFFFFFFFF, 0x00FFFFFF, 0x0000FFFF, 0x000000FF
+};
+
+void
+XAARotateMonoPattern(int *pat0, int *pat1, int xorg, int yorg, Bool msbfirst)
+{
+    int tmp, mask;
+
+    if (xorg) {
+        if (msbfirst)
+            xorg = 8 - xorg;
+        mask = RotateMasksX[xorg];
+        *pat0 = ((*pat0 >> xorg) & mask) | ((*pat0 << (8 - xorg)) & ~mask);
+        *pat1 = ((*pat1 >> xorg) & mask) | ((*pat1 << (8 - xorg)) & ~mask);
+    }
+    if (yorg >= 4) {
+        tmp = *pat0;
+        *pat0 = *pat1;
+        *pat1 = tmp;
+        yorg -= 4;
+    }
+    if (yorg) {
+        mask = RotateMasksY[yorg];
+        yorg <<= 3;
+        tmp = *pat0;
+        *pat0 = ((*pat0 >> yorg) & mask) | ((*pat1 << (32 - yorg)) & ~mask);
+        *pat1 = ((*pat1 >> yorg) & mask) | ((tmp << (32 - yorg)) & ~mask);
+    }
+}
+
+void
+XAAInvalidatePixmapCache(ScreenPtr pScreen)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
+    XAAPixmapCachePrivatePtr pCachePriv =
+        (XAAPixmapCachePrivatePtr) infoRec->PixmapCachePrivate;
+    int i;
+
+    if (!pCachePriv)
+        return;
+
+    for (i = 0; i < pCachePriv->Num512x512; i++)
+        (pCachePriv->Info512)[i].serialNumber = 0;
+    for (i = 0; i < pCachePriv->Num256x256; i++)
+        (pCachePriv->Info256)[i].serialNumber = 0;
+    for (i = 0; i < pCachePriv->Num128x128; i++)
+        (pCachePriv->Info128)[i].serialNumber = 0;
+    for (i = 0; i < pCachePriv->NumPartial; i++)
+        (pCachePriv->InfoPartial)[i].serialNumber = 0;
+    for (i = 0; i < pCachePriv->NumMono; i++)
+        (pCachePriv->InfoMono)[i].serialNumber = 0;
+    for (i = 0; i < pCachePriv->NumColor; i++)
+        (pCachePriv->InfoColor)[i].serialNumber = 0;
+}
diff --git a/hw/xfree86/xaa/xaaPict.c b/hw/xfree86/xaa/xaaPict.c
new file mode 100644
index 000000000..0721768ed
--- /dev/null
+++ b/hw/xfree86/xaa/xaaPict.c
@@ -0,0 +1,654 @@
+/*
+ *
+ * Copyright © 2000 Keith Packard, member of The XFree86 Project, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <string.h>
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include "pixmapstr.h"
+#include "windowstr.h"
+#include "xf86str.h"
+#include "mi.h"
+#include "picturestr.h"
+#include "glyphstr.h"
+#include "picture.h"
+#include "mipict.h"
+#include "xaa.h"
+#include "xaalocal.h"
+#include "xaawrap.h"
+#include "xaacexp.h"
+#include "xf86fbman.h"
+#include "servermd.h"
+
+Bool
+XAAGetPixelFromRGBA(CARD32 *pixel,
+                    CARD16 red,
+                    CARD16 green, CARD16 blue, CARD16 alpha, CARD32 format)
+{
+    int rbits, bbits, gbits, abits;
+    int rshift, bshift, gshift, ashift;
+
+    *pixel = 0;
+
+    if (!PICT_FORMAT_COLOR(format))
+        return FALSE;
+
+    rbits = PICT_FORMAT_R(format);
+    gbits = PICT_FORMAT_G(format);
+    bbits = PICT_FORMAT_B(format);
+    abits = PICT_FORMAT_A(format);
+
+    if (PICT_FORMAT_TYPE(format) == PICT_TYPE_ARGB) {
+        bshift = 0;
+        gshift = bbits;
+        rshift = gshift + gbits;
+        ashift = rshift + rbits;
+    }
+    else if (PICT_FORMAT_TYPE(format) == PICT_TYPE_ABGR) {
+        rshift = 0;
+        gshift = rbits;
+        bshift = gshift + gbits;
+        ashift = bshift + bbits;
+    }
+    else if (PICT_FORMAT_TYPE(format) == PICT_TYPE_BGRA) {
+        bshift = PICT_FORMAT_BPP(format) - bbits;
+        gshift = bshift - gbits;
+        rshift = gshift - rbits;
+        ashift = 0;
+    }
+    else
+        return FALSE;
+
+    *pixel |= (blue >> (16 - bbits)) << bshift;
+    *pixel |= (red >> (16 - rbits)) << rshift;
+    *pixel |= (green >> (16 - gbits)) << gshift;
+    *pixel |= (alpha >> (16 - abits)) << ashift;
+
+    return TRUE;
+}
+
+Bool
+XAAGetRGBAFromPixel(CARD32 pixel,
+                    CARD16 *red,
+                    CARD16 *green, CARD16 *blue, CARD16 *alpha, CARD32 format)
+{
+    int rbits, bbits, gbits, abits;
+    int rshift, bshift, gshift, ashift;
+
+    if (!PICT_FORMAT_COLOR(format))
+        return FALSE;
+
+    rbits = PICT_FORMAT_R(format);
+    gbits = PICT_FORMAT_G(format);
+    bbits = PICT_FORMAT_B(format);
+    abits = PICT_FORMAT_A(format);
+
+    if (PICT_FORMAT_TYPE(format) == PICT_TYPE_ARGB) {
+        bshift = 0;
+        gshift = bbits;
+        rshift = gshift + gbits;
+        ashift = rshift + rbits;
+    }
+    else if (PICT_FORMAT_TYPE(format) == PICT_TYPE_ABGR) {
+        rshift = 0;
+        gshift = rbits;
+        bshift = gshift + gbits;
+        ashift = bshift + bbits;
+    }
+    else if (PICT_FORMAT_TYPE(format) == PICT_TYPE_BGRA) {
+        bshift = PICT_FORMAT_BPP(format) - bbits;
+        gshift = bshift - gbits;
+        rshift = gshift - rbits;
+        ashift = 0;
+    }
+    else
+        return FALSE;
+
+    *red = ((pixel >> rshift) & ((1 << rbits) - 1)) << (16 - rbits);
+    while (rbits < 16) {
+        *red |= *red >> rbits;
+        rbits <<= 1;
+    }
+
+    *green = ((pixel >> gshift) & ((1 << gbits) - 1)) << (16 - gbits);
+    while (gbits < 16) {
+        *green |= *green >> gbits;
+        gbits <<= 1;
+    }
+
+    *blue = ((pixel >> bshift) & ((1 << bbits) - 1)) << (16 - bbits);
+    while (bbits < 16) {
+        *blue |= *blue >> bbits;
+        bbits <<= 1;
+    }
+
+    if (abits) {
+        *alpha = ((pixel >> ashift) & ((1 << abits) - 1)) << (16 - abits);
+        while (abits < 16) {
+            *alpha |= *alpha >> abits;
+            abits <<= 1;
+        }
+    }
+    else
+        *alpha = 0xffff;
+
+    return TRUE;
+}
+
+/* 8:8:8 + PICT_a8 -> 8:8:8:8 texture */
+
+void
+XAA_888_plus_PICT_a8_to_8888(CARD32 color, CARD8 *alphaPtr,     /* in bytes */
+                             int alphaPitch, CARD32 *dstPtr, int dstPitch,      /* in dwords */
+                             int width, int height)
+{
+    int x;
+
+    color &= 0x00ffffff;
+
+    while (height--) {
+        for (x = 0; x < width; x++)
+            dstPtr[x] = color | (alphaPtr[x] << 24);
+        dstPtr += dstPitch;
+        alphaPtr += alphaPitch;
+    }
+}
+
+#define DRAWABLE_IS_ON_CARD(pDraw) \
+    (pDraw->type == DRAWABLE_WINDOW || \
+     (pDraw->type == DRAWABLE_PIXMAP && IS_OFFSCREEN_PIXMAP(pDraw)))
+
+Bool
+XAADoComposite(CARD8 op,
+               PicturePtr pSrc,
+               PicturePtr pMask,
+               PicturePtr pDst,
+               INT16 xSrc,
+               INT16 ySrc,
+               INT16 xMask,
+               INT16 yMask, INT16 xDst, INT16 yDst, CARD16 width, CARD16 height)
+{
+    ScreenPtr pScreen = pDst->pDrawable->pScreen;
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
+    RegionRec region;
+    CARD32 *formats, *dstformats;
+    int flags = 0;
+    BoxPtr pbox;
+    int nbox, w, h;
+
+    if (!RegionNumRects(pDst->pCompositeClip))
+        return TRUE;
+
+    if (!infoRec->pScrn->vtSema || !DRAWABLE_IS_ON_CARD(pDst->pDrawable))
+        return FALSE;
+
+    if (DRAWABLE_IS_ON_CARD(pSrc->pDrawable))
+        return FALSE;
+
+    if (pSrc->transform || (pMask && pMask->transform))
+        return FALSE;
+
+    if (pDst->alphaMap || pSrc->alphaMap || (pMask && pMask->alphaMap))
+        return FALSE;
+
+    if ((pSrc->repeat && pSrc->repeatType != RepeatNormal) ||
+        (pMask && pMask->repeat && pMask->repeatType != RepeatNormal)) {
+        return FALSE;
+    }
+
+    xDst += pDst->pDrawable->x;
+    yDst += pDst->pDrawable->y;
+    xSrc += pSrc->pDrawable->x;
+    ySrc += pSrc->pDrawable->y;
+
+    if (pMask) {
+        if (pMask->componentAlpha)
+            return FALSE;
+
+        /* for now we only do it if there is a 1x1 (solid) source */
+
+        if ((pSrc->pDrawable->width == 1) && (pSrc->pDrawable->height == 1)) {
+            CARD16 red, green, blue, alpha;
+            CARD32 pixel =
+                *((CARD32 *) (((PixmapPtr) (pSrc->pDrawable))->devPrivate.ptr));
+
+            if (!XAAGetRGBAFromPixel
+                (pixel, &red, &green, &blue, &alpha, pSrc->format))
+                return FALSE;
+
+            xMask += pMask->pDrawable->x;
+            yMask += pMask->pDrawable->y;
+
+            /* pull out color expandable operations here */
+            if ((pMask->format == PICT_a1) && (alpha == 0xffff) &&
+                (op == PictOpOver) && infoRec->WriteBitmap && !pMask->repeat &&
+                !(infoRec->WriteBitmapFlags & NO_TRANSPARENCY) &&
+                (!(infoRec->WriteBitmapFlags & RGB_EQUAL) ||
+                 ((red == green) && (green == blue)))) {
+                PixmapPtr pPix = (PixmapPtr) (pMask->pDrawable);
+                int skipleft;
+
+                if (!miComputeCompositeRegion(&region, pSrc, pMask, pDst,
+                                              xSrc, ySrc, xMask, yMask, xDst,
+                                              yDst, width, height))
+                    return TRUE;
+
+                nbox = RegionNumRects(&region);
+                pbox = RegionRects(&region);
+
+                if (!nbox)
+                    return TRUE;
+
+                XAAGetPixelFromRGBA(&pixel, red, green, blue, 0, pDst->format);
+
+                xMask -= xDst;
+                yMask -= yDst;
+
+                while (nbox--) {
+                    skipleft = pbox->x1 + xMask;
+
+                    (*infoRec->WriteBitmap) (infoRec->pScrn,
+                                             pbox->x1, pbox->y1,
+                                             pbox->x2 - pbox->x1,
+                                             pbox->y2 - pbox->y1,
+                                             (unsigned char *) (pPix->
+                                                                devPrivate.
+                                                                ptr) +
+                                             (pPix->devKind *
+                                              (pbox->y1 + yMask)) +
+                                             ((skipleft >> 3) & ~3),
+                                             pPix->devKind, skipleft & 31,
+                                             pixel, -1, GXcopy, ~0);
+                    pbox++;
+                }
+
+                /* WriteBitmap sets the Sync flag */
+                RegionUninit(&region);
+                return TRUE;
+            }
+
+            formats = infoRec->CPUToScreenAlphaTextureFormats;
+            dstformats = infoRec->CPUToScreenAlphaTextureDstFormats;
+            if (!formats || !dstformats)
+                return FALSE;
+
+            w = pMask->pDrawable->width;
+            h = pMask->pDrawable->height;
+
+            if (pMask->repeat) {
+                if ((infoRec->CPUToScreenAlphaTextureFlags & XAA_RENDER_NO_TILE)
+                    ||
+                    ((infoRec->
+                      CPUToScreenAlphaTextureFlags &
+                      XAA_RENDER_POWER_OF_2_TILE_ONLY) && ((h & (h - 1)) ||
+                                                           (w & (w - 1))))) {
+                    return FALSE;
+                }
+                flags |= XAA_RENDER_REPEAT;
+            }
+
+            if ((alpha != 0xffff) &&
+                (infoRec->
+                 CPUToScreenAlphaTextureFlags & XAA_RENDER_NO_SRC_ALPHA))
+                return FALSE;
+
+            while (*formats != pMask->format) {
+                if (!(*formats))
+                    return FALSE;
+                formats++;
+            }
+            while (*dstformats != pDst->format) {
+                if (!(*dstformats))
+                    return FALSE;
+                dstformats++;
+            }
+
+            if (!miComputeCompositeRegion(&region, pSrc, pMask, pDst,
+                                          xSrc, ySrc, xMask, yMask, xDst, yDst,
+                                          width, height))
+                return TRUE;
+
+            nbox = RegionNumRects(&region);
+            pbox = RegionRects(&region);
+
+            if (!nbox) {
+                RegionUninit(&region);
+                return TRUE;
+            }
+
+            if (!(infoRec->SetupForCPUToScreenAlphaTexture2) (infoRec->pScrn,
+                                                              op, red, green,
+                                                              blue, alpha,
+                                                              pMask->format,
+                                                              pDst->format,
+                                                              ((PixmapPtr)
+                                                               (pMask->
+                                                                pDrawable))->
+                                                              devPrivate.ptr,
+                                                              ((PixmapPtr)
+                                                               (pMask->
+                                                                pDrawable))->
+                                                              devKind, w, h,
+                                                              flags)) {
+                RegionUninit(&region);
+                return FALSE;
+            }
+
+            xMask -= xDst;
+            yMask -= yDst;
+
+            while (nbox--) {
+                (*infoRec->SubsequentCPUToScreenAlphaTexture) (infoRec->pScrn,
+                                                               pbox->x1,
+                                                               pbox->y1,
+                                                               pbox->x1 + xMask,
+                                                               pbox->y1 + yMask,
+                                                               pbox->x2 -
+                                                               pbox->x1,
+                                                               pbox->y2 -
+                                                               pbox->y1);
+                pbox++;
+            }
+
+            SET_SYNC_FLAG(infoRec);
+            RegionUninit(&region);
+            return TRUE;
+        }
+    }
+    else {
+        formats = infoRec->CPUToScreenTextureFormats;
+        dstformats = infoRec->CPUToScreenTextureDstFormats;
+        if (!formats || !dstformats)
+            return FALSE;
+
+        w = pSrc->pDrawable->width;
+        h = pSrc->pDrawable->height;
+
+        if (pSrc->repeat) {
+            if ((infoRec->CPUToScreenTextureFlags & XAA_RENDER_NO_TILE) ||
+                ((infoRec->CPUToScreenTextureFlags &
+                  XAA_RENDER_POWER_OF_2_TILE_ONLY) &&
+                 ((h & (h - 1)) || (w & (w - 1))))) {
+                return FALSE;
+            }
+            flags |= XAA_RENDER_REPEAT;
+        }
+
+        while (*formats != pSrc->format) {
+            if (!(*formats))
+                return FALSE;
+            formats++;
+        }
+        while (*dstformats != pDst->format) {
+            if (!(*dstformats))
+                return FALSE;
+            dstformats++;
+        }
+
+        if (!miComputeCompositeRegion(&region, pSrc, pMask, pDst,
+                                      xSrc, ySrc, xMask, yMask, xDst, yDst,
+                                      width, height))
+            return TRUE;
+
+        nbox = RegionNumRects(&region);
+        pbox = RegionRects(&region);
+
+        if (!nbox) {
+            RegionUninit(&region);
+            return TRUE;
+        }
+
+        if (!(infoRec->SetupForCPUToScreenTexture2) (infoRec->pScrn,
+                                                     op, pSrc->format,
+                                                     pDst->format,
+                                                     ((PixmapPtr)
+                                                      (pSrc->pDrawable))->
+                                                     devPrivate.ptr,
+                                                     ((PixmapPtr)
+                                                      (pSrc->pDrawable))->
+                                                     devKind, w, h, flags)) {
+            RegionUninit(&region);
+            return FALSE;
+        }
+
+        xSrc -= xDst;
+        ySrc -= yDst;
+
+        while (nbox--) {
+            (*infoRec->SubsequentCPUToScreenTexture) (infoRec->pScrn,
+                                                      pbox->x1, pbox->y1,
+                                                      pbox->x1 + xSrc,
+                                                      pbox->y1 + ySrc,
+                                                      pbox->x2 - pbox->x1,
+                                                      pbox->y2 - pbox->y1);
+            pbox++;
+        }
+
+        SET_SYNC_FLAG(infoRec);
+        RegionUninit(&region);
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+static void
+XAACompositeSrcCopy(PicturePtr pSrc,
+                    PicturePtr pDst,
+                    INT16 xSrc,
+                    INT16 ySrc,
+                    INT16 xDst, INT16 yDst, CARD16 width, CARD16 height)
+{
+    ScreenPtr pScreen = pDst->pDrawable->pScreen;
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
+    int i, nbox;
+    int xoff, yoff;
+    BoxPtr pbox;
+    DDXPointPtr pptSrc;
+    RegionRec region;
+
+    xDst += pDst->pDrawable->x;
+    yDst += pDst->pDrawable->y;
+    xSrc += pSrc->pDrawable->x;
+    ySrc += pSrc->pDrawable->y;
+
+    if (!miComputeCompositeRegion(&region, pSrc, NULL, pDst,
+                                  xSrc, ySrc, 0, 0, xDst, yDst, width, height))
+        return;
+
+    nbox = RegionNumRects(&region);
+    pbox = RegionRects(&region);
+
+    if (!nbox) {
+        RegionUninit(&region);
+        return;
+    }
+    pptSrc = malloc(sizeof(DDXPointRec) * nbox);
+    if (!pptSrc) {
+        RegionUninit(&region);
+        return;
+    }
+    xoff = xSrc - xDst;
+    yoff = ySrc - yDst;
+    for (i = 0; i < nbox; i++) {
+        pptSrc[i].x = pbox[i].x1 + xoff;
+        pptSrc[i].y = pbox[i].y1 + yoff;
+    }
+
+    infoRec->ScratchGC.planemask = ~0L;
+    infoRec->ScratchGC.alu = GXcopy;
+
+    XAADoBitBlt(pSrc->pDrawable, pDst->pDrawable, &infoRec->ScratchGC, &region,
+                pptSrc);
+
+    free(pptSrc);
+    RegionUninit(&region);
+    return;
+}
+
+void
+XAAComposite(CARD8 op,
+             PicturePtr pSrc,
+             PicturePtr pMask,
+             PicturePtr pDst,
+             INT16 xSrc,
+             INT16 ySrc,
+             INT16 xMask,
+             INT16 yMask, INT16 xDst, INT16 yDst, CARD16 width, CARD16 height)
+{
+    ScreenPtr pScreen = pDst->pDrawable->pScreen;
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
+
+    XAA_RENDER_PROLOGUE(pScreen, Composite);
+
+    if (!pMask && infoRec->pScrn->vtSema &&
+        infoRec->ScreenToScreenBitBlt &&
+        pSrc->pDrawable &&
+        DRAWABLE_IS_ON_CARD(pSrc->pDrawable) &&
+        DRAWABLE_IS_ON_CARD(pDst->pDrawable) &&
+        !pSrc->transform &&
+        (!pSrc->repeat || (xSrc >= 0 && ySrc >= 0 &&
+                           xSrc + width <= pSrc->pDrawable->width &&
+                           ySrc + height <= pSrc->pDrawable->height)) &&
+        ((op == PictOpSrc &&
+          ((pSrc->format == pDst->format) ||
+           (pSrc->format == PICT_a8r8g8b8 && pDst->format == PICT_x8r8g8b8) ||
+           (pSrc->format == PICT_a8b8g8r8 && pDst->format == PICT_x8b8g8r8))) ||
+         (op == PictOpOver && !pSrc->alphaMap && !pDst->alphaMap &&
+          pSrc->format == pDst->format &&
+          (pSrc->format == PICT_x8r8g8b8 || pSrc->format == PICT_x8b8g8r8)))) {
+        XAACompositeSrcCopy(pSrc, pDst, xSrc, ySrc, xDst, yDst, width, height);
+    }
+    else if (!pSrc->pDrawable || (pMask && !pMask->pDrawable) ||
+             !infoRec->Composite ||
+             !(*infoRec->Composite) (op, pSrc, pMask, pDst,
+                                     xSrc, ySrc, xMask, yMask, xDst, yDst,
+                                     width, height)) {
+        if (infoRec->pScrn->vtSema &&
+            ((pSrc->pDrawable &&
+              (pSrc->pDrawable->type == DRAWABLE_WINDOW ||
+               IS_OFFSCREEN_PIXMAP(pSrc->pDrawable))) ||
+             pDst->pDrawable->type == DRAWABLE_WINDOW ||
+             IS_OFFSCREEN_PIXMAP(pDst->pDrawable))) {
+            SYNC_CHECK(pDst->pDrawable);
+        }
+        (*GetPictureScreen(pScreen)->Composite) (op,
+                                                 pSrc,
+                                                 pMask,
+                                                 pDst,
+                                                 xSrc,
+                                                 ySrc,
+                                                 xMask,
+                                                 yMask,
+                                                 xDst, yDst, width, height);
+    }
+
+    if (pDst->pDrawable->type == DRAWABLE_PIXMAP)
+        (XAA_GET_PIXMAP_PRIVATE((PixmapPtr) (pDst->pDrawable)))->flags |= DIRTY;
+
+    XAA_RENDER_EPILOGUE(pScreen, Composite, XAAComposite);
+}
+
+Bool
+XAADoGlyphs(CARD8 op,
+            PicturePtr pSrc,
+            PicturePtr pDst,
+            PictFormatPtr maskFormat,
+            INT16 xSrc,
+            INT16 ySrc, int nlist, GlyphListPtr list, GlyphPtr * glyphs)
+{
+    ScreenPtr pScreen = pDst->pDrawable->pScreen;
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
+
+    if (!RegionNumRects(pDst->pCompositeClip))
+        return TRUE;
+
+    if (!infoRec->pScrn->vtSema ||
+        ((pDst->pDrawable->type != DRAWABLE_WINDOW) &&
+         !IS_OFFSCREEN_PIXMAP(pDst->pDrawable)))
+        return FALSE;
+
+    if ((pSrc->pDrawable->type != DRAWABLE_PIXMAP) ||
+        IS_OFFSCREEN_PIXMAP(pSrc->pDrawable))
+        return FALSE;
+
+    /*
+     * If it looks like we have a chance of being able to draw these
+     * glyphs with an accelerated Composite, do that now to avoid
+     * unneeded and costly syncs.
+     */
+    if (maskFormat) {
+        if (!infoRec->CPUToScreenAlphaTextureFormats)
+            return FALSE;
+    }
+    else {
+        if (!infoRec->CPUToScreenTextureFormats)
+            return FALSE;
+    }
+
+    miGlyphs(op, pSrc, pDst, maskFormat, xSrc, ySrc, nlist, list, glyphs);
+
+    return TRUE;
+}
+
+void
+XAAGlyphs(CARD8 op,
+          PicturePtr pSrc,
+          PicturePtr pDst,
+          PictFormatPtr maskFormat,
+          INT16 xSrc,
+          INT16 ySrc, int nlist, GlyphListPtr list, GlyphPtr * glyphs)
+{
+    ScreenPtr pScreen = pDst->pDrawable->pScreen;
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCREEN(pScreen);
+
+    XAA_RENDER_PROLOGUE(pScreen, Glyphs);
+
+    if (!pSrc->pDrawable || !infoRec->Glyphs ||
+        !(*infoRec->Glyphs) (op, pSrc, pDst, maskFormat,
+                             xSrc, ySrc, nlist, list, glyphs)) {
+        if (infoRec->pScrn->vtSema &&
+            ((pSrc->pDrawable &&
+              (pSrc->pDrawable->type == DRAWABLE_WINDOW ||
+               IS_OFFSCREEN_PIXMAP(pSrc->pDrawable))) ||
+             pDst->pDrawable->type == DRAWABLE_WINDOW ||
+             IS_OFFSCREEN_PIXMAP(pDst->pDrawable))) {
+            SYNC_CHECK(pDst->pDrawable);
+        }
+        (*GetPictureScreen(pScreen)->Glyphs) (op, pSrc, pDst, maskFormat,
+                                              xSrc, ySrc, nlist, list, glyphs);
+    }
+
+    if (pDst->pDrawable->type == DRAWABLE_PIXMAP)
+        (XAA_GET_PIXMAP_PRIVATE((PixmapPtr) (pDst->pDrawable)))->flags |= DIRTY;
+
+    XAA_RENDER_EPILOGUE(pScreen, Glyphs, XAAGlyphs);
+}
diff --git a/hw/xfree86/xaa/xaaROP.c b/hw/xfree86/xaa/xaaROP.c
new file mode 100644
index 000000000..3b6ec9385
--- /dev/null
+++ b/hw/xfree86/xaa/xaaROP.c
@@ -0,0 +1,182 @@
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <X11/X.h>
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include "scrnintstr.h"
+#include "xf86str.h"
+#include "xaarop.h"
+#include "xaa.h"
+#include "xaalocal.h"
+
+int XAACopyROP[16] = {
+    ROP_0,                      /* GXclear */
+    ROP_DSa,                    /* GXand */
+    ROP_SDna,                   /* GXandReverse */
+    ROP_S,                      /* GXcopy */
+    ROP_DSna,                   /* GXandInverted */
+    ROP_D,                      /* GXnoop */
+    ROP_DSx,                    /* GXxor */
+    ROP_DSo,                    /* GXor */
+    ROP_DSon,                   /* GXnor */
+    ROP_DSxn,                   /* GXequiv */
+    ROP_Dn,                     /* GXinvert */
+    ROP_SDno,                   /* GXorReverse */
+    ROP_Sn,                     /* GXcopyInverted */
+    ROP_DSno,                   /* GXorInverted */
+    ROP_DSan,                   /* GXnand */
+    ROP_1                       /* GXset */
+};
+
+int XAACopyROP_PM[16] = {
+    ROP_0,                      /* not used */
+    ROP_DSPnoa,
+    ROP_DPSnaon,
+    ROP_DPSDxax,
+    ROP_DPSana,
+    ROP_D,                      /* not used */
+    ROP_DPSax,
+    ROP_DPSao,
+    ROP_DPSaon,
+    ROP_DPSaxn,
+    ROP_Dn,                     /* not used */
+    ROP_DPSanan,
+    ROP_PSDPxox,                /* is that correct ? */
+    ROP_DPSnao,
+    ROP_DSPnoan,
+    ROP_1                       /* not used */
+};
+
+int XAAPatternROP[16] = {
+    ROP_0,
+    ROP_DPa,
+    ROP_PDna,
+    ROP_P,
+    ROP_DPna,
+    ROP_D,
+    ROP_DPx,
+    ROP_DPo,
+    ROP_DPon,
+    ROP_PDxn,
+    ROP_Dn,
+    ROP_PDno,
+    ROP_Pn,
+    ROP_DPno,
+    ROP_DPan,
+    ROP_1
+};
+
+int XAAPatternROP_PM[16] = {
+    ROP_DPna,
+    ROP_DPSnoa,
+    ROP_DSPnaon,
+    ROP_DSPDxax,
+    ROP_DPSana,
+    ROP_D,
+    ROP_DPSax,
+    ROP_DPSao,
+    ROP_DPSaon,
+    ROP_DPSaxn,
+    ROP_DPx,
+    ROP_DPSanan,
+    ROP_SPDSxox,                /* is that correct ? */
+    ROP_DSPnao,
+    ROP_DPSnoan,
+    ROP_DPo
+};
+
+int
+XAAGetCopyROP(int i)
+{
+    return XAACopyROP[i];
+}
+
+int
+XAAGetCopyROP_PM(int i)
+{
+    return XAACopyROP_PM[i];
+}
+
+int
+XAAGetPatternROP(int i)
+{
+    return XAAPatternROP[i];
+}
+
+int
+XAAGetPatternROP_PM(int i)
+{
+    return XAAPatternROP_PM[i];
+}
+
+int
+XAAHelpPatternROP(ScrnInfoPtr pScrn, int *fg, int *bg, int pm, int *rop)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int ret = 0;
+
+    pm &= infoRec->FullPlanemasks[pScrn->depth - 1];
+
+    if (pm == infoRec->FullPlanemasks[pScrn->depth - 1]) {
+        if (!NO_SRC_ROP(*rop))
+            ret |= ROP_PAT;
+        *rop = XAAPatternROP[*rop];
+    }
+    else {
+        switch (*rop) {
+        case GXnoop:
+            break;
+        case GXset:
+        case GXclear:
+        case GXinvert:
+            ret |= ROP_PAT;
+            *fg = pm;
+            if (*bg != -1)
+                *bg = pm;
+            break;
+        default:
+            ret |= ROP_PAT | ROP_SRC;
+            break;
+        }
+        *rop = XAAPatternROP_PM[*rop];
+    }
+
+    return ret;
+}
+
+int
+XAAHelpSolidROP(ScrnInfoPtr pScrn, int *fg, int pm, int *rop)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int ret = 0;
+
+    pm &= infoRec->FullPlanemasks[pScrn->depth - 1];
+
+    if (pm == infoRec->FullPlanemasks[pScrn->depth - 1]) {
+        if (!NO_SRC_ROP(*rop))
+            ret |= ROP_PAT;
+        *rop = XAAPatternROP[*rop];
+    }
+    else {
+        switch (*rop) {
+        case GXnoop:
+            break;
+        case GXset:
+        case GXclear:
+        case GXinvert:
+            ret |= ROP_PAT;
+            *fg = pm;
+            break;
+        default:
+            ret |= ROP_PAT | ROP_SRC;
+            break;
+        }
+        *rop = XAAPatternROP_PM[*rop];
+    }
+
+    return ret;
+}
diff --git a/hw/xfree86/xaa/xaaRect.c b/hw/xfree86/xaa/xaaRect.c
new file mode 100644
index 000000000..002090085
--- /dev/null
+++ b/hw/xfree86/xaa/xaaRect.c
@@ -0,0 +1,121 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include "pixmapstr.h"
+#include "xf86str.h"
+#include "xaa.h"
+#include "xaalocal.h"
+
+/*
+   Much of this file based on code by 
+	Harm Hanemaayer (H.Hanemaayer@inter.nl.net).
+*/
+
+void
+XAAPolyRectangleThinSolid(DrawablePtr pDrawable,
+                          GCPtr pGC, int nRectsInit, xRectangle *pRectsInit)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    int nClipRects;             /* number of clip rectangles */
+    BoxPtr pClipRects;          /* points to the list of clip rects */
+    int xOrigin;                /* Drawables x origin */
+    int yOrigin;                /* Drawables x origin */
+    xRectangle *pRect;          /* list of rects */
+    int nRects;                 /* running count of number of rects */
+    int origX1, origY1;         /* original rectangle's U/L corner */
+    int origX2, origY2;         /* original rectangle's L/R corner */
+    int clippedX1;              /* clipped rectangle's left x */
+    int clippedY1;              /* clipped rectangle's top y */
+    int clippedX2;              /* clipped rectangle's right x */
+    int clippedY2;              /* clipped rectangle's bottom y */
+    int clipXMin;               /* upper left corner of clip rect */
+    int clipYMin;               /* upper left corner of clip rect */
+    int clipXMax;               /* lower right corner of clip rect */
+    int clipYMax;               /* lower right corner of clip rect */
+    int width, height;          /* width and height of rect */
+
+    nClipRects = RegionNumRects(pGC->pCompositeClip);
+    pClipRects = RegionRects(pGC->pCompositeClip);
+
+    if (!nClipRects)
+        return;
+
+    xOrigin = pDrawable->x;
+    yOrigin = pDrawable->y;
+
+    (*infoRec->SetupForSolidLine) (infoRec->pScrn,
+                                   pGC->fgPixel, pGC->alu, pGC->planemask);
+
+    for (; nClipRects > 0; nClipRects--, pClipRects++) {
+        clipYMin = pClipRects->y1;
+        clipYMax = pClipRects->y2 - 1;
+        clipXMin = pClipRects->x1;
+        clipXMax = pClipRects->x2 - 1;
+
+        for (pRect = pRectsInit, nRects = nRectsInit;
+             nRects > 0; nRects--, pRect++) {
+            /* translate rectangle data over to the drawable */
+            origX1 = pRect->x + xOrigin;
+            origY1 = pRect->y + yOrigin;
+            origX2 = origX1 + pRect->width;
+            origY2 = origY1 + pRect->height;
+
+            /* reject entire rectangle if completely outside clip rect */
+            if ((origX1 > clipXMax) || (origX2 < clipXMin) ||
+                (origY1 > clipYMax) || (origY2 < clipYMin))
+                continue;
+
+            /* clip the rectangle */
+            clippedX1 = max(origX1, clipXMin);
+            clippedX2 = min(origX2, clipXMax);
+            clippedY1 = max(origY1, clipYMin);
+            clippedY2 = min(origY2, clipYMax);
+
+            width = clippedX2 - clippedX1 + 1;
+
+            if (origY1 >= clipYMin) {
+                (*infoRec->SubsequentSolidHorVertLine) (infoRec->pScrn,
+                                                        clippedX1, clippedY1,
+                                                        width, DEGREES_0);
+
+                /* don't overwrite corner */
+                clippedY1++;
+            }
+
+            if ((origY2 <= clipYMax) && (origY1 != origY2)) {
+                (*infoRec->SubsequentSolidHorVertLine) (infoRec->pScrn,
+                                                        clippedX1, clippedY2,
+                                                        width, DEGREES_0);
+
+                /* don't overwrite corner */
+                clippedY2--;
+            }
+
+            if (clippedY2 < clippedY1)
+                continue;
+
+            height = clippedY2 - clippedY1 + 1;
+
+            /* draw vertical edges using lines if not clipped out */
+            if (origX1 >= clipXMin)
+                (*infoRec->SubsequentSolidHorVertLine) (infoRec->pScrn,
+                                                        clippedX1, clippedY1,
+                                                        height, DEGREES_270);
+
+            if ((origX2 <= clipXMax) && (origX2 != origX1))
+                (*infoRec->SubsequentSolidHorVertLine) (infoRec->pScrn,
+                                                        clippedX2, clippedY1,
+                                                        height, DEGREES_270);
+        }
+    }
+
+    SET_SYNC_FLAG(infoRec);
+}
diff --git a/hw/xfree86/xaa/xaaSpans.c b/hw/xfree86/xaa/xaaSpans.c
new file mode 100644
index 000000000..f03452a46
--- /dev/null
+++ b/hw/xfree86/xaa/xaaSpans.c
@@ -0,0 +1,876 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include "pixmapstr.h"
+#include "xf86str.h"
+#include "mi.h"
+#include "mispans.h"
+#include "xaa.h"
+#include "xaalocal.h"
+
+static void XAARenderSolidSpans(GCPtr, int, DDXPointPtr, int *, int, int, int);
+static void XAARenderColor8x8Spans(GCPtr, int, DDXPointPtr, int *, int, int,
+                                   int);
+static void XAARenderMono8x8Spans(GCPtr, int, DDXPointPtr, int *, int, int,
+                                  int);
+static void XAARenderCacheBltSpans(GCPtr, int, DDXPointPtr, int *, int, int,
+                                   int);
+static void XAARenderColorExpandSpans(GCPtr, int, DDXPointPtr, int *, int, int,
+                                      int);
+static void XAARenderCacheExpandSpans(GCPtr, int, DDXPointPtr, int *, int, int,
+                                      int);
+static void XAARenderPixmapCopySpans(GCPtr, int, DDXPointPtr, int *, int, int,
+                                     int);
+
+void
+XAAFillSpans(DrawablePtr pDraw, GC * pGC, int nInit,    /* number of spans to fill */
+             DDXPointPtr pptInit,       /* pointer to list of start points */
+             int *pwidthInit,   /* pointer to list of n widths */
+             int fSorted)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    int type = 0;
+    ClipAndRenderSpansFunc function;
+    Bool fastClip = FALSE;
+
+    if ((nInit <= 0) || !pGC->planemask)
+        return;
+
+    if (!RegionNumRects(pGC->pCompositeClip))
+        return;
+
+    switch (pGC->fillStyle) {
+    case FillSolid:
+        type = DO_SOLID;
+        break;
+    case FillStippled:
+        type = (*infoRec->StippledFillChooser) (pGC);
+        break;
+    case FillOpaqueStippled:
+        if ((pGC->fgPixel == pGC->bgPixel) && infoRec->FillSpansSolid &&
+            CHECK_PLANEMASK(pGC, infoRec->FillSpansSolidFlags) &&
+            CHECK_ROP(pGC, infoRec->FillSpansSolidFlags) &&
+            CHECK_ROPSRC(pGC, infoRec->FillSpansSolidFlags) &&
+            CHECK_FG(pGC, infoRec->FillSpansSolidFlags))
+            type = DO_SOLID;
+        else
+            type = (*infoRec->OpaqueStippledFillChooser) (pGC);
+        break;
+    case FillTiled:
+        type = (*infoRec->TiledFillChooser) (pGC);
+        break;
+    }
+
+    switch (type) {
+    case DO_SOLID:
+        function = XAARenderSolidSpans;
+        if (infoRec->ClippingFlags & HARDWARE_CLIP_SOLID_FILL)
+            fastClip = TRUE;
+        break;
+    case DO_COLOR_8x8:
+        function = XAARenderColor8x8Spans;
+        if (infoRec->ClippingFlags & HARDWARE_CLIP_COLOR_8x8_FILL)
+            fastClip = TRUE;
+        break;
+    case DO_MONO_8x8:
+        function = XAARenderMono8x8Spans;
+        if (infoRec->ClippingFlags & HARDWARE_CLIP_MONO_8x8_FILL)
+            fastClip = TRUE;
+        break;
+    case DO_CACHE_BLT:
+        function = XAARenderCacheBltSpans;
+        if (infoRec->ClippingFlags & HARDWARE_CLIP_SCREEN_TO_SCREEN_COPY)
+            fastClip = TRUE;
+        break;
+    case DO_COLOR_EXPAND:
+        function = XAARenderColorExpandSpans;
+        break;
+    case DO_CACHE_EXPAND:
+        function = XAARenderCacheExpandSpans;
+        if (infoRec->ClippingFlags &
+            HARDWARE_CLIP_SCREEN_TO_SCREEN_COLOR_EXPAND)
+            fastClip = TRUE;
+        break;
+    case DO_PIXMAP_COPY:
+        function = XAARenderPixmapCopySpans;
+        if (infoRec->ClippingFlags & HARDWARE_CLIP_SCREEN_TO_SCREEN_COPY)
+            fastClip = TRUE;
+        break;
+    case DO_IMAGE_WRITE:
+    default:
+        (*XAAFallbackOps.FillSpans) (pDraw, pGC, nInit, pptInit,
+                                     pwidthInit, fSorted);
+        return;
+    }
+
+    if ((nInit < 10) || (RegionNumRects(pGC->pCompositeClip) != 1))
+        fastClip = FALSE;
+
+    if (fastClip) {
+        infoRec->ClipBox = &pGC->pCompositeClip->extents;
+        (*function) (pGC, nInit, pptInit, pwidthInit, fSorted,
+                     pDraw->x, pDraw->y);
+        infoRec->ClipBox = NULL;
+    }
+    else
+        XAAClipAndRenderSpans(pGC, pptInit, pwidthInit, nInit, fSorted,
+                              function, pDraw->x, pDraw->y);
+}
+
+        /*********************\
+	|     Solid Spans     |
+	\*********************/
+
+static void
+XAARenderSolidSpans(GCPtr pGC,
+                    int n,
+                    DDXPointPtr ppt,
+                    int *pwidth, int fSorted, int xorg, int yorg)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+
+    (*infoRec->FillSolidSpans) (infoRec->pScrn, pGC->fgPixel,
+                                pGC->alu, pGC->planemask, n, ppt, pwidth,
+                                fSorted);
+}
+
+        /************************\
+	|     Mono 8x8 Spans     |
+	\************************/
+
+static void
+XAARenderMono8x8Spans(GCPtr pGC,
+                      int n,
+                      DDXPointPtr ppt,
+                      int *pwidth, int fSorted, int xorg, int yorg)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    XAAPixmapPtr pPriv;
+    int fg, bg;
+
+    switch (pGC->fillStyle) {
+    case FillStippled:
+        pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->stipple);
+        fg = pGC->fgPixel;
+        bg = -1;
+        break;
+    case FillOpaqueStippled:
+        pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->stipple);
+        fg = pGC->fgPixel;
+        bg = pGC->bgPixel;
+        break;
+    case FillTiled:
+        pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);
+        fg = pPriv->fg;
+        bg = pPriv->bg;
+        break;
+    default:                   /* Muffle compiler */
+        pPriv = NULL;           /* Kaboom */
+        fg = -1;
+        bg = -1;
+        break;
+    }
+
+    (*infoRec->FillMono8x8PatternSpans) (infoRec->pScrn,
+                                         fg, bg, pGC->alu, pGC->planemask,
+                                         n, ppt, pwidth, fSorted,
+                                         pPriv->pattern0, pPriv->pattern1,
+                                         (xorg + pGC->patOrg.x),
+                                         (yorg + pGC->patOrg.y));
+}
+
+        /*************************\
+	|     Color 8x8 Spans     |
+	\*************************/
+
+static void
+XAARenderColor8x8Spans(GCPtr pGC,
+                       int n,
+                       DDXPointPtr ppt,
+                       int *pwidth, int fSorted, int xorg, int yorg)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    XAACacheInfoPtr pCache;
+    PixmapPtr pPix;
+    int fg, bg;
+
+    switch (pGC->fillStyle) {
+    case FillStippled:
+        pPix = pGC->stipple;
+        fg = pGC->fgPixel;
+        bg = -1;
+        break;
+    case FillOpaqueStippled:
+        pPix = pGC->stipple;
+        fg = pGC->fgPixel;
+        bg = pGC->bgPixel;
+        break;
+    case FillTiled:
+        pPix = pGC->tile.pixmap;
+        fg = -1;
+        bg = -1;
+        break;
+    default:                   /* Muffle compiler */
+        pPix = NULL;
+        fg = -1;
+        bg = -1;
+        break;
+    }
+
+    pCache = (*infoRec->CacheColor8x8Pattern) (infoRec->pScrn, pPix, fg, bg);
+
+    (*infoRec->FillColor8x8PatternSpans) (infoRec->pScrn,
+                                          pGC->alu, pGC->planemask, n, ppt,
+                                          pwidth, fSorted, pCache,
+                                          (yorg + pGC->patOrg.x),
+                                          (xorg + pGC->patOrg.y));
+}
+
+        /****************************\
+	|     Color Expand Spans     |
+	\****************************/
+
+static void
+XAARenderColorExpandSpans(GCPtr pGC,
+                          int n,
+                          DDXPointPtr ppt,
+                          int *pwidth, int fSorted, int xorg, int yorg)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    int fg, bg;
+
+    switch (pGC->fillStyle) {
+    case FillStippled:
+        fg = pGC->fgPixel;
+        bg = -1;
+        break;
+    case FillOpaqueStippled:
+        fg = pGC->fgPixel;
+        bg = pGC->bgPixel;
+        break;
+    default:                   /* Muffle compiler */
+        fg = -1;
+        bg = -1;
+        break;
+    }
+
+    (*infoRec->FillColorExpandSpans) (infoRec->pScrn, fg, bg,
+                                      pGC->alu, pGC->planemask, n, ppt, pwidth,
+                                      fSorted, (xorg + pGC->patOrg.x),
+                                      (yorg + pGC->patOrg.y), pGC->stipple);
+
+}
+
+        /*************************\
+	|     Cache Blt Spans     |
+	\*************************/
+
+static void
+XAARenderCacheBltSpans(GCPtr pGC,
+                       int n,
+                       DDXPointPtr ppt,
+                       int *pwidth, int fSorted, int xorg, int yorg)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    XAACacheInfoPtr pCache;
+
+    switch (pGC->fillStyle) {
+    case FillStippled:
+        pCache = (*infoRec->CacheStipple) (infoRec->pScrn, pGC->stipple,
+                                           pGC->fgPixel, -1);
+        break;
+    case FillOpaqueStippled:
+        pCache = (*infoRec->CacheStipple) (infoRec->pScrn, pGC->stipple,
+                                           pGC->fgPixel, pGC->bgPixel);
+        break;
+    case FillTiled:
+        pCache = (*infoRec->CacheTile) (infoRec->pScrn, pGC->tile.pixmap);
+        break;
+    default:                   /* Muffle compiler */
+        pCache = NULL;
+        break;
+    }
+
+    (*infoRec->FillCacheBltSpans) (infoRec->pScrn,
+                                   pGC->alu, pGC->planemask, n, ppt, pwidth,
+                                   fSorted, pCache, (xorg + pGC->patOrg.x),
+                                   (yorg + pGC->patOrg.y));
+
+}
+
+        /****************************\
+	|     Cache Expand Spans     |
+	\****************************/
+
+static void
+XAARenderCacheExpandSpans(GCPtr pGC,
+                          int n,
+                          DDXPointPtr ppt,
+                          int *pwidth, int fSorted, int xorg, int yorg)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    int fg, bg;
+
+    switch (pGC->fillStyle) {
+    case FillStippled:
+        fg = pGC->fgPixel;
+        bg = -1;
+        break;
+    case FillOpaqueStippled:
+        fg = pGC->fgPixel;
+        bg = pGC->bgPixel;
+        break;
+    default:                   /* Muffle compiler */
+        fg = -1;
+        bg = -1;
+        break;
+    }
+
+    (*infoRec->FillCacheExpandSpans) (infoRec->pScrn, fg, bg,
+                                      pGC->alu, pGC->planemask, n, ppt, pwidth,
+                                      fSorted, (xorg + pGC->patOrg.x),
+                                      (yorg + pGC->patOrg.y), pGC->stipple);
+}
+
+        /***************************\
+	|     Pixmap Copy Spans     |
+	\***************************/
+
+static void
+XAARenderPixmapCopySpans(GCPtr pGC,
+                         int n,
+                         DDXPointPtr ppt,
+                         int *pwidth, int fSorted, int xorg, int yorg)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    XAACacheInfoPtr pCache = &(infoRec->ScratchCacheInfoRec);
+    XAAPixmapPtr pPriv = XAA_GET_PIXMAP_PRIVATE(pGC->tile.pixmap);
+
+    pCache->x = pPriv->offscreenArea->box.x1;
+    pCache->y = pPriv->offscreenArea->box.y1;
+    pCache->w = pCache->orig_w = pPriv->offscreenArea->box.x2 - pCache->x;
+    pCache->h = pCache->orig_h = pPriv->offscreenArea->box.y2 - pCache->y;
+    pCache->trans_color = -1;
+
+    (*infoRec->FillCacheBltSpans) (infoRec->pScrn,
+                                   pGC->alu, pGC->planemask, n, ppt, pwidth,
+                                   fSorted, pCache, (xorg + pGC->patOrg.x),
+                                   (yorg + pGC->patOrg.y));
+}
+
+        /****************\
+	|     Solid      |
+	\****************/
+
+void
+XAAFillSolidSpans(ScrnInfoPtr pScrn,
+                  int fg, int rop,
+                  unsigned int planemask,
+                  int n, DDXPointPtr ppt, int *pwidth, int fSorted)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+
+    (*infoRec->SetupForSolidFill) (pScrn, fg, rop, planemask);
+
+    if (infoRec->ClipBox)
+        (*infoRec->SetClippingRectangle) (infoRec->pScrn,
+                                          infoRec->ClipBox->x1,
+                                          infoRec->ClipBox->y1,
+                                          infoRec->ClipBox->x2 - 1,
+                                          infoRec->ClipBox->y2 - 1);
+
+    while (n--) {
+        if (*pwidth > 0)
+            (*infoRec->SubsequentSolidFillRect) (pScrn, ppt->x, ppt->y,
+                                                 *pwidth, 1);
+        ppt++;
+        pwidth++;
+    }
+
+    if (infoRec->ClipBox)
+        (*infoRec->DisableClipping) (infoRec->pScrn);
+
+    SET_SYNC_FLAG(infoRec);
+}
+
+        /***************\
+	|   Mono 8x8    |
+	\***************/
+
+void
+XAAFillMono8x8PatternSpansScreenOrigin(ScrnInfoPtr pScrn,
+                                       int fg, int bg, int rop,
+                                       unsigned int planemask,
+                                       int n,
+                                       DDXPointPtr ppt,
+                                       int *pwidth, int fSorted,
+                                       int pattern0, int pattern1,
+                                       int xorigin, int yorigin)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int patx = pattern0, paty = pattern1;
+    int xorg = (-xorigin) & 0x07;
+    int yorg = (-yorigin) & 0x07;
+
+    if (infoRec->Mono8x8PatternFillFlags & HARDWARE_PATTERN_PROGRAMMED_BITS) {
+        if (!(infoRec->Mono8x8PatternFillFlags &
+              HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
+            XAARotateMonoPattern(&patx, &paty, xorg, yorg,
+                                 (infoRec->Mono8x8PatternFillFlags &
+                                  BIT_ORDER_IN_BYTE_MSBFIRST));
+            xorg = patx;
+            yorg = paty;
+        }
+    }
+    else {
+        XAACacheInfoPtr pCache =
+            (*infoRec->CacheMono8x8Pattern) (pScrn, pattern0, pattern1);
+        patx = pCache->x;
+        paty = pCache->y;
+        if (!(infoRec->Mono8x8PatternFillFlags &
+              HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
+            int slot = (yorg << 3) + xorg;
+
+            patx += pCache->offsets[slot].x;
+            paty += pCache->offsets[slot].y;
+            xorg = patx;
+            yorg = paty;
+        }
+    }
+
+    (*infoRec->SetupForMono8x8PatternFill) (pScrn, patx, paty,
+                                            fg, bg, rop, planemask);
+
+    if (infoRec->ClipBox)
+        (*infoRec->SetClippingRectangle) (infoRec->pScrn,
+                                          infoRec->ClipBox->x1,
+                                          infoRec->ClipBox->y1,
+                                          infoRec->ClipBox->x2 - 1,
+                                          infoRec->ClipBox->y2 - 1);
+
+    while (n--) {
+        (*infoRec->SubsequentMono8x8PatternFillRect) (pScrn,
+                                                      xorg, yorg, ppt->x,
+                                                      ppt->y, *pwidth, 1);
+        ppt++;
+        pwidth++;
+    }
+
+    if (infoRec->ClipBox)
+        (*infoRec->DisableClipping) (infoRec->pScrn);
+
+    SET_SYNC_FLAG(infoRec);
+}
+
+void
+XAAFillMono8x8PatternSpans(ScrnInfoPtr pScrn,
+                           int fg, int bg, int rop,
+                           unsigned int planemask,
+                           int n,
+                           DDXPointPtr ppt,
+                           int *pwidth, int fSorted,
+                           int pattern0, int pattern1, int xorigin, int yorigin)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int patx = pattern0, paty = pattern1;
+    int xorg, yorg, slot;
+    XAACacheInfoPtr pCache = NULL;
+
+    if (!(infoRec->Mono8x8PatternFillFlags & HARDWARE_PATTERN_PROGRAMMED_BITS)) {
+        pCache = (*infoRec->CacheMono8x8Pattern) (pScrn, pattern0, pattern1);
+        patx = pCache->x;
+        paty = pCache->y;
+    }
+
+    (*infoRec->SetupForMono8x8PatternFill) (pScrn, patx, paty,
+                                            fg, bg, rop, planemask);
+
+    if (infoRec->ClipBox)
+        (*infoRec->SetClippingRectangle) (infoRec->pScrn,
+                                          infoRec->ClipBox->x1,
+                                          infoRec->ClipBox->y1,
+                                          infoRec->ClipBox->x2 - 1,
+                                          infoRec->ClipBox->y2 - 1);
+
+    while (n--) {
+        xorg = (ppt->x - xorigin) & 0x07;
+        yorg = (ppt->y - yorigin) & 0x07;
+
+        if (!(infoRec->Mono8x8PatternFillFlags &
+              HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
+            if (infoRec->Mono8x8PatternFillFlags &
+                HARDWARE_PATTERN_PROGRAMMED_BITS) {
+                patx = pattern0;
+                paty = pattern1;
+                XAARotateMonoPattern(&patx, &paty, xorg, yorg,
+                                     (infoRec->Mono8x8PatternFillFlags &
+                                      BIT_ORDER_IN_BYTE_MSBFIRST));
+                xorg = patx;
+                yorg = paty;
+            }
+            else {
+                slot = (yorg << 3) + xorg;
+                xorg = patx + pCache->offsets[slot].x;
+                yorg = paty + pCache->offsets[slot].y;
+            }
+        }
+
+        (*infoRec->SubsequentMono8x8PatternFillRect) (pScrn,
+                                                      xorg, yorg, ppt->x,
+                                                      ppt->y, *pwidth, 1);
+        ppt++;
+        pwidth++;
+    }
+
+    if (infoRec->ClipBox)
+        (*infoRec->DisableClipping) (infoRec->pScrn);
+
+    SET_SYNC_FLAG(infoRec);
+}
+
+        /****************\
+	|   Color 8x8    |
+	\****************/
+
+void
+XAAFillColor8x8PatternSpansScreenOrigin(ScrnInfoPtr pScrn,
+                                        int rop,
+                                        unsigned int planemask,
+                                        int n,
+                                        DDXPointPtr ppt,
+                                        int *pwidth, int fSorted,
+                                        XAACacheInfoPtr pCache,
+                                        int xorigin, int yorigin)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int patx = pCache->x, paty = pCache->y;
+    int xorg = (-xorigin) & 0x07;
+    int yorg = (-yorigin) & 0x07;
+
+    if (!(infoRec->Color8x8PatternFillFlags &
+          HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
+        int slot = (yorg << 3) + xorg;
+
+        paty += pCache->offsets[slot].y;
+        patx += pCache->offsets[slot].x;
+        xorg = patx;
+        yorg = paty;
+    }
+
+    (*infoRec->SetupForColor8x8PatternFill) (pScrn, patx, paty,
+                                             rop, planemask,
+                                             pCache->trans_color);
+
+    if (infoRec->ClipBox)
+        (*infoRec->SetClippingRectangle) (infoRec->pScrn,
+                                          infoRec->ClipBox->x1,
+                                          infoRec->ClipBox->y1,
+                                          infoRec->ClipBox->x2 - 1,
+                                          infoRec->ClipBox->y2 - 1);
+
+    while (n--) {
+        (*infoRec->SubsequentColor8x8PatternFillRect) (pScrn,
+                                                       xorg, yorg, ppt->x,
+                                                       ppt->y, *pwidth, 1);
+        ppt++;
+        pwidth++;
+    }
+
+    if (infoRec->ClipBox)
+        (*infoRec->DisableClipping) (infoRec->pScrn);
+
+    SET_SYNC_FLAG(infoRec);
+}
+
+void
+XAAFillColor8x8PatternSpans(ScrnInfoPtr pScrn,
+                            int rop,
+                            unsigned int planemask,
+                            int n,
+                            DDXPointPtr ppt,
+                            int *pwidth, int fSorted,
+                            XAACacheInfoPtr pCache, int xorigin, int yorigin)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int xorg, yorg, slot;
+
+    (*infoRec->SetupForColor8x8PatternFill) (pScrn, pCache->x, pCache->y,
+                                             rop, planemask,
+                                             pCache->trans_color);
+
+    if (infoRec->ClipBox)
+        (*infoRec->SetClippingRectangle) (infoRec->pScrn,
+                                          infoRec->ClipBox->x1,
+                                          infoRec->ClipBox->y1,
+                                          infoRec->ClipBox->x2 - 1,
+                                          infoRec->ClipBox->y2 - 1);
+
+    while (n--) {
+        xorg = (ppt->x - xorigin) & 0x07;
+        yorg = (ppt->y - yorigin) & 0x07;
+
+        if (!(infoRec->Color8x8PatternFillFlags &
+              HARDWARE_PATTERN_PROGRAMMED_ORIGIN)) {
+            slot = (yorg << 3) + xorg;
+            yorg = pCache->y + pCache->offsets[slot].y;
+            xorg = pCache->x + pCache->offsets[slot].x;
+        }
+
+        (*infoRec->SubsequentColor8x8PatternFillRect) (pScrn,
+                                                       xorg, yorg, ppt->x,
+                                                       ppt->y, *pwidth, 1);
+        ppt++;
+        pwidth++;
+    }
+
+    if (infoRec->ClipBox)
+        (*infoRec->DisableClipping) (infoRec->pScrn);
+
+    SET_SYNC_FLAG(infoRec);
+}
+
+        /*****************\
+	|   Cache Blit    |
+	\*****************/
+
+void
+XAAFillCacheBltSpans(ScrnInfoPtr pScrn,
+                     int rop,
+                     unsigned int planemask,
+                     int n,
+                     DDXPointPtr ppt,
+                     int *pwidth,
+                     int fSorted, XAACacheInfoPtr pCache, int xorg, int yorg)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int x, w, phaseX, phaseY, blit_w;
+
+    (*infoRec->SetupForScreenToScreenCopy) (pScrn, 1, 1, rop, planemask,
+                                            pCache->trans_color);
+
+    if (infoRec->ClipBox)
+        (*infoRec->SetClippingRectangle) (infoRec->pScrn,
+                                          infoRec->ClipBox->x1,
+                                          infoRec->ClipBox->y1,
+                                          infoRec->ClipBox->x2 - 1,
+                                          infoRec->ClipBox->y2 - 1);
+
+    while (n--) {
+        x = ppt->x;
+        w = *pwidth;
+        phaseX = (x - xorg) % pCache->orig_w;
+        if (phaseX < 0)
+            phaseX += pCache->orig_w;
+        phaseY = (ppt->y - yorg) % pCache->orig_h;
+        if (phaseY < 0)
+            phaseY += pCache->orig_h;
+
+        while (1) {
+            blit_w = pCache->w - phaseX;
+            if (blit_w > w)
+                blit_w = w;
+
+            (*infoRec->SubsequentScreenToScreenCopy) (pScrn,
+                                                      pCache->x + phaseX,
+                                                      pCache->y + phaseY, x,
+                                                      ppt->y, blit_w, 1);
+
+            w -= blit_w;
+            if (!w)
+                break;
+            x += blit_w;
+            phaseX = (phaseX + blit_w) % pCache->orig_w;
+        }
+        ppt++;
+        pwidth++;
+    }
+
+    if (infoRec->ClipBox)
+        (*infoRec->DisableClipping) (infoRec->pScrn);
+
+    SET_SYNC_FLAG(infoRec);
+}
+
+        /****************\
+	|  Cache Expand  |
+	\****************/
+
+void
+XAAFillCacheExpandSpans(ScrnInfoPtr pScrn,
+                        int fg, int bg, int rop,
+                        unsigned int planemask,
+                        int n,
+                        DDXPointPtr ppt,
+                        int *pwidth,
+                        int fSorted, int xorg, int yorg, PixmapPtr pPix)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int x, w, phaseX, phaseY, blit_w, cacheWidth;
+    XAACacheInfoPtr pCache;
+
+    pCache = (*infoRec->CacheMonoStipple) (pScrn, pPix);
+
+    cacheWidth = (pCache->w * pScrn->bitsPerPixel) /
+        infoRec->CacheColorExpandDensity;
+
+    (*infoRec->SetupForScreenToScreenColorExpandFill) (pScrn, fg, bg, rop,
+                                                       planemask);
+
+    if (infoRec->ClipBox)
+        (*infoRec->SetClippingRectangle) (infoRec->pScrn,
+                                          infoRec->ClipBox->x1,
+                                          infoRec->ClipBox->y1,
+                                          infoRec->ClipBox->x2 - 1,
+                                          infoRec->ClipBox->y2 - 1);
+
+    while (n--) {
+        x = ppt->x;
+        w = *pwidth;
+        phaseX = (x - xorg) % pCache->orig_w;
+        if (phaseX < 0)
+            phaseX += pCache->orig_w;
+        phaseY = (ppt->y - yorg) % pCache->orig_h;
+        if (phaseY < 0)
+            phaseY += pCache->orig_h;
+
+        while (1) {
+            blit_w = cacheWidth - phaseX;
+            if (blit_w > w)
+                blit_w = w;
+
+            (*infoRec->SubsequentScreenToScreenColorExpandFill) (pScrn, x,
+                                                                 ppt->y, blit_w,
+                                                                 1, pCache->x,
+                                                                 pCache->y +
+                                                                 phaseY,
+                                                                 phaseX);
+
+            w -= blit_w;
+            if (!w)
+                break;
+            x += blit_w;
+            phaseX = (phaseX + blit_w) % pCache->orig_w;
+        }
+        ppt++;
+        pwidth++;
+    }
+
+    if (infoRec->ClipBox)
+        (*infoRec->DisableClipping) (infoRec->pScrn);
+
+    SET_SYNC_FLAG(infoRec);
+}
+
+void
+XAAClipAndRenderSpans(GCPtr pGC,
+                      DDXPointPtr ppt,
+                      int *pwidth,
+                      int nspans,
+                      int fSorted,
+                      ClipAndRenderSpansFunc func, int xorg, int yorg)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    DDXPointPtr pptNew, pptBase;
+    int *pwidthBase, *pwidthNew;
+    int Right, numRects, MaxBoxes;
+
+    MaxBoxes = infoRec->PreAllocSize / (sizeof(DDXPointRec) + sizeof(int));
+    pptBase = (DDXPointRec *) infoRec->PreAllocMem;
+    pwidthBase = (int *) (&pptBase[MaxBoxes]);
+
+    pptNew = pptBase;
+    pwidthNew = pwidthBase;
+
+    numRects = RegionNumRects(pGC->pCompositeClip);
+
+    if (numRects == 1) {
+        BoxPtr pextent = RegionRects(pGC->pCompositeClip);
+
+        while (nspans--) {
+            if ((pextent->y1 <= ppt->y) && (ppt->y < pextent->y2)) {
+                pptNew->x = max(pextent->x1, ppt->x);
+                Right = ppt->x + *pwidth;
+                *pwidthNew = min(pextent->x2, Right) - pptNew->x;
+
+                if (*pwidthNew > 0) {
+                    pptNew->y = ppt->y;
+                    pptNew++;
+                    pwidthNew++;
+
+                    if (pptNew >= (pptBase + MaxBoxes)) {
+                        (*func) (pGC, MaxBoxes, pptBase, pwidthBase, fSorted,
+                                 xorg, yorg);
+                        pptNew = pptBase;
+                        pwidthNew = pwidthBase;
+                    }
+                }
+            }
+            ppt++;
+            pwidth++;
+        }
+    }
+    else if (numRects) {
+        BoxPtr pbox;
+        int nbox;
+
+        while (nspans--) {
+            nbox = numRects;
+            pbox = RegionRects(pGC->pCompositeClip);
+
+            /* find the first band */
+            while (nbox && (pbox->y2 <= ppt->y)) {
+                pbox++;
+                nbox--;
+            }
+
+            if (nbox && (pbox->y1 <= ppt->y)) {
+                int orig_y = pbox->y1;
+
+                Right = ppt->x + *pwidth;
+                while (nbox && (orig_y == pbox->y1)) {
+                    if (pbox->x2 <= ppt->x) {
+                        nbox--;
+                        pbox++;
+                        continue;
+                    }
+
+                    if (pbox->x1 >= Right) {
+                        nbox = 0;
+                        break;
+                    }
+
+                    pptNew->x = max(pbox->x1, ppt->x);
+                    *pwidthNew = min(pbox->x2, Right) - pptNew->x;
+                    if (*pwidthNew > 0) {
+                        pptNew->y = ppt->y;
+                        pptNew++;
+                        pwidthNew++;
+
+                        if (pptNew >= (pptBase + MaxBoxes)) {
+                            (*func) (pGC, MaxBoxes, pptBase, pwidthBase,
+                                     fSorted, xorg, yorg);
+                            pptNew = pptBase;
+                            pwidthNew = pwidthBase;
+                        }
+                    }
+                    pbox++;
+                    nbox--;
+                }
+            }
+            ppt++;
+            pwidth++;
+        }
+    }
+
+    if (pptNew != pptBase)
+        (*func) (pGC, pptNew - pptBase, pptBase, pwidthBase, fSorted,
+                 xorg, yorg);
+}
diff --git a/hw/xfree86/xaa/xaaStateChange.c b/hw/xfree86/xaa/xaaStateChange.c
new file mode 100644
index 000000000..c1411da8d
--- /dev/null
+++ b/hw/xfree86/xaa/xaaStateChange.c
@@ -0,0 +1,1665 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include "pixmapstr.h"
+#include "windowstr.h"
+#include "xf86str.h"
+#include "mi.h"
+#include "miline.h"
+#include "xaa.h"
+#include "xaalocal.h"
+#include "xaawrap.h"
+#include "servermd.h"
+
+#define XAA_STATE_WRAP(func) do {\
+if(infoRec->func) { \
+   pStatePriv->func = infoRec->func;\
+   infoRec->func = XAAStateWrap##func;\
+}} while(0)
+
+/* Wrap all XAA functions and allocate our private structure.
+ */
+
+typedef struct _XAAStateWrapRec {
+    ScrnInfoPtr pScrn;
+    void (*RestoreAccelState) (ScrnInfoPtr pScrn);
+    void (*Sync) (ScrnInfoPtr pScrn);
+    void (*SetupForScreenToScreenCopy) (ScrnInfoPtr pScrn, int xdir, int ydir,
+                                        int rop, unsigned int planemask,
+                                        int trans_color);
+    void (*SetupForSolidFill) (ScrnInfoPtr pScrn, int color, int rop,
+                               unsigned int planemask);
+    void (*SetupForSolidLine) (ScrnInfoPtr pScrn, int color, int rop,
+                               unsigned int planemask);
+    void (*SetupForDashedLine) (ScrnInfoPtr pScrn, int fg, int bg, int rop,
+                                unsigned int planemask, int length,
+                                unsigned char *pattern);
+    void (*SetClippingRectangle) (ScrnInfoPtr pScrn, int left, int top,
+                                  int right, int bottom);
+    void (*DisableClipping) (ScrnInfoPtr pScrn);
+    void (*SetupForMono8x8PatternFill) (ScrnInfoPtr pScrn, int patx, int paty,
+                                        int fg, int bg, int rop,
+                                        unsigned int planemask);
+    void (*SetupForColor8x8PatternFill) (ScrnInfoPtr pScrn, int patx, int paty,
+                                         int rop, unsigned int planemask,
+                                         int transparency_color);
+    void (*SetupForCPUToScreenColorExpandFill) (ScrnInfoPtr pScrn, int fg,
+                                                int bg, int rop,
+                                                unsigned int planemask);
+    void (*SetupForScanlineCPUToScreenColorExpandFill) (ScrnInfoPtr pScrn,
+                                                        int fg, int bg, int rop,
+                                                        unsigned int planemask);
+    void (*SetupForScreenToScreenColorExpandFill) (ScrnInfoPtr pScrn,
+                                                   int fg, int bg, int rop,
+                                                   unsigned int planemask);
+    void (*SetupForImageWrite) (ScrnInfoPtr pScrn, int rop,
+                                unsigned int planemask, int transparency_color,
+                                int bpp, int depth);
+    void (*SetupForScanlineImageWrite) (ScrnInfoPtr pScrn, int rop,
+                                        unsigned int planemask,
+                                        int transparency_color,
+                                        int bpp, int depth);
+    void (*SetupForImageRead) (ScrnInfoPtr pScrn, int bpp, int depth);
+    void (*ScreenToScreenBitBlt) (ScrnInfoPtr pScrn, int nbox,
+                                  DDXPointPtr pptSrc, BoxPtr pbox, int xdir,
+                                  int ydir, int alu, unsigned int planmask);
+    void (*WriteBitmap) (ScrnInfoPtr pScrn, int x, int y, int w, int h,
+                         unsigned char *src, int srcwidth, int skipleft,
+                         int fg, int bg, int rop, unsigned int planemask);
+    void (*FillSolidRects) (ScrnInfoPtr pScrn, int fg, int rop,
+                            unsigned int planemask, int nBox, BoxPtr pBox);
+    void (*FillMono8x8PatternRects) (ScrnInfoPtr pScrn, int fg, int bg, int rop,
+                                     unsigned int planemask, int nBox,
+                                     BoxPtr pBox, int pat0, int pat1,
+                                     int xorg, int yorg);
+    void (*FillColor8x8PatternRects) (ScrnInfoPtr pScrn, int rop,
+                                      unsigned int planemask, int nBox,
+                                      BoxPtr pBox, int xorg, int yorg,
+                                      XAACacheInfoPtr pCache);
+    void (*FillCacheBltRects) (ScrnInfoPtr pScrn, int rop,
+                               unsigned int planemask, int nBox, BoxPtr pBox,
+                               int xorg, int yorg, XAACacheInfoPtr pCache);
+    void (*FillColorExpandRects) (ScrnInfoPtr pScrn, int fg, int bg, int rop,
+                                  unsigned int planemask, int nBox,
+                                  BoxPtr pBox, int xorg, int yorg,
+                                  PixmapPtr pPix);
+    void (*FillCacheExpandRects) (ScrnInfoPtr pScrn, int fg, int bg, int rop,
+                                  unsigned int planemask, int nBox, BoxPtr pBox,
+                                  int xorg, int yorg, PixmapPtr pPix);
+    void (*FillImageWriteRects) (ScrnInfoPtr pScrn, int rop,
+                                 unsigned int planemask, int nBox, BoxPtr pBox,
+                                 int xorg, int yorg, PixmapPtr pPix);
+    void (*FillSolidSpans) (ScrnInfoPtr pScrn, int fg, int rop,
+                            unsigned int planemask, int n, DDXPointPtr points,
+                            int *widths, int fSorted);
+    void (*FillMono8x8PatternSpans) (ScrnInfoPtr pScrn, int fg, int bg, int rop,
+                                     unsigned int planemask, int n,
+                                     DDXPointPtr points, int *widths,
+                                     int fSorted, int pat0, int pat1,
+                                     int xorg, int yorg);
+    void (*FillColor8x8PatternSpans) (ScrnInfoPtr pScrn, int rop,
+                                      unsigned int planemask, int n,
+                                      DDXPointPtr points, int *widths,
+                                      int fSorted, XAACacheInfoPtr pCache,
+                                      int xorg, int yorg);
+    void (*FillCacheBltSpans) (ScrnInfoPtr pScrn, int rop,
+                               unsigned int planemask, int n,
+                               DDXPointPtr points, int *widths, int fSorted,
+                               XAACacheInfoPtr pCache, int xorg, int yorg);
+    void (*FillColorExpandSpans) (ScrnInfoPtr pScrn, int fg, int bg, int rop,
+                                  unsigned int planemask, int n,
+                                  DDXPointPtr points, int *widths, int fSorted,
+                                  int xorg, int yorg, PixmapPtr pPix);
+    void (*FillCacheExpandSpans) (ScrnInfoPtr pScrn, int fg, int bg, int rop,
+                                  unsigned int planemask, int n,
+                                  DDXPointPtr ppt, int *pwidth, int fSorted,
+                                  int xorg, int yorg, PixmapPtr pPix);
+    void (*TEGlyphRenderer) (ScrnInfoPtr pScrn, int x, int y, int w, int h,
+                             int skipleft, int startline, unsigned int **glyphs,
+                             int glyphWidth, int fg, int bg, int rop,
+                             unsigned planemask);
+    void (*NonTEGlyphRenderer) (ScrnInfoPtr pScrn, int x, int y, int n,
+                                NonTEGlyphPtr glyphs, BoxPtr pbox, int fg,
+                                int rop, unsigned int planemask);
+    void (*WritePixmap) (ScrnInfoPtr pScrn, int x, int y, int w, int h,
+                         unsigned char *src, int srcwidth, int rop,
+                         unsigned int planemask, int transparency_color,
+                         int bpp, int depth);
+    void (*ReadPixmap) (ScrnInfoPtr pScrn, int x, int y, int w, int h,
+                        unsigned char *dst, int dstwidth, int bpp, int depth);
+    RegionPtr (*CopyArea) (DrawablePtr pSrcDrawable, DrawablePtr pDstDrawable,
+                           GC * pGC, int srcx, int srcy, int width, int height,
+                           int dstx, int dsty);
+    RegionPtr (*CopyPlane) (DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
+                            int srcx, int srcy, int width, int height, int dstx,
+                            int dsty, unsigned long bitPlane);
+    void (*PushPixelsSolid) (GCPtr pGC, PixmapPtr pBitMap,
+                             DrawablePtr pDrawable, int dx, int dy, int xOrg,
+                             int yOrg);
+    void (*PolyFillRectSolid) (DrawablePtr pDraw, GCPtr pGC, int nrectFill,
+                               xRectangle *prectInit);
+    void (*PolyFillRectStippled) (DrawablePtr pDraw, GCPtr pGC, int nrectFill,
+                                  xRectangle *prectInit);
+    void (*PolyFillRectOpaqueStippled) (DrawablePtr pDraw, GCPtr pGC,
+                                        int nrectFill, xRectangle *prectInit);
+    void (*PolyFillRectTiled) (DrawablePtr pDraw, GCPtr pGC, int nrectFill,
+                               xRectangle *prectInit);
+    void (*FillSpansSolid) (DrawablePtr pDraw, GCPtr pGC, int nInit,
+                            DDXPointPtr ppt, int *pwidth, int fSorted);
+    void (*FillSpansStippled) (DrawablePtr pDraw, GCPtr pGC, int nInit,
+                               DDXPointPtr ppt, int *pwidth, int fSorted);
+    void (*FillSpansOpaqueStippled) (DrawablePtr pDraw, GCPtr pGC, int nInit,
+                                     DDXPointPtr ppt, int *pwidth, int fSorted);
+    void (*FillSpansTiled) (DrawablePtr pDraw, GCPtr pGC, int nInit,
+                            DDXPointPtr ppt, int *pwidth, int fSorted);
+    int (*PolyText8TE) (DrawablePtr pDraw, GCPtr pGC, int x, int y, int count,
+                        char *chars);
+    int (*PolyText16TE) (DrawablePtr pDraw, GCPtr pGC, int x, int y, int count,
+                         unsigned short *chars);
+    void (*ImageText8TE) (DrawablePtr pDraw, GCPtr pGC, int x, int y, int count,
+                          char *chars);
+    void (*ImageText16TE) (DrawablePtr pDraw, GCPtr pGC, int x, int y,
+                           int count, unsigned short *chars);
+    void (*ImageGlyphBltTE) (DrawablePtr pDrawable, GCPtr pGC, int xInit,
+                             int yInit, unsigned int nglyph, CharInfoPtr * ppci,
+                             void *pglyphBase);
+    void (*PolyGlyphBltTE) (DrawablePtr pDrawable, GCPtr pGC, int xInit,
+                            int yInit, unsigned int nglyph, CharInfoPtr * ppci,
+                            void *pglyphBase);
+    int (*PolyText8NonTE) (DrawablePtr pDraw, GCPtr pGC, int x, int y,
+                           int count, char *chars);
+    int (*PolyText16NonTE) (DrawablePtr pDraw, GCPtr pGC, int x, int y,
+                            int count, unsigned short *chars);
+    void (*ImageText8NonTE) (DrawablePtr pDraw, GCPtr pGC, int x, int y,
+                             int count, char *chars);
+    void (*ImageText16NonTE) (DrawablePtr pDraw, GCPtr pGC, int x, int y,
+                              int count, unsigned short *chars);
+    void (*ImageGlyphBltNonTE) (DrawablePtr pDrawable, GCPtr pGC, int xInit,
+                                int yInit, unsigned int nglyph,
+                                CharInfoPtr * ppci, void *pglyphBase);
+    void (*PolyGlyphBltNonTE) (DrawablePtr pDrawable, GCPtr pGC, int xInit,
+                               int yInit, unsigned int nglyph,
+                               CharInfoPtr * ppci, void *pglyphBase);
+    void (*PolyRectangleThinSolid) (DrawablePtr pDrawable, GCPtr pGC,
+                                    int nRectsInit, xRectangle *pRectsInit);
+    void (*PolylinesWideSolid) (DrawablePtr pDrawable, GCPtr pGC, int mode,
+                                int npt, DDXPointPtr pPts);
+    void (*PolylinesThinSolid) (DrawablePtr pDrawable, GCPtr pGC, int mode,
+                                int npt, DDXPointPtr pPts);
+    void (*PolySegmentThinSolid) (DrawablePtr pDrawable, GCPtr pGC, int nseg,
+                                  xSegment * pSeg);
+    void (*PolylinesThinDashed) (DrawablePtr pDrawable, GCPtr pGC, int mode,
+                                 int npt, DDXPointPtr pPts);
+    void (*PolySegmentThinDashed) (DrawablePtr pDrawable, GCPtr pGC, int nseg,
+                                   xSegment * pSeg);
+    void (*FillPolygonSolid) (DrawablePtr pDrawable, GCPtr pGC, int shape,
+                              int mode, int count, DDXPointPtr ptsIn);
+    void (*FillPolygonStippled) (DrawablePtr pDrawable, GCPtr pGC, int shape,
+                                 int mode, int count, DDXPointPtr ptsIn);
+    void (*FillPolygonOpaqueStippled) (DrawablePtr pDrawable, GCPtr pGC,
+                                       int shape, int mode, int count,
+                                       DDXPointPtr ptsIn);
+    void (*FillPolygonTiled) (DrawablePtr pDrawable, GCPtr pGC, int shape,
+                              int mode, int count, DDXPointPtr ptsIn);
+    void (*PolyFillArcSolid) (DrawablePtr pDraw, GCPtr pGC, int narcs,
+                              xArc * parcs);
+    void (*PutImage) (DrawablePtr pDraw, GCPtr pGC, int depth, int x, int y,
+                      int w, int h, int leftPad, int format, char *pImage);
+    ValidateGCProcPtr ValidateFillSpans;
+    ValidateGCProcPtr ValidateSetSpans;
+    ValidateGCProcPtr ValidatePutImage;
+    ValidateGCProcPtr ValidateCopyArea;
+    ValidateGCProcPtr ValidateCopyPlane;
+    ValidateGCProcPtr ValidatePolyPoint;
+    ValidateGCProcPtr ValidatePolylines;
+    ValidateGCProcPtr ValidatePolySegment;
+    ValidateGCProcPtr ValidatePolyRectangle;
+    ValidateGCProcPtr ValidatePolyArc;
+    ValidateGCProcPtr ValidateFillPolygon;
+    ValidateGCProcPtr ValidatePolyFillRect;
+    ValidateGCProcPtr ValidatePolyFillArc;
+    ValidateGCProcPtr ValidatePolyText8;
+    ValidateGCProcPtr ValidatePolyText16;
+    ValidateGCProcPtr ValidateImageText8;
+    ValidateGCProcPtr ValidateImageText16;
+    ValidateGCProcPtr ValidatePolyGlyphBlt;
+    ValidateGCProcPtr ValidateImageGlyphBlt;
+    ValidateGCProcPtr ValidatePushPixels;
+    void (*ComputeDash) (GCPtr pGC);
+    void (*InitPixmapCache) (ScreenPtr pScreen, RegionPtr areas, void *data);
+    void (*ClosePixmapCache) (ScreenPtr pScreen);
+    int (*StippledFillChooser) (GCPtr pGC);
+    int (*OpaqueStippledFillChooser) (GCPtr pGC);
+    int (*TiledFillChooser) (GCPtr pGC);
+     XAACacheInfoPtr(*CacheTile) (ScrnInfoPtr Scrn, PixmapPtr pPix);
+     XAACacheInfoPtr(*CacheStipple) (ScrnInfoPtr Scrn, PixmapPtr pPix, int fg,
+                                     int bg);
+     XAACacheInfoPtr(*CacheMonoStipple) (ScrnInfoPtr Scrn, PixmapPtr pPix);
+     XAACacheInfoPtr(*CacheMono8x8Pattern) (ScrnInfoPtr Scrn, int pat0,
+                                            int pat1);
+     XAACacheInfoPtr(*CacheColor8x8Pattern) (ScrnInfoPtr Scrn, PixmapPtr pPix,
+                                             int fg, int bg);
+    void (*WriteBitmapToCache) (ScrnInfoPtr pScrn, int x, int y, int w, int h,
+                                unsigned char *src, int srcwidth, int fg,
+                                int bg);
+    void (*WritePixmapToCache) (ScrnInfoPtr pScrn, int x, int y, int w, int h,
+                                unsigned char *src, int srcwidth, int bpp,
+                                int depth);
+    void (*WriteMono8x8PatternToCache) (ScrnInfoPtr pScrn,
+                                        XAACacheInfoPtr pCache);
+    void (*WriteColor8x8PatternToCache) (ScrnInfoPtr pScrn, PixmapPtr pPix,
+                                         XAACacheInfoPtr pCache);
+    GetImageProcPtr GetImage;
+    GetSpansProcPtr GetSpans;
+    CopyWindowProcPtr CopyWindow;
+    Bool (*SetupForCPUToScreenAlphaTexture2) (ScrnInfoPtr pScrn, int op,
+                                              CARD16 red, CARD16 green,
+                                              CARD16 blue, CARD16 alpha,
+                                              CARD32 maskFormat,
+                                              CARD32 dstFormat, CARD8 *alphaPtr,
+                                              int alphaPitch, int width,
+                                              int height, int flags);
+    Bool (*SetupForCPUToScreenTexture2) (ScrnInfoPtr pScrn, int op,
+                                         CARD32 srcFormat, CARD32 dstFormat,
+                                         CARD8 *texPtr, int texPitch, int width,
+                                         int height, int flags);
+} XAAStateWrapRec, *XAAStateWrapPtr;
+
+static DevPrivateKeyRec XAAStateKeyRec;
+
+#define XAAStateKey (&XAAStateKeyRec)
+
+/* Wrap functions start here */
+#define GET_STATEPRIV_GC(pGC)   XAAStateWrapPtr pStatePriv =\
+(XAAStateWrapPtr)dixLookupPrivate(&(pGC)->pScreen->devPrivates, XAAStateKey)
+
+#define GET_STATEPRIV_SCREEN(pScreen)   XAAStateWrapPtr pStatePriv =\
+(XAAStateWrapPtr)dixLookupPrivate(&(pScreen)->devPrivates, XAAStateKey)
+
+#define GET_STATEPRIV_PSCRN(pScrn)   XAAStateWrapPtr pStatePriv =\
+(XAAStateWrapPtr)dixLookupPrivate(&(pScrn)->pScreen->devPrivates, XAAStateKey)
+
+#define STATE_CHECK_SP(pStatePriv) {\
+	ScrnInfoPtr pScrn = pStatePriv->pScrn;\
+	int i = 0;\
+	int need_change = 0;\
+	while(i < pScrn->numEntities) {\
+		if(xf86IsEntityShared(pScrn->entityList[i]) &&\
+		   xf86GetLastScrnFlag(pScrn->entityList[i]) != pScrn->scrnIndex) {\
+			need_change = 1;\
+			xf86SetLastScrnFlag(pScrn->entityList[i],\
+					    pScrn->scrnIndex);\
+		}\
+		i++;\
+	}\
+	if(need_change == 1) (*pStatePriv->RestoreAccelState)(pScrn);\
+}
+
+#define STATE_CHECK_PSCRN(pScrn) {\
+	int i = 0;\
+	int need_change = 0;\
+	while(i < pScrn->numEntities) {\
+		if(xf86IsEntityShared(pScrn->entityList[i]) &&\
+		   xf86GetLastScrnFlag(pScrn->entityList[i]) != pScrn->scrnIndex) {\
+			need_change = 1;\
+			xf86SetLastScrnFlag(pScrn->entityList[i],\
+					    pScrn->scrnIndex);\
+		}\
+		i++;\
+	}\
+	if(need_change == 1) (*pStatePriv->RestoreAccelState)(pScrn);\
+}
+
+static void
+XAAStateWrapSync(ScrnInfoPtr pScrn)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->Sync) (pScrn);
+}
+
+static void
+XAAStateWrapSetupForScreenToScreenCopy(ScrnInfoPtr pScrn, int xdir, int ydir,
+                                       int rop, unsigned int planemask,
+                                       int trans_color)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->SetupForScreenToScreenCopy) (pScrn, xdir, ydir, rop,
+                                               planemask, trans_color);
+}
+
+static void
+XAAStateWrapSetupForSolidFill(ScrnInfoPtr pScrn, int color, int rop,
+                              unsigned int planemask)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->SetupForSolidFill) (pScrn, color, rop, planemask);
+}
+
+static void
+XAAStateWrapSetupForSolidLine(ScrnInfoPtr pScrn, int color, int rop,
+                              unsigned int planemask)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->SetupForSolidLine) (pScrn, color, rop, planemask);
+}
+
+static void
+XAAStateWrapSetupForDashedLine(ScrnInfoPtr pScrn, int fg, int bg, int rop,
+                               unsigned int planemask, int length,
+                               unsigned char *pattern)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->SetupForDashedLine) (pScrn, fg, bg, rop, planemask, length,
+                                       pattern);
+}
+
+static void
+XAAStateWrapSetClippingRectangle(ScrnInfoPtr pScrn, int left, int top,
+                                 int right, int bottom)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->SetClippingRectangle) (pScrn, left, top, right, bottom);
+}
+
+static void
+XAAStateWrapDisableClipping(ScrnInfoPtr pScrn)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->DisableClipping) (pScrn);
+}
+
+static void
+XAAStateWrapSetupForMono8x8PatternFill(ScrnInfoPtr pScrn, int patx, int paty,
+                                       int fg, int bg, int rop,
+                                       unsigned int planemask)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->SetupForMono8x8PatternFill) (pScrn, patx, paty, fg, bg, rop,
+                                               planemask);
+}
+
+static void
+XAAStateWrapSetupForColor8x8PatternFill(ScrnInfoPtr pScrn, int patx, int paty,
+                                        int rop, unsigned int planemask,
+                                        int transparency_color)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->SetupForColor8x8PatternFill) (pScrn, patx, paty, rop,
+                                                planemask, transparency_color);
+}
+
+static void
+XAAStateWrapSetupForCPUToScreenColorExpandFill(ScrnInfoPtr pScrn, int fg,
+                                               int bg, int rop,
+                                               unsigned int planemask)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->SetupForCPUToScreenColorExpandFill) (pScrn, fg, bg, rop,
+                                                       planemask);
+}
+
+static void
+XAAStateWrapSetupForScanlineCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
+                                                       int fg, int bg,
+                                                       int rop,
+                                                       unsigned int planemask)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->SetupForScanlineCPUToScreenColorExpandFill) (pScrn, fg, bg,
+                                                               rop, planemask);
+}
+
+static void
+XAAStateWrapSetupForScreenToScreenColorExpandFill(ScrnInfoPtr pScrn,
+                                                  int fg, int bg, int rop,
+                                                  unsigned int planemask)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->SetupForScreenToScreenColorExpandFill) (pScrn, fg, bg, rop,
+                                                          planemask);
+}
+
+static void
+XAAStateWrapSetupForImageWrite(ScrnInfoPtr pScrn, int rop,
+                               unsigned int planemask, int transparency_color,
+                               int bpp, int depth)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->SetupForImageWrite) (pScrn, rop, planemask,
+                                       transparency_color, bpp, depth);
+}
+
+static void
+XAAStateWrapSetupForScanlineImageWrite(ScrnInfoPtr pScrn, int rop,
+                                       unsigned int planemask,
+                                       int transparency_color,
+                                       int bpp, int depth)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->SetupForScanlineImageWrite) (pScrn, rop, planemask,
+                                               transparency_color, bpp, depth);
+}
+
+static void
+XAAStateWrapSetupForImageRead(ScrnInfoPtr pScrn, int bpp, int depth)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->SetupForImageRead) (pScrn, bpp, depth);
+}
+
+static void
+XAAStateWrapScreenToScreenBitBlt(ScrnInfoPtr pScrn, int nbox,
+                                 DDXPointPtr pptSrc, BoxPtr pbox, int xdir,
+                                 int ydir, int alu, unsigned int planmask)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->ScreenToScreenBitBlt) (pScrn, nbox,
+                                         pptSrc, pbox, xdir,
+                                         ydir, alu, planmask);
+}
+
+static void
+XAAStateWrapWriteBitmap(ScrnInfoPtr pScrn, int x, int y, int w, int h,
+                        unsigned char *src, int srcwidth, int skipleft,
+                        int fg, int bg, int rop, unsigned int planemask)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->WriteBitmap) (pScrn, x, y, w, h,
+                                src, srcwidth, skipleft,
+                                fg, bg, rop, planemask);
+}
+
+static void
+XAAStateWrapFillSolidRects(ScrnInfoPtr pScrn, int fg, int rop,
+                           unsigned int planemask, int nBox, BoxPtr pBox)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->FillSolidRects) (pScrn, fg, rop, planemask, nBox, pBox);
+}
+
+static void
+XAAStateWrapFillMono8x8PatternRects(ScrnInfoPtr pScrn, int fg, int bg,
+                                    int rop, unsigned int planemask, int nBox,
+                                    BoxPtr pBox, int pat0, int pat1,
+                                    int xorg, int yorg)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->FillMono8x8PatternRects) (pScrn, fg, bg,
+                                            rop, planemask, nBox,
+                                            pBox, pat0, pat1, xorg, yorg);
+}
+
+static void
+XAAStateWrapFillColor8x8PatternRects(ScrnInfoPtr pScrn, int rop,
+                                     unsigned int planemask, int nBox,
+                                     BoxPtr pBox, int xorg, int yorg,
+                                     XAACacheInfoPtr pCache)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->FillColor8x8PatternRects) (pScrn, rop,
+                                             planemask, nBox,
+                                             pBox, xorg, yorg, pCache);
+}
+
+static void
+XAAStateWrapFillCacheBltRects(ScrnInfoPtr pScrn, int rop,
+                              unsigned int planemask, int nBox, BoxPtr pBox,
+                              int xorg, int yorg, XAACacheInfoPtr pCache)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->FillCacheBltRects) (pScrn, rop,
+                                      planemask, nBox, pBox,
+                                      xorg, yorg, pCache);
+}
+
+static void
+XAAStateWrapFillColorExpandRects(ScrnInfoPtr pScrn, int fg, int bg, int rop,
+                                 unsigned int planemask, int nBox,
+                                 BoxPtr pBox, int xorg, int yorg,
+                                 PixmapPtr pPix)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->FillColorExpandRects) (pScrn, fg, bg, rop,
+                                         planemask, nBox,
+                                         pBox, xorg, yorg, pPix);
+}
+
+static void
+XAAStateWrapFillCacheExpandRects(ScrnInfoPtr pScrn, int fg, int bg, int rop,
+                                 unsigned int planemask, int nBox,
+                                 BoxPtr pBox, int xorg, int yorg,
+                                 PixmapPtr pPix)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->FillCacheExpandRects) (pScrn, fg, bg, rop,
+                                         planemask, nBox,
+                                         pBox, xorg, yorg, pPix);
+}
+
+static void
+XAAStateWrapFillImageWriteRects(ScrnInfoPtr pScrn, int rop,
+                                unsigned int planemask, int nBox, BoxPtr pBox,
+                                int xorg, int yorg, PixmapPtr pPix)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->FillImageWriteRects) (pScrn, rop,
+                                        planemask, nBox, pBox,
+                                        xorg, yorg, pPix);
+}
+
+static void
+XAAStateWrapFillSolidSpans(ScrnInfoPtr pScrn, int fg, int rop,
+                           unsigned int planemask, int n, DDXPointPtr points,
+                           int *widths, int fSorted)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->FillSolidSpans) (pScrn, fg, rop,
+                                   planemask, n, points, widths, fSorted);
+}
+
+static void
+XAAStateWrapFillMono8x8PatternSpans(ScrnInfoPtr pScrn, int fg, int bg,
+                                    int rop, unsigned int planemask, int n,
+                                    DDXPointPtr points, int *widths,
+                                    int fSorted, int pat0, int pat1,
+                                    int xorg, int yorg)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->FillMono8x8PatternSpans) (pScrn, fg, bg,
+                                            rop, planemask, n,
+                                            points, widths,
+                                            fSorted, pat0, pat1, xorg, yorg);
+}
+
+static void
+XAAStateWrapFillColor8x8PatternSpans(ScrnInfoPtr pScrn, int rop,
+                                     unsigned int planemask, int n,
+                                     DDXPointPtr points, int *widths,
+                                     int fSorted, XAACacheInfoPtr pCache,
+                                     int xorg, int yorg)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->FillColor8x8PatternSpans) (pScrn, rop,
+                                             planemask, n,
+                                             points, widths,
+                                             fSorted, pCache, xorg, yorg);
+}
+
+static void
+XAAStateWrapFillCacheBltSpans(ScrnInfoPtr pScrn, int rop,
+                              unsigned int planemask, int n,
+                              DDXPointPtr points, int *widths,
+                              int fSorted, XAACacheInfoPtr pCache,
+                              int xorg, int yorg)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->FillCacheBltSpans) (pScrn, rop,
+                                      planemask, n,
+                                      points, widths,
+                                      fSorted, pCache, xorg, yorg);
+}
+
+static void
+XAAStateWrapFillColorExpandSpans(ScrnInfoPtr pScrn, int fg, int bg, int rop,
+                                 unsigned int planemask, int n,
+                                 DDXPointPtr points, int *widths, int fSorted,
+                                 int xorg, int yorg, PixmapPtr pPix)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->FillColorExpandSpans) (pScrn, fg, bg, rop,
+                                         planemask, n,
+                                         points, widths, fSorted,
+                                         xorg, yorg, pPix);
+}
+
+static void
+XAAStateWrapFillCacheExpandSpans(ScrnInfoPtr pScrn, int fg, int bg, int rop,
+                                 unsigned int planemask, int n,
+                                 DDXPointPtr ppt, int *pwidth, int fSorted,
+                                 int xorg, int yorg, PixmapPtr pPix)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->FillCacheExpandSpans) (pScrn, fg, bg, rop,
+                                         planemask, n,
+                                         ppt, pwidth, fSorted,
+                                         xorg, yorg, pPix);
+}
+
+static void
+XAAStateWrapTEGlyphRenderer(ScrnInfoPtr pScrn, int x, int y, int w, int h,
+                            int skipleft, int startline,
+                            unsigned int **glyphs,
+                            int glyphWidth, int fg, int bg, int rop,
+                            unsigned planemask)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->TEGlyphRenderer) (pScrn, x, y, w, h,
+                                    skipleft, startline,
+                                    glyphs, glyphWidth, fg, bg, rop, planemask);
+}
+
+static void
+XAAStateWrapNonTEGlyphRenderer(ScrnInfoPtr pScrn, int x, int y, int n,
+                               NonTEGlyphPtr glyphs, BoxPtr pbox,
+                               int fg, int rop, unsigned int planemask)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->NonTEGlyphRenderer) (pScrn, x, y, n,
+                                       glyphs, pbox, fg, rop, planemask);
+}
+
+static void
+XAAStateWrapWritePixmap(ScrnInfoPtr pScrn, int x, int y, int w, int h,
+                        unsigned char *src, int srcwidth, int rop,
+                        unsigned int planemask, int transparency_color,
+                        int bpp, int depth)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->WritePixmap) (pScrn, x, y, w, h,
+                                src, srcwidth, rop,
+                                planemask, transparency_color, bpp, depth);
+}
+
+static void
+XAAStateWrapReadPixmap(ScrnInfoPtr pScrn, int x, int y, int w, int h,
+                       unsigned char *dst, int dstwidth, int bpp, int depth)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->ReadPixmap) (pScrn, x, y, w, h, dst, dstwidth, bpp, depth);
+}
+
+static RegionPtr
+XAAStateWrapCopyArea(DrawablePtr pSrcDrawable, DrawablePtr pDstDrawable,
+                     GC * pGC, int srcx, int srcy, int width, int height,
+                     int dstx, int dsty)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    return (*pStatePriv->CopyArea) (pSrcDrawable, pDstDrawable,
+                                    pGC, srcx, srcy, width, height, dstx, dsty);
+}
+
+static RegionPtr
+XAAStateWrapCopyPlane(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
+                      int srcx, int srcy, int width, int height,
+                      int dstx, int dsty, unsigned long bitPlane)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    return (*pStatePriv->CopyPlane) (pSrc, pDst, pGC,
+                                     srcx, srcy, width, height,
+                                     dstx, dsty, bitPlane);
+}
+
+static void
+XAAStateWrapPushPixelsSolid(GCPtr pGC, PixmapPtr pBitMap,
+                            DrawablePtr pDrawable, int dx, int dy, int xOrg,
+                            int yOrg)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->PushPixelsSolid) (pGC, pBitMap,
+                                    pDrawable, dx, dy, xOrg, yOrg);
+}
+
+static void
+XAAStateWrapPolyFillRectSolid(DrawablePtr pDraw, GCPtr pGC, int nrectFill,
+                              xRectangle *prectInit)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->PolyFillRectSolid) (pDraw, pGC, nrectFill, prectInit);
+}
+
+static void
+XAAStateWrapPolyFillRectStippled(DrawablePtr pDraw, GCPtr pGC, int nrectFill,
+                                 xRectangle *prectInit)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->PolyFillRectStippled) (pDraw, pGC, nrectFill, prectInit);
+}
+
+static void
+XAAStateWrapPolyFillRectOpaqueStippled(DrawablePtr pDraw, GCPtr pGC,
+                                       int nrectFill, xRectangle *prectInit)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->PolyFillRectOpaqueStippled) (pDraw, pGC,
+                                               nrectFill, prectInit);
+}
+
+static void
+XAAStateWrapPolyFillRectTiled(DrawablePtr pDraw, GCPtr pGC, int nrectFill,
+                              xRectangle *prectInit)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->PolyFillRectTiled) (pDraw, pGC, nrectFill, prectInit);
+}
+
+static void
+XAAStateWrapFillSpansSolid(DrawablePtr pDraw, GCPtr pGC, int nInit,
+                           DDXPointPtr ppt, int *pwidth, int fSorted)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->FillSpansSolid) (pDraw, pGC, nInit, ppt, pwidth, fSorted);
+}
+
+static void
+XAAStateWrapFillSpansStippled(DrawablePtr pDraw, GCPtr pGC, int nInit,
+                              DDXPointPtr ppt, int *pwidth, int fSorted)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->FillSpansStippled) (pDraw, pGC, nInit, ppt, pwidth, fSorted);
+}
+
+static void
+XAAStateWrapFillSpansOpaqueStippled(DrawablePtr pDraw, GCPtr pGC, int nInit,
+                                    DDXPointPtr ppt, int *pwidth, int fSorted)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->FillSpansOpaqueStippled) (pDraw, pGC, nInit,
+                                            ppt, pwidth, fSorted);
+}
+
+static void
+XAAStateWrapFillSpansTiled(DrawablePtr pDraw, GCPtr pGC, int nInit,
+                           DDXPointPtr ppt, int *pwidth, int fSorted)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->FillSpansTiled) (pDraw, pGC, nInit, ppt, pwidth, fSorted);
+}
+
+static int
+XAAStateWrapPolyText8TE(DrawablePtr pDraw, GCPtr pGC, int x, int y, int count,
+                        char *chars)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    return (*pStatePriv->PolyText8TE) (pDraw, pGC, x, y, count, chars);
+}
+
+static int
+XAAStateWrapPolyText16TE(DrawablePtr pDraw, GCPtr pGC, int x, int y, int count,
+                         unsigned short *chars)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    return (*pStatePriv->PolyText16TE) (pDraw, pGC, x, y, count, chars);
+}
+
+static void
+XAAStateWrapImageText8TE(DrawablePtr pDraw, GCPtr pGC, int x, int y,
+                         int count, char *chars)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ImageText8TE) (pDraw, pGC, x, y, count, chars);
+}
+
+static void
+XAAStateWrapImageText16TE(DrawablePtr pDraw, GCPtr pGC, int x, int y,
+                          int count, unsigned short *chars)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ImageText16TE) (pDraw, pGC, x, y, count, chars);
+}
+
+static void
+XAAStateWrapImageGlyphBltTE(DrawablePtr pDrawable, GCPtr pGC, int xInit,
+                            int yInit, unsigned int nglyph, CharInfoPtr * ppci,
+                            void *pglyphBase)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ImageGlyphBltTE) (pDrawable, pGC, xInit,
+                                    yInit, nglyph, ppci, pglyphBase);
+}
+
+static void
+XAAStateWrapPolyGlyphBltTE(DrawablePtr pDrawable, GCPtr pGC, int xInit,
+                           int yInit, unsigned int nglyph, CharInfoPtr * ppci,
+                           void *pglyphBase)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->PolyGlyphBltTE) (pDrawable, pGC, xInit,
+                                   yInit, nglyph, ppci, pglyphBase);
+}
+
+static int
+XAAStateWrapPolyText8NonTE(DrawablePtr pDraw, GCPtr pGC, int x, int y,
+                           int count, char *chars)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    return (*pStatePriv->PolyText8NonTE) (pDraw, pGC, x, y, count, chars);
+}
+
+static int
+XAAStateWrapPolyText16NonTE(DrawablePtr pDraw, GCPtr pGC, int x, int y,
+                            int count, unsigned short *chars)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    return (*pStatePriv->PolyText16NonTE) (pDraw, pGC, x, y, count, chars);
+}
+
+static void
+XAAStateWrapImageText8NonTE(DrawablePtr pDraw, GCPtr pGC, int x, int y,
+                            int count, char *chars)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ImageText8NonTE) (pDraw, pGC, x, y, count, chars);
+}
+
+static void
+XAAStateWrapImageText16NonTE(DrawablePtr pDraw, GCPtr pGC, int x, int y,
+                             int count, unsigned short *chars)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ImageText16NonTE) (pDraw, pGC, x, y, count, chars);
+}
+
+static void
+XAAStateWrapImageGlyphBltNonTE(DrawablePtr pDrawable, GCPtr pGC, int xInit,
+                               int yInit, unsigned int nglyph,
+                               CharInfoPtr * ppci, void *pglyphBase)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ImageGlyphBltNonTE) (pDrawable, pGC, xInit,
+                                       yInit, nglyph, ppci, pglyphBase);
+}
+
+static void
+XAAStateWrapPolyGlyphBltNonTE(DrawablePtr pDrawable, GCPtr pGC, int xInit,
+                              int yInit, unsigned int nglyph,
+                              CharInfoPtr * ppci, void *pglyphBase)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->PolyGlyphBltNonTE) (pDrawable, pGC, xInit,
+                                      yInit, nglyph, ppci, pglyphBase);
+}
+
+static void
+XAAStateWrapPolyRectangleThinSolid(DrawablePtr pDrawable, GCPtr pGC,
+                                   int nRectsInit, xRectangle *pRectsInit)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->PolyRectangleThinSolid) (pDrawable, pGC,
+                                           nRectsInit, pRectsInit);
+}
+
+static void
+XAAStateWrapPolylinesWideSolid(DrawablePtr pDrawable, GCPtr pGC, int mode,
+                               int npt, DDXPointPtr pPts)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->PolylinesWideSolid) (pDrawable, pGC, mode, npt, pPts);
+}
+
+static void
+XAAStateWrapPolylinesThinSolid(DrawablePtr pDrawable, GCPtr pGC, int mode,
+                               int npt, DDXPointPtr pPts)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->PolylinesThinSolid) (pDrawable, pGC, mode, npt, pPts);
+}
+
+static void
+XAAStateWrapPolySegmentThinSolid(DrawablePtr pDrawable, GCPtr pGC, int nseg,
+                                 xSegment * pSeg)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->PolySegmentThinSolid) (pDrawable, pGC, nseg, pSeg);
+}
+
+static void
+XAAStateWrapPolylinesThinDashed(DrawablePtr pDrawable, GCPtr pGC, int mode,
+                                int npt, DDXPointPtr pPts)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->PolylinesThinDashed) (pDrawable, pGC, mode, npt, pPts);
+}
+
+static void
+XAAStateWrapPolySegmentThinDashed(DrawablePtr pDrawable, GCPtr pGC, int nseg,
+                                  xSegment * pSeg)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->PolySegmentThinDashed) (pDrawable, pGC, nseg, pSeg);
+}
+
+static void
+XAAStateWrapFillPolygonSolid(DrawablePtr pDrawable, GCPtr pGC, int shape,
+                             int mode, int count, DDXPointPtr ptsIn)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->FillPolygonSolid) (pDrawable, pGC, shape, mode, count, ptsIn);
+}
+
+static void
+XAAStateWrapFillPolygonStippled(DrawablePtr pDrawable, GCPtr pGC, int shape,
+                                int mode, int count, DDXPointPtr ptsIn)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->FillPolygonStippled) (pDrawable, pGC, shape,
+                                        mode, count, ptsIn);
+}
+
+static void
+XAAStateWrapFillPolygonOpaqueStippled(DrawablePtr pDrawable, GCPtr pGC,
+                                      int shape, int mode, int count,
+                                      DDXPointPtr ptsIn)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->FillPolygonOpaqueStippled) (pDrawable, pGC,
+                                              shape, mode, count, ptsIn);
+}
+
+static void
+XAAStateWrapFillPolygonTiled(DrawablePtr pDrawable, GCPtr pGC, int shape,
+                             int mode, int count, DDXPointPtr ptsIn)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->FillPolygonTiled) (pDrawable, pGC, shape, mode, count, ptsIn);
+}
+
+static void
+XAAStateWrapPolyFillArcSolid(DrawablePtr pDraw, GCPtr pGC, int narcs,
+                             xArc * parcs)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->PolyFillArcSolid) (pDraw, pGC, narcs, parcs);
+}
+
+static void
+XAAStateWrapPutImage(DrawablePtr pDraw, GCPtr pGC, int depth, int x, int y,
+                     int w, int h, int leftPad, int format, char *pImage)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->PutImage) (pDraw, pGC, depth, x, y,
+                             w, h, leftPad, format, pImage);
+}
+
+static void
+XAAStateWrapValidateFillSpans(GCPtr pGC, unsigned long changes,
+                              DrawablePtr pDraw)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ValidateFillSpans) (pGC, changes, pDraw);
+}
+
+static void
+XAAStateWrapValidateSetSpans(GCPtr pGC, unsigned long changes,
+                             DrawablePtr pDraw)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ValidateSetSpans) (pGC, changes, pDraw);
+}
+
+static void
+XAAStateWrapValidatePutImage(GCPtr pGC, unsigned long changes,
+                             DrawablePtr pDraw)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ValidatePutImage) (pGC, changes, pDraw);
+}
+
+static void
+XAAStateWrapValidateCopyArea(GCPtr pGC, unsigned long changes,
+                             DrawablePtr pDraw)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ValidateCopyArea) (pGC, changes, pDraw);
+}
+
+static void
+XAAStateWrapValidateCopyPlane(GCPtr pGC, unsigned long changes,
+                              DrawablePtr pDraw)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ValidateCopyPlane) (pGC, changes, pDraw);
+}
+
+static void
+XAAStateWrapValidatePolyPoint(GCPtr pGC, unsigned long changes,
+                              DrawablePtr pDraw)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ValidatePolyPoint) (pGC, changes, pDraw);
+}
+
+static void
+XAAStateWrapValidatePolylines(GCPtr pGC, unsigned long changes,
+                              DrawablePtr pDraw)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ValidatePolylines) (pGC, changes, pDraw);
+}
+
+static void
+XAAStateWrapValidatePolySegment(GCPtr pGC, unsigned long changes,
+                                DrawablePtr pDraw)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ValidatePolySegment) (pGC, changes, pDraw);
+}
+
+static void
+XAAStateWrapValidatePolyRectangle(GCPtr pGC, unsigned long changes,
+                                  DrawablePtr pDraw)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ValidatePolyRectangle) (pGC, changes, pDraw);
+}
+
+static void
+XAAStateWrapValidatePolyArc(GCPtr pGC, unsigned long changes, DrawablePtr pDraw)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ValidatePolyArc) (pGC, changes, pDraw);
+}
+
+static void
+XAAStateWrapValidateFillPolygon(GCPtr pGC, unsigned long changes,
+                                DrawablePtr pDraw)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ValidateFillPolygon) (pGC, changes, pDraw);
+}
+
+static void
+XAAStateWrapValidatePolyFillRect(GCPtr pGC, unsigned long changes,
+                                 DrawablePtr pDraw)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ValidatePolyFillRect) (pGC, changes, pDraw);
+}
+
+static void
+XAAStateWrapValidatePolyFillArc(GCPtr pGC, unsigned long changes,
+                                DrawablePtr pDraw)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ValidatePolyFillArc) (pGC, changes, pDraw);
+}
+
+static void
+XAAStateWrapValidatePolyText8(GCPtr pGC, unsigned long changes,
+                              DrawablePtr pDraw)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ValidatePolyText8) (pGC, changes, pDraw);
+}
+
+static void
+XAAStateWrapValidatePolyText16(GCPtr pGC, unsigned long changes,
+                               DrawablePtr pDraw)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ValidatePolyText16) (pGC, changes, pDraw);
+}
+
+static void
+XAAStateWrapValidateImageText8(GCPtr pGC, unsigned long changes,
+                               DrawablePtr pDraw)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ValidateImageText8) (pGC, changes, pDraw);
+}
+
+static void
+XAAStateWrapValidateImageText16(GCPtr pGC, unsigned long changes,
+                                DrawablePtr pDraw)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ValidateImageText16) (pGC, changes, pDraw);
+}
+
+static void
+XAAStateWrapValidatePolyGlyphBlt(GCPtr pGC, unsigned long changes,
+                                 DrawablePtr pDraw)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ValidatePolyGlyphBlt) (pGC, changes, pDraw);
+}
+
+static void
+XAAStateWrapValidateImageGlyphBlt(GCPtr pGC, unsigned long changes,
+                                  DrawablePtr pDraw)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+    (*pStatePriv->ValidateImageGlyphBlt) (pGC, changes, pDraw);
+}
+
+static void
+XAAStateWrapValidatePushPixels(GCPtr pGC, unsigned long changes,
+                               DrawablePtr pDraw)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ValidatePushPixels) (pGC, changes, pDraw);
+}
+
+static void
+XAAStateWrapComputeDash(GCPtr pGC)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ComputeDash) (pGC);
+}
+
+static void
+XAAStateWrapInitPixmapCache(ScreenPtr pScreen, RegionPtr areas, void *data)
+{
+    GET_STATEPRIV_SCREEN(pScreen);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->InitPixmapCache) (pScreen, areas, data);
+}
+
+static void
+XAAStateWrapClosePixmapCache(ScreenPtr pScreen)
+{
+    GET_STATEPRIV_SCREEN(pScreen);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->ClosePixmapCache) (pScreen);
+}
+
+static int
+XAAStateWrapStippledFillChooser(GCPtr pGC)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    return (*pStatePriv->StippledFillChooser) (pGC);
+}
+
+static int
+XAAStateWrapOpaqueStippledFillChooser(GCPtr pGC)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    return (*pStatePriv->OpaqueStippledFillChooser) (pGC);
+}
+
+static int
+XAAStateWrapTiledFillChooser(GCPtr pGC)
+{
+    GET_STATEPRIV_GC(pGC);
+    STATE_CHECK_SP(pStatePriv);
+
+    return (*pStatePriv->TiledFillChooser) (pGC);
+}
+
+static XAACacheInfoPtr
+XAAStateWrapCacheTile(ScrnInfoPtr pScrn, PixmapPtr pPix)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    return (*pStatePriv->CacheTile) (pScrn, pPix);
+}
+
+static XAACacheInfoPtr
+XAAStateWrapCacheStipple(ScrnInfoPtr pScrn, PixmapPtr pPix, int fg, int bg)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    return (*pStatePriv->CacheStipple) (pScrn, pPix, fg, bg);
+}
+
+static XAACacheInfoPtr
+XAAStateWrapCacheMonoStipple(ScrnInfoPtr pScrn, PixmapPtr pPix)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    return (*pStatePriv->CacheMonoStipple) (pScrn, pPix);
+}
+
+static XAACacheInfoPtr
+XAAStateWrapCacheMono8x8Pattern(ScrnInfoPtr pScrn, int pat0, int pat1)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    return (*pStatePriv->CacheMono8x8Pattern) (pScrn, pat0, pat1);
+}
+
+static XAACacheInfoPtr
+XAAStateWrapCacheColor8x8Pattern(ScrnInfoPtr pScrn, PixmapPtr pPix,
+                                 int fg, int bg)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    return (*pStatePriv->CacheColor8x8Pattern) (pScrn, pPix, fg, bg);
+}
+
+static void
+XAAStateWrapWriteBitmapToCache(ScrnInfoPtr pScrn, int x, int y, int w, int h,
+                               unsigned char *src, int srcwidth, int fg, int bg)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->WriteBitmapToCache) (pScrn, x, y, w, h,
+                                       src, srcwidth, fg, bg);
+}
+
+static void
+XAAStateWrapWritePixmapToCache(ScrnInfoPtr pScrn, int x, int y, int w, int h,
+                               unsigned char *src, int srcwidth, int bpp,
+                               int depth)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->WritePixmapToCache) (pScrn, x, y, w, h,
+                                       src, srcwidth, bpp, depth);
+}
+
+static void
+XAAStateWrapWriteMono8x8PatternToCache(ScrnInfoPtr pScrn,
+                                       XAACacheInfoPtr pCache)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->WriteMono8x8PatternToCache) (pScrn, pCache);
+}
+
+static void
+XAAStateWrapWriteColor8x8PatternToCache(ScrnInfoPtr pScrn, PixmapPtr pPix,
+                                        XAACacheInfoPtr pCache)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    (*pStatePriv->WriteColor8x8PatternToCache) (pScrn, pPix, pCache);
+}
+
+static void
+XAAStateWrapGetImage(DrawablePtr pDrawable, int sx, int sy, int w, int h,
+                     unsigned int format, unsigned long planeMask,
+                     char *pdstLine)
+{
+    GET_STATEPRIV_SCREEN(pDrawable->pScreen);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->GetImage) (pDrawable, sx, sy, w, h,
+                             format, planeMask, pdstLine);
+}
+
+static void
+XAAStateWrapGetSpans(DrawablePtr pDrawable, int wMax, DDXPointPtr ppt,
+                     int *pwidth, int nspans, char *pdstStart)
+{
+    GET_STATEPRIV_SCREEN(pDrawable->pScreen);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->GetSpans) (pDrawable, wMax, ppt, pwidth, nspans, pdstStart);
+}
+
+static void
+XAAStateWrapCopyWindow(WindowPtr pWindow, DDXPointRec ptOldOrg,
+                       RegionPtr prgnSrc)
+{
+    GET_STATEPRIV_SCREEN(pWindow->drawable.pScreen);
+    STATE_CHECK_SP(pStatePriv);
+
+    (*pStatePriv->CopyWindow) (pWindow, ptOldOrg, prgnSrc);
+}
+
+static Bool
+XAAStateWrapSetupForCPUToScreenAlphaTexture2(ScrnInfoPtr pScrn,
+                                             int op, CARD16 red,
+                                             CARD16 green,
+                                             CARD16 blue,
+                                             CARD16 alpha,
+                                             CARD32 srcFormat,
+                                             CARD32 dstFormat,
+                                             CARD8 *alphaPtr,
+                                             int alphaPitch,
+                                             int width, int height, int flags)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    return (*pStatePriv->SetupForCPUToScreenAlphaTexture2) (pScrn, op, red,
+                                                            green, blue, alpha,
+                                                            srcFormat,
+                                                            dstFormat, alphaPtr,
+                                                            alphaPitch, width,
+                                                            height, flags);
+}
+
+static Bool
+XAAStateWrapSetupForCPUToScreenTexture2(ScrnInfoPtr pScrn, int op,
+                                        CARD32 srcFormat,
+                                        CARD32 dstFormat,
+                                        CARD8 *texPtr, int texPitch,
+                                        int width, int height, int flags)
+{
+    GET_STATEPRIV_PSCRN(pScrn);
+    STATE_CHECK_PSCRN(pScrn);
+
+    return (*pStatePriv->SetupForCPUToScreenTexture2) (pScrn, op, srcFormat,
+                                                       dstFormat, texPtr,
+                                                       texPitch, width, height,
+                                                       flags);
+}
+
+/* Setup Function */
+Bool
+XAAInitStateWrap(ScreenPtr pScreen, XAAInfoRecPtr infoRec)
+{
+    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
+    XAAStateWrapPtr pStatePriv;
+    int i = 0;
+
+    if (!dixRegisterPrivateKey(&XAAStateKeyRec, PRIVATE_SCREEN, 0))
+        return FALSE;
+    if (!(pStatePriv = malloc(sizeof(XAAStateWrapRec))))
+        return FALSE;
+    dixSetPrivate(&pScreen->devPrivates, XAAStateKey, pStatePriv);
+    pStatePriv->RestoreAccelState = infoRec->RestoreAccelState;
+    pStatePriv->pScrn = pScrn;
+
+    /* Initialize the last screen to -1 so whenever an accel function
+     * is called the proper state is setup
+     */
+    while (i < pScrn->numEntities) {
+        xf86SetLastScrnFlag(pScrn->entityList[i], -1);
+        i++;
+    }
+/* Do the wrapping */
+    XAA_STATE_WRAP(Sync);
+    XAA_STATE_WRAP(SetupForScreenToScreenCopy);
+    XAA_STATE_WRAP(SetupForSolidFill);
+    XAA_STATE_WRAP(SetupForSolidLine);
+    XAA_STATE_WRAP(SetupForDashedLine);
+    XAA_STATE_WRAP(SetClippingRectangle);
+    XAA_STATE_WRAP(DisableClipping);
+    XAA_STATE_WRAP(SetupForMono8x8PatternFill);
+    XAA_STATE_WRAP(SetupForColor8x8PatternFill);
+    XAA_STATE_WRAP(SetupForCPUToScreenColorExpandFill);
+    XAA_STATE_WRAP(SetupForScanlineCPUToScreenColorExpandFill);
+    XAA_STATE_WRAP(SetupForScreenToScreenColorExpandFill);
+    XAA_STATE_WRAP(SetupForImageWrite);
+    XAA_STATE_WRAP(SetupForScanlineImageWrite);
+    XAA_STATE_WRAP(SetupForImageRead);
+    XAA_STATE_WRAP(ScreenToScreenBitBlt);
+    XAA_STATE_WRAP(WriteBitmap);
+    XAA_STATE_WRAP(FillSolidRects);
+    XAA_STATE_WRAP(FillMono8x8PatternRects);
+    XAA_STATE_WRAP(FillColor8x8PatternRects);
+    XAA_STATE_WRAP(FillCacheBltRects);
+    XAA_STATE_WRAP(FillColorExpandRects);
+    XAA_STATE_WRAP(FillCacheExpandRects);
+    XAA_STATE_WRAP(FillImageWriteRects);
+    XAA_STATE_WRAP(FillSolidSpans);
+    XAA_STATE_WRAP(FillMono8x8PatternSpans);
+    XAA_STATE_WRAP(FillColor8x8PatternSpans);
+    XAA_STATE_WRAP(FillCacheBltSpans);
+    XAA_STATE_WRAP(FillColorExpandSpans);
+    XAA_STATE_WRAP(FillCacheExpandSpans);
+    XAA_STATE_WRAP(TEGlyphRenderer);
+    XAA_STATE_WRAP(NonTEGlyphRenderer);
+    XAA_STATE_WRAP(WritePixmap);
+    XAA_STATE_WRAP(ReadPixmap);
+    XAA_STATE_WRAP(CopyArea);
+    XAA_STATE_WRAP(CopyPlane);
+    XAA_STATE_WRAP(PushPixelsSolid);
+    XAA_STATE_WRAP(PolyFillRectSolid);
+    XAA_STATE_WRAP(PolyFillRectStippled);
+    XAA_STATE_WRAP(PolyFillRectOpaqueStippled);
+    XAA_STATE_WRAP(PolyFillRectTiled);
+    XAA_STATE_WRAP(FillSpansSolid);
+    XAA_STATE_WRAP(FillSpansStippled);
+    XAA_STATE_WRAP(FillSpansOpaqueStippled);
+    XAA_STATE_WRAP(FillSpansTiled);
+    XAA_STATE_WRAP(PolyText8TE);
+    XAA_STATE_WRAP(PolyText16TE);
+    XAA_STATE_WRAP(ImageText8TE);
+    XAA_STATE_WRAP(ImageText16TE);
+    XAA_STATE_WRAP(ImageGlyphBltTE);
+    XAA_STATE_WRAP(PolyGlyphBltTE);
+    XAA_STATE_WRAP(PolyText8NonTE);
+    XAA_STATE_WRAP(PolyText16NonTE);
+    XAA_STATE_WRAP(ImageText8NonTE);
+    XAA_STATE_WRAP(ImageText16NonTE);
+    XAA_STATE_WRAP(ImageGlyphBltNonTE);
+    XAA_STATE_WRAP(PolyGlyphBltNonTE);
+    XAA_STATE_WRAP(PolyRectangleThinSolid);
+    XAA_STATE_WRAP(PolylinesWideSolid);
+    XAA_STATE_WRAP(PolylinesThinSolid);
+    XAA_STATE_WRAP(PolySegmentThinSolid);
+    XAA_STATE_WRAP(PolylinesThinDashed);
+    XAA_STATE_WRAP(PolySegmentThinDashed);
+    XAA_STATE_WRAP(FillPolygonSolid);
+    XAA_STATE_WRAP(FillPolygonStippled);
+    XAA_STATE_WRAP(FillPolygonOpaqueStippled);
+    XAA_STATE_WRAP(FillPolygonTiled);
+    XAA_STATE_WRAP(PolyFillArcSolid);
+    XAA_STATE_WRAP(PutImage);
+    XAA_STATE_WRAP(ValidateFillSpans);
+    XAA_STATE_WRAP(ValidateSetSpans);
+    XAA_STATE_WRAP(ValidatePutImage);
+    XAA_STATE_WRAP(ValidateCopyArea);
+    XAA_STATE_WRAP(ValidateCopyPlane);
+    XAA_STATE_WRAP(ValidatePolyPoint);
+    XAA_STATE_WRAP(ValidatePolylines);
+    XAA_STATE_WRAP(ValidatePolySegment);
+    XAA_STATE_WRAP(ValidatePolyRectangle);
+    XAA_STATE_WRAP(ValidatePolyArc);
+    XAA_STATE_WRAP(ValidateFillPolygon);
+    XAA_STATE_WRAP(ValidatePolyFillRect);
+    XAA_STATE_WRAP(ValidatePolyFillArc);
+    XAA_STATE_WRAP(ValidatePolyText8);
+    XAA_STATE_WRAP(ValidatePolyText16);
+    XAA_STATE_WRAP(ValidateImageText8);
+    XAA_STATE_WRAP(ValidateImageText16);
+    XAA_STATE_WRAP(ValidatePolyGlyphBlt);
+    XAA_STATE_WRAP(ValidateImageGlyphBlt);
+    XAA_STATE_WRAP(ValidatePushPixels);
+    XAA_STATE_WRAP(ComputeDash);
+    XAA_STATE_WRAP(InitPixmapCache);
+    XAA_STATE_WRAP(ClosePixmapCache);
+    XAA_STATE_WRAP(StippledFillChooser);
+    XAA_STATE_WRAP(OpaqueStippledFillChooser);
+    XAA_STATE_WRAP(TiledFillChooser);
+    XAA_STATE_WRAP(CacheTile);
+    XAA_STATE_WRAP(CacheStipple);
+    XAA_STATE_WRAP(CacheMonoStipple);
+    XAA_STATE_WRAP(CacheMono8x8Pattern);
+    XAA_STATE_WRAP(CacheColor8x8Pattern);
+    XAA_STATE_WRAP(WriteBitmapToCache);
+    XAA_STATE_WRAP(WritePixmapToCache);
+    XAA_STATE_WRAP(WriteMono8x8PatternToCache);
+    XAA_STATE_WRAP(WriteColor8x8PatternToCache);
+    XAA_STATE_WRAP(GetImage);
+    XAA_STATE_WRAP(GetSpans);
+    XAA_STATE_WRAP(CopyWindow);
+    XAA_STATE_WRAP(SetupForCPUToScreenAlphaTexture2);
+    XAA_STATE_WRAP(SetupForCPUToScreenTexture2);
+    return TRUE;
+}
diff --git a/hw/xfree86/xaa/xaaStipple.c b/hw/xfree86/xaa/xaaStipple.c
new file mode 100644
index 000000000..fc74e3988
--- /dev/null
+++ b/hw/xfree86/xaa/xaaStipple.c
@@ -0,0 +1,915 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "xaa.h"
+#include "xaalocal.h"
+#include "xaacexp.h"
+#include "xf86.h"
+
+static CARD32 *StipplePowerOfTwo(CARD32 *, CARD32 *, int, int, int);
+static CARD32 *StipplePowerOfTwo_Inverted(CARD32 *, CARD32 *, int, int, int);
+static CARD32 *StippleUpTo32(CARD32 *, CARD32 *, int, int, int);
+static CARD32 *StippleUpTo32_Inverted(CARD32 *, CARD32 *, int, int, int);
+static CARD32 *StippleOver32(CARD32 *, CARD32 *, int, int, int);
+static CARD32 *StippleOver32_Inverted(CARD32 *, CARD32 *, int, int, int);
+
+#ifdef TRIPLE_BITS
+#define stipple_scanline_func EXPNAME(XAAStippleScanlineFunc3)
+#define stipple_get_scanline_func EXPNAME(XAAGetStippleScanlineFunc3)
+#else
+#define stipple_scanline_func EXPNAME(XAAStippleScanlineFunc)
+#define stipple_get_scanline_func EXPNAME(XAAGetStippleScanlineFunc)
+#endif
+
+StippleScanlineProcPtr stipple_scanline_func[6] = {
+    StipplePowerOfTwo,
+    StippleUpTo32,
+    StippleOver32,
+    StipplePowerOfTwo_Inverted,
+    StippleUpTo32_Inverted,
+    StippleOver32_Inverted
+};
+
+StippleScanlineProcPtr *
+stipple_get_scanline_func(void)
+{
+    return stipple_scanline_func;
+}
+
+#ifdef FIXEDBASE
+#define DEST(i)	*dest
+#define RETURN(i)	return(dest)
+#else
+#define DEST(i)	dest[i]
+#define RETURN(i)	return(dest + i)
+#endif
+
+/* TRIPLE_BITS pattern expansion */
+#ifdef TRIPLE_BITS
+#define EXPAND_PAT \
+	CARD32 pat1 = byte_expand3[pat & 0xFF], \
+	       pat2 = byte_expand3[(pat & 0xFF00) >> 8], \
+	       pat3 = byte_expand3[(pat & 0xFF0000) >> 16], \
+	       pat4 = byte_expand3[(pat & 0xFF000000) >> 24], \
+	       patA = pat1 | (pat2 << 24), \
+	       patB = (pat2 >> 8) | (pat3 << 16), \
+	       patC = (pat3 >> 16) | (pat4 << 8)
+#ifdef FIXED_BASE
+#define WRITE_PAT1 { \
+	*dest = patA; }
+#define WRITE_PAT2 { \
+	*dest = patA; \
+	*dest = patB; }
+#define WRITE_PAT3 { \
+	*dest = patA; \
+	*dest = patB; \
+	*dest = patC; }
+#else
+#define WRITE_PAT1 { \
+	*(dest++) = patA; }
+#define WRITE_PAT2 { \
+	*(dest) = patA; \
+	*(dest + 1) = patB; \
+	dest += 2; }
+#define WRITE_PAT3 { \
+	*(dest) = patA; \
+	*(dest + 1) = patB; \
+	*(dest + 2) = patC; \
+	dest += 3; }
+#endif
+#endif
+
+#if !defined(FIXEDBASE) && !defined(MSBFIRST) && !defined(TRIPLE_BITS)
+
+unsigned int XAAShiftMasks[32] = {
+    /* gcc is rather pedantic about SHIFT_R(0xFFFFFFFF,32) */
+    0x00000000, SHIFT_R(0xFFFFFFFF, 31),
+    SHIFT_R(0xFFFFFFFF, 30), SHIFT_R(0xFFFFFFFF, 29),
+    SHIFT_R(0xFFFFFFFF, 28), SHIFT_R(0xFFFFFFFF, 27),
+    SHIFT_R(0xFFFFFFFF, 26), SHIFT_R(0xFFFFFFFF, 25),
+    SHIFT_R(0xFFFFFFFF, 24), SHIFT_R(0xFFFFFFFF, 23),
+    SHIFT_R(0xFFFFFFFF, 22), SHIFT_R(0xFFFFFFFF, 21),
+    SHIFT_R(0xFFFFFFFF, 20), SHIFT_R(0xFFFFFFFF, 19),
+    SHIFT_R(0xFFFFFFFF, 18), SHIFT_R(0xFFFFFFFF, 17),
+    SHIFT_R(0xFFFFFFFF, 16), SHIFT_R(0xFFFFFFFF, 15),
+    SHIFT_R(0xFFFFFFFF, 14), SHIFT_R(0xFFFFFFFF, 13),
+    SHIFT_R(0xFFFFFFFF, 12), SHIFT_R(0xFFFFFFFF, 11),
+    SHIFT_R(0xFFFFFFFF, 10), SHIFT_R(0xFFFFFFFF, 9),
+    SHIFT_R(0xFFFFFFFF, 8), SHIFT_R(0xFFFFFFFF, 7),
+    SHIFT_R(0xFFFFFFFF, 6), SHIFT_R(0xFFFFFFFF, 5),
+    SHIFT_R(0xFFFFFFFF, 4), SHIFT_R(0xFFFFFFFF, 3),
+    SHIFT_R(0xFFFFFFFF, 2), SHIFT_R(0xFFFFFFFF, 1)
+};
+
+#endif
+
+void
+#ifdef TRIPLE_BITS
+ EXPNAME(XAAFillColorExpandRects3) (
+#else
+ EXPNAME(XAAFillColorExpandRects) (
+#endif
+                                      ScrnInfoPtr pScrn,
+                                      int fg, int bg, int rop,
+                                      unsigned int planemask,
+                                      int nBox,
+                                      BoxPtr pBox,
+                                      int xorg, int yorg, PixmapPtr pPix) {
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    CARD32 *base;
+    Bool TwoPass = FALSE, FirstPass = TRUE;
+    StippleScanlineProcPtr StippleFunc, FirstFunc, SecondFunc;
+    int stipplewidth = pPix->drawable.width;
+    int stippleheight = pPix->drawable.height;
+    int srcwidth = pPix->devKind;
+    int dwords, srcy, srcx, funcNo = 2, h;
+    unsigned char *src = (unsigned char *) pPix->devPrivate.ptr;
+    unsigned char *srcp;
+    int flag;
+
+    if (stipplewidth <= 32) {
+        if (stipplewidth & (stipplewidth - 1))
+            funcNo = 1;
+        else
+            funcNo = 0;
+    }
+    StippleFunc = stipple_scanline_func[funcNo];
+    SecondFunc = stipple_scanline_func[funcNo];
+    FirstFunc = stipple_scanline_func[funcNo + 3];
+
+#ifdef TRIPLE_BITS
+    if ((bg == -1) ||
+        (!(infoRec->CPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY) &&
+         (!(infoRec->CPUToScreenColorExpandFillFlags & RGB_EQUAL) ||
+          (CHECK_RGB_EQUAL(bg))))) {
+#else
+    if ((bg == -1) ||
+        !(infoRec->CPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY)) {
+#endif
+        /* one pass */
+    }
+    else if ((rop == GXcopy) && infoRec->FillSolidRects) {
+        /* one pass but we fill background rects first */
+        (*infoRec->FillSolidRects) (pScrn, bg, rop, planemask, nBox, pBox);
+        bg = -1;
+    }
+    else {
+        /* gotta do two passes */
+        TwoPass = TRUE;
+    }
+
+    if (!TwoPass)
+        (*infoRec->SetupForCPUToScreenColorExpandFill) (pScrn, fg, bg, rop,
+                                                        planemask);
+
+    while (nBox--) {
+#ifdef TRIPLE_BITS
+        dwords = (3 * (pBox->x2 - pBox->x1) + 31) >> 5;
+#else
+        dwords = (pBox->x2 - pBox->x1 + 31) >> 5;
+#endif
+
+ SECOND_PASS:
+        if (TwoPass) {
+            (*infoRec->SetupForCPUToScreenColorExpandFill) (pScrn,
+                                                            (FirstPass) ? bg :
+                                                            fg, -1, rop,
+                                                            planemask);
+            StippleFunc = (FirstPass) ? FirstFunc : SecondFunc;
+        }
+
+        h = pBox->y2 - pBox->y1;
+        flag = (infoRec->CPUToScreenColorExpandFillFlags
+                & CPU_TRANSFER_PAD_QWORD) && ((dwords * h) & 0x01);
+
+        (*infoRec->SubsequentCPUToScreenColorExpandFill) (pScrn, pBox->x1,
+                                                          pBox->y1,
+                                                          pBox->x2 - pBox->x1,
+                                                          h, 0);
+
+        base = (CARD32 *) infoRec->ColorExpandBase;
+
+        srcy = (pBox->y1 - yorg) % stippleheight;
+        if (srcy < 0)
+            srcy += stippleheight;
+        srcx = (pBox->x1 - xorg) % stipplewidth;
+        if (srcx < 0)
+            srcx += stipplewidth;
+
+        srcp = (srcwidth * srcy) + src;
+
+#ifndef FIXEDBASE
+        if ((dwords * h) <= infoRec->ColorExpandRange) {
+            while (h--) {
+                base =
+                    (*StippleFunc) (base, (CARD32 *) srcp, srcx, stipplewidth,
+                                    dwords);
+                srcy++;
+                srcp += srcwidth;
+                if (srcy >= stippleheight) {
+                    srcy = 0;
+                    srcp = src;
+                }
+            }
+        }
+        else
+#endif
+            while (h--) {
+                (*StippleFunc) (base, (CARD32 *) srcp, srcx, stipplewidth,
+                                dwords);
+                srcy++;
+                srcp += srcwidth;
+                if (srcy >= stippleheight) {
+                    srcy = 0;
+                    srcp = src;
+                }
+            }
+
+        if (flag) {
+            base = (CARD32 *) infoRec->ColorExpandBase;
+            base[0] = 0x00000000;
+        }
+
+        if (TwoPass) {
+            if (FirstPass) {
+                FirstPass = FALSE;
+                goto SECOND_PASS;
+            }
+            else
+                FirstPass = TRUE;
+        }
+
+        pBox++;
+    }
+
+    if (infoRec->CPUToScreenColorExpandFillFlags & SYNC_AFTER_COLOR_EXPAND)
+        (*infoRec->Sync) (pScrn);
+    else
+        SET_SYNC_FLAG(infoRec);
+}
+
+void
+#ifdef TRIPLE_BITS
+ EXPNAME(XAAFillColorExpandSpans3) (
+#else
+ EXPNAME(XAAFillColorExpandSpans) (
+#endif
+                                      ScrnInfoPtr pScrn,
+                                      int fg, int bg, int rop,
+                                      unsigned int planemask,
+                                      int n,
+                                      DDXPointPtr ppt,
+                                      int *pwidth,
+                                      int fSorted,
+                                      int xorg, int yorg, PixmapPtr pPix) {
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    CARD32 *base;
+    Bool TwoPass = FALSE, FirstPass = TRUE;
+    StippleScanlineProcPtr StippleFunc, FirstFunc, SecondFunc;
+    int stipplewidth = pPix->drawable.width;
+    int stippleheight = pPix->drawable.height;
+    int dwords, srcy, srcx, funcNo = 2;
+    unsigned char *srcp;
+
+    if (stipplewidth <= 32) {
+        if (stipplewidth & (stipplewidth - 1))
+            funcNo = 1;
+        else
+            funcNo = 0;
+    }
+    StippleFunc = stipple_scanline_func[funcNo];
+    SecondFunc = stipple_scanline_func[funcNo];
+    FirstFunc = stipple_scanline_func[funcNo + 3];
+
+#ifdef TRIPLE_BITS
+    if ((bg == -1) ||
+        (!(infoRec->CPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY) &&
+         (!(infoRec->CPUToScreenColorExpandFillFlags & RGB_EQUAL) ||
+          (CHECK_RGB_EQUAL(bg))))) {
+#else
+    if ((bg == -1) ||
+        !(infoRec->CPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY)) {
+#endif
+        /* one pass */
+    }
+    else if ((rop == GXcopy) && infoRec->FillSolidSpans) {
+        /* one pass but we fill background rects first */
+        (*infoRec->FillSolidSpans) (pScrn, bg, rop, planemask, n, ppt, pwidth,
+                                    fSorted);
+        bg = -1;
+    }
+    else {
+        /* gotta do two passes */
+        TwoPass = TRUE;
+    }
+
+    if (!TwoPass)
+        (*infoRec->SetupForCPUToScreenColorExpandFill) (pScrn, fg, bg, rop,
+                                                        planemask);
+
+    while (n--) {
+#ifdef TRIPLE_BITS
+        dwords = (3 * *pwidth + 31) >> 5;
+#else
+        dwords = (*pwidth + 31) >> 5;
+#endif
+
+        srcy = (ppt->y - yorg) % stippleheight;
+        if (srcy < 0)
+            srcy += stippleheight;
+        srcx = (ppt->x - xorg) % stipplewidth;
+        if (srcx < 0)
+            srcx += stipplewidth;
+
+        srcp = (pPix->devKind * srcy) + (unsigned char *) pPix->devPrivate.ptr;
+
+ SECOND_PASS:
+        if (TwoPass) {
+            (*infoRec->SetupForCPUToScreenColorExpandFill) (pScrn,
+                                                            (FirstPass) ? bg :
+                                                            fg, -1, rop,
+                                                            planemask);
+            StippleFunc = (FirstPass) ? FirstFunc : SecondFunc;
+        }
+
+        (*infoRec->SubsequentCPUToScreenColorExpandFill) (pScrn, ppt->x, ppt->y,
+                                                          *pwidth, 1, 0);
+
+        base = (CARD32 *) infoRec->ColorExpandBase;
+
+        (*StippleFunc) (base, (CARD32 *) srcp, srcx, stipplewidth, dwords);
+
+        if ((infoRec->CPUToScreenColorExpandFillFlags & CPU_TRANSFER_PAD_QWORD)
+            && (dwords & 0x01)) {
+            base = (CARD32 *) infoRec->ColorExpandBase;
+            base[0] = 0x00000000;
+        }
+
+        if (TwoPass) {
+            if (FirstPass) {
+                FirstPass = FALSE;
+                goto SECOND_PASS;
+            }
+            else
+                FirstPass = TRUE;
+        }
+
+        ppt++;
+        pwidth++;
+    }
+
+    if (infoRec->CPUToScreenColorExpandFillFlags & SYNC_AFTER_COLOR_EXPAND)
+        (*infoRec->Sync) (pScrn);
+    else
+        SET_SYNC_FLAG(infoRec);
+}
+
+#ifndef FIXEDBASE
+
+void
+#ifdef TRIPLE_BITS
+ EXPNAME(XAAFillScanlineColorExpandRects3) (
+#else
+ EXPNAME(XAAFillScanlineColorExpandRects) (
+#endif
+                                              ScrnInfoPtr pScrn,
+                                              int fg, int bg, int rop,
+                                              unsigned int planemask,
+                                              int nBox,
+                                              BoxPtr pBox,
+                                              int xorg, int yorg,
+                                              PixmapPtr pPix) {
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    CARD32 *base;
+    Bool TwoPass = FALSE, FirstPass = TRUE;
+    StippleScanlineProcPtr StippleFunc, FirstFunc, SecondFunc;
+    int stipplewidth = pPix->drawable.width;
+    int stippleheight = pPix->drawable.height;
+    int srcwidth = pPix->devKind;
+    int dwords, srcy, srcx, funcNo = 2, bufferNo, h;
+    unsigned char *src = pPix->devPrivate.ptr;
+    unsigned char *srcp;
+
+    if (stipplewidth <= 32) {
+        if (stipplewidth & (stipplewidth - 1))
+            funcNo = 1;
+        else
+            funcNo = 0;
+    }
+    StippleFunc = stipple_scanline_func[funcNo];
+    SecondFunc = stipple_scanline_func[funcNo];
+    FirstFunc = stipple_scanline_func[funcNo + 3];
+
+#ifdef TRIPLE_BITS
+    if ((bg == -1) ||
+        (!(infoRec->ScanlineCPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY)
+         && (!(infoRec->ScanlineCPUToScreenColorExpandFillFlags & RGB_EQUAL) ||
+             (CHECK_RGB_EQUAL(bg))))) {
+#else
+    if ((bg == -1) ||
+        !(infoRec->
+          ScanlineCPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY)) {
+#endif
+        /* one pass */
+    }
+    else if ((rop == GXcopy) && infoRec->FillSolidRects) {
+        /* one pass but we fill background rects first */
+        (*infoRec->FillSolidRects) (pScrn, bg, rop, planemask, nBox, pBox);
+        bg = -1;
+    }
+    else {
+        /* gotta do two passes */
+        TwoPass = TRUE;
+    }
+
+    if (!TwoPass)
+        (*infoRec->SetupForScanlineCPUToScreenColorExpandFill) (pScrn, fg, bg,
+                                                                rop, planemask);
+
+    while (nBox--) {
+#ifdef TRIPLE_BITS
+        dwords = (3 * (pBox->x2 - pBox->x1) + 31) >> 5;
+#else
+        dwords = (pBox->x2 - pBox->x1 + 31) >> 5;
+#endif
+
+ SECOND_PASS:
+        if (TwoPass) {
+            (*infoRec->SetupForScanlineCPUToScreenColorExpandFill) (pScrn,
+                                                                    (FirstPass)
+                                                                    ? bg : fg,
+                                                                    -1, rop,
+                                                                    planemask);
+            StippleFunc = (FirstPass) ? FirstFunc : SecondFunc;
+        }
+
+        h = pBox->y2 - pBox->y1;
+
+        (*infoRec->SubsequentScanlineCPUToScreenColorExpandFill) (pScrn,
+                                                                  pBox->x1,
+                                                                  pBox->y1,
+                                                                  pBox->x2 -
+                                                                  pBox->x1, h,
+                                                                  0);
+
+        bufferNo = 0;
+
+        srcy = (pBox->y1 - yorg) % stippleheight;
+        if (srcy < 0)
+            srcy += stippleheight;
+        srcx = (pBox->x1 - xorg) % stipplewidth;
+        if (srcx < 0)
+            srcx += stipplewidth;
+
+        srcp = (srcwidth * srcy) + src;
+
+        while (h--) {
+            base = (CARD32 *) infoRec->ScanlineColorExpandBuffers[bufferNo];
+            (*StippleFunc) (base, (CARD32 *) srcp, srcx, stipplewidth, dwords);
+            (*infoRec->SubsequentColorExpandScanline) (pScrn, bufferNo++);
+            if (bufferNo >= infoRec->NumScanlineColorExpandBuffers)
+                bufferNo = 0;
+            srcy++;
+            srcp += srcwidth;
+            if (srcy >= stippleheight) {
+                srcy = 0;
+                srcp = src;
+            }
+        }
+
+        if (TwoPass) {
+            if (FirstPass) {
+                FirstPass = FALSE;
+                goto SECOND_PASS;
+            }
+            else
+                FirstPass = TRUE;
+        }
+
+        pBox++;
+    }
+
+    SET_SYNC_FLAG(infoRec);
+}
+
+void
+#ifdef TRIPLE_BITS
+ EXPNAME(XAAFillScanlineColorExpandSpans3) (
+#else
+ EXPNAME(XAAFillScanlineColorExpandSpans) (
+#endif
+                                              ScrnInfoPtr pScrn,
+                                              int fg, int bg, int rop,
+                                              unsigned int planemask,
+                                              int n,
+                                              DDXPointPtr ppt,
+                                              int *pwidth,
+                                              int fSorted,
+                                              int xorg, int yorg,
+                                              PixmapPtr pPix) {
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    CARD32 *base;
+    Bool TwoPass = FALSE, FirstPass = TRUE;
+    StippleScanlineProcPtr StippleFunc, FirstFunc, SecondFunc;
+    int stipplewidth = pPix->drawable.width;
+    int stippleheight = pPix->drawable.height;
+    int dwords, srcy, srcx, funcNo = 2;
+    unsigned char *srcp;
+
+    if (stipplewidth <= 32) {
+        if (stipplewidth & (stipplewidth - 1))
+            funcNo = 1;
+        else
+            funcNo = 0;
+    }
+    StippleFunc = stipple_scanline_func[funcNo];
+    SecondFunc = stipple_scanline_func[funcNo];
+    FirstFunc = stipple_scanline_func[funcNo + 3];
+
+#ifdef TRIPLE_BITS
+    if ((bg == -1) ||
+        (!(infoRec->ScanlineCPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY)
+         && (!(infoRec->ScanlineCPUToScreenColorExpandFillFlags & RGB_EQUAL) ||
+             (CHECK_RGB_EQUAL(bg))))) {
+#else
+    if ((bg == -1) ||
+        !(infoRec->
+          ScanlineCPUToScreenColorExpandFillFlags & TRANSPARENCY_ONLY)) {
+#endif
+        /* one pass */
+    }
+    else if ((rop == GXcopy) && infoRec->FillSolidSpans) {
+        /* one pass but we fill background rects first */
+        (*infoRec->FillSolidSpans) (pScrn, bg, rop, planemask, n, ppt, pwidth,
+                                    fSorted);
+        bg = -1;
+    }
+    else {
+        /* gotta do two passes */
+        TwoPass = TRUE;
+    }
+
+    if (!TwoPass)
+        (*infoRec->SetupForScanlineCPUToScreenColorExpandFill) (pScrn, fg, bg,
+                                                                rop, planemask);
+
+    while (n--) {
+#ifdef TRIPLE_BITS
+        dwords = (3 * *pwidth + 31) >> 5;
+#else
+        dwords = (*pwidth + 31) >> 5;
+#endif
+
+        srcy = (ppt->y - yorg) % stippleheight;
+        if (srcy < 0)
+            srcy += stippleheight;
+        srcx = (ppt->x - xorg) % stipplewidth;
+        if (srcx < 0)
+            srcx += stipplewidth;
+
+        srcp = (pPix->devKind * srcy) + (unsigned char *) pPix->devPrivate.ptr;
+
+ SECOND_PASS:
+        if (TwoPass) {
+            (*infoRec->SetupForScanlineCPUToScreenColorExpandFill) (pScrn,
+                                                                    (FirstPass)
+                                                                    ? bg : fg,
+                                                                    -1, rop,
+                                                                    planemask);
+            StippleFunc = (FirstPass) ? FirstFunc : SecondFunc;
+        }
+
+        (*infoRec->SubsequentScanlineCPUToScreenColorExpandFill) (pScrn, ppt->x,
+                                                                  ppt->y,
+                                                                  *pwidth, 1,
+                                                                  0);
+
+        base = (CARD32 *) infoRec->ScanlineColorExpandBuffers[0];
+
+        (*StippleFunc) (base, (CARD32 *) srcp, srcx, stipplewidth, dwords);
+        (*infoRec->SubsequentColorExpandScanline) (pScrn, 0);
+
+        if (TwoPass) {
+            if (FirstPass) {
+                FirstPass = FALSE;
+                goto SECOND_PASS;
+            }
+            else
+                FirstPass = TRUE;
+        }
+
+        ppt++;
+        pwidth++;
+    }
+
+    SET_SYNC_FLAG(infoRec);
+}
+
+#endif
+
+static CARD32 *
+StipplePowerOfTwo(CARD32 *dest, CARD32 *src, int shift, int width, int dwords)
+{
+    CARD32 pat = *src;
+
+    if (width < 32) {
+        pat &= XAAShiftMasks[width];
+        while (width < 32) {
+            pat |= SHIFT_L(pat, width);
+            width <<= 1;
+        }
+    }
+
+    if (shift)
+        pat = SHIFT_R(pat, shift) | SHIFT_L(pat, 32 - shift);
+
+#ifdef MSBFIRST
+    pat = SWAP_BITS_IN_BYTES(pat);
+#endif
+
+#ifdef TRIPLE_BITS
+    {
+        EXPAND_PAT;
+
+        while (dwords >= 3) {
+            WRITE_PAT3;
+            dwords -= 3;
+        }
+        if (dwords == 2) {
+            WRITE_PAT2;
+        }
+        else if (dwords == 1) {
+            WRITE_PAT1;
+        }
+
+        return dest;
+    }
+#else                           /* TRIPLE_BITS */
+    while (dwords >= 4) {
+        DEST(0) = pat;
+        DEST(1) = pat;
+        DEST(2) = pat;
+        DEST(3) = pat;
+        dwords -= 4;
+#ifndef FIXEDBASE
+        dest += 4;
+#endif
+    }
+
+    if (!dwords)
+        return dest;
+    DEST(0) = pat;
+    if (dwords == 1)
+        RETURN(1);
+    DEST(1) = pat;
+    if (dwords == 2)
+        RETURN(2);
+    DEST(2) = pat;
+    RETURN(3);
+#endif                          /* TRIPLE_BITS */
+}
+
+static CARD32 *
+StipplePowerOfTwo_Inverted(CARD32 *dest, CARD32 *src,
+                           int shift, int width, int dwords)
+{
+    CARD32 pat = *src;
+
+    if (width < 32) {
+        pat &= XAAShiftMasks[width];
+        while (width < 32) {
+            pat |= SHIFT_L(pat, width);
+            width <<= 1;
+        }
+    }
+
+    if (shift)
+        pat = SHIFT_R(pat, shift) | SHIFT_L(pat, 32 - shift);
+
+#ifdef MSBFIRST
+    pat = SWAP_BITS_IN_BYTES(pat);
+#endif
+
+    pat = ~pat;
+
+#ifdef TRIPLE_BITS
+    {
+        EXPAND_PAT;
+
+        while (dwords >= 3) {
+            WRITE_PAT3;
+            dwords -= 3;
+        }
+        if (dwords == 2) {
+            WRITE_PAT2;
+        }
+        else if (dwords == 1) {
+            WRITE_PAT1;
+        }
+
+        return dest;
+    }
+#else                           /* TRIPLE_BITS */
+    while (dwords >= 4) {
+        DEST(0) = pat;
+        DEST(1) = pat;
+        DEST(2) = pat;
+        DEST(3) = pat;
+        dwords -= 4;
+#ifndef FIXEDBASE
+        dest += 4;
+#endif
+    }
+
+    if (!dwords)
+        return dest;
+    DEST(0) = pat;
+    if (dwords == 1)
+        RETURN(1);
+    DEST(1) = pat;
+    if (dwords == 2)
+        RETURN(2);
+    DEST(2) = pat;
+    RETURN(3);
+#endif                          /* TRIPLE_BITS */
+}
+
+static CARD32 *
+StippleUpTo32(CARD32 *base, CARD32 *src, int shift, int width, int dwords)
+{
+    CARD32 pat = *src & XAAShiftMasks[width];
+
+    while (width <= 15) {
+        pat |= SHIFT_L(pat, width);
+        width <<= 1;
+    }
+    pat |= SHIFT_L(pat, width);
+
+    while (dwords--) {
+        CARD32 bits = SHIFT_R(pat, shift) | SHIFT_L(pat, width - shift);
+
+#ifdef TRIPLE_BITS
+        if (dwords >= 2) {
+            WRITE_BITS3(bits);
+            dwords -= 2;
+        }
+        else if (dwords > 0) {
+            WRITE_BITS2(bits);
+            dwords--;
+        }
+        else {
+            WRITE_BITS1(bits);
+        }
+#else
+        WRITE_BITS(bits);
+#endif
+
+        shift += 32;
+        shift %= width;
+    }
+    return base;
+}
+
+static CARD32 *
+StippleUpTo32_Inverted(CARD32 *base, CARD32 *src,
+                       int shift, int width, int dwords)
+{
+    CARD32 pat = *src & XAAShiftMasks[width];
+
+    while (width <= 15) {
+        pat |= SHIFT_L(pat, width);
+        width <<= 1;
+    }
+    pat |= SHIFT_L(pat, width);
+
+    while (dwords--) {
+        CARD32 bits = ~(SHIFT_R(pat, shift) | SHIFT_L(pat, width - shift));
+
+#ifdef TRIPLE_BITS
+        if (dwords >= 2) {
+            WRITE_BITS3(bits);
+            dwords -= 2;
+        }
+        else if (dwords > 0) {
+            WRITE_BITS2(bits);
+            dwords--;
+        }
+        else {
+            WRITE_BITS1(bits);
+        }
+#else
+        WRITE_BITS(bits);
+#endif
+
+        shift += 32;
+        shift %= width;
+    }
+    return base;
+}
+
+static CARD32 *
+StippleOver32(CARD32 *base, CARD32 *src, int offset, int width, int dwords)
+{
+    CARD32 *srcp;
+    CARD32 bits;
+    int bitsleft, shift, usable;
+
+    while (dwords--) {
+        bitsleft = width - offset;
+        srcp = src + (offset >> 5);
+        shift = offset & 31;
+        usable = 32 - shift;
+
+        if (bitsleft < 32) {
+            if (bitsleft <= usable) {
+                bits = SHIFT_L(*src, bitsleft) |
+                    (SHIFT_R(*srcp, shift) & XAAShiftMasks[bitsleft]);
+            }
+            else {
+                bits = SHIFT_L(*src, bitsleft) |
+                    (SHIFT_L(srcp[1], usable) & XAAShiftMasks[bitsleft]) |
+                    (SHIFT_R(*srcp, shift) & XAAShiftMasks[usable]);
+            }
+        }
+        else if (shift)
+            bits = SHIFT_R(*srcp, shift) | SHIFT_L(srcp[1], usable);
+        else
+            bits = *srcp;
+
+#ifdef TRIPLE_BITS
+        if (dwords >= 2) {
+            WRITE_BITS3(bits);
+            dwords -= 2;
+        }
+        else if (dwords > 0) {
+            WRITE_BITS2(bits);
+            dwords--;
+        }
+        else {
+            WRITE_BITS1(bits);
+        }
+#else
+        WRITE_BITS(bits);
+#endif
+
+        offset += 32;
+        offset %= width;
+    }
+    return base;
+}
+
+static CARD32 *
+StippleOver32_Inverted(CARD32 *base, CARD32 *src,
+                       int offset, int width, int dwords)
+{
+    CARD32 *srcp;
+    CARD32 bits;
+    int bitsleft, shift, usable;
+
+    while (dwords--) {
+        bitsleft = width - offset;
+        srcp = src + (offset >> 5);
+        shift = offset & 31;
+        usable = 32 - shift;
+
+        if (bitsleft < 32) {
+            if (bitsleft <= usable) {
+                bits = SHIFT_L(*src, bitsleft) |
+                    (SHIFT_R(*srcp, shift) & XAAShiftMasks[bitsleft]);
+            }
+            else {
+                bits = SHIFT_L(*src, bitsleft) |
+                    (SHIFT_L(srcp[1], usable) & XAAShiftMasks[bitsleft]) |
+                    (SHIFT_R(*srcp, shift) & XAAShiftMasks[usable]);
+            }
+        }
+        else if (shift)
+            bits = SHIFT_R(*srcp, shift) | SHIFT_L(srcp[1], usable);
+        else
+            bits = *srcp;
+
+        bits = ~bits;
+
+#ifdef TRIPLE_BITS
+        if (dwords >= 2) {
+            WRITE_BITS3(bits);
+            dwords -= 2;
+        }
+        else if (dwords > 0) {
+            WRITE_BITS2(bits);
+            dwords--;
+        }
+        else {
+            WRITE_BITS1(bits);
+        }
+#else
+        WRITE_BITS(bits);
+#endif
+
+        offset += 32;
+        offset %= width;
+    }
+    return base;
+}
diff --git a/hw/xfree86/xaa/xaaTEGlyph.c b/hw/xfree86/xaa/xaaTEGlyph.c
new file mode 100644
index 000000000..2926c1df2
--- /dev/null
+++ b/hw/xfree86/xaa/xaaTEGlyph.c
@@ -0,0 +1,1083 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "xaa.h"
+#include "xaalocal.h"
+#include "xaacexp.h"
+#include "xf86.h"
+
+/* scanline function for TRIPLE_BITS_24BPP */
+static CARD32 *DrawTextScanline3(CARD32 *base, CARD32 *mem, int width);
+
+/* Loop unrolled functions for common font widths */
+static CARD32 *DrawTETextScanlineGeneric(CARD32 *base, unsigned int **glyphp,
+                                         int line, int width, int glyphwidth);
+static CARD32 *DrawTETextScanlineWidth7(CARD32 *base, unsigned int **glyphp,
+                                        int line, int width, int glyphwidth);
+static CARD32 *DrawTETextScanlineWidth10(CARD32 *base, unsigned int **glyphp,
+                                         int line, int width, int glyphwidth);
+static CARD32 *DrawTETextScanlineWidth12(CARD32 *base, unsigned int **glyphp,
+                                         int line, int width, int glyphwidth);
+static CARD32 *DrawTETextScanlineWidth14(CARD32 *base, unsigned int **glyphp,
+                                         int line, int width, int glyphwidth);
+static CARD32 *DrawTETextScanlineWidth16(CARD32 *base, unsigned int **glyphp,
+                                         int line, int width, int glyphwidth);
+static CARD32 *DrawTETextScanlineWidth18(CARD32 *base, unsigned int **glyphp,
+                                         int line, int width, int glyphwidth);
+static CARD32 *DrawTETextScanlineWidth24(CARD32 *base, unsigned int **glyphp,
+                                         int line, int width, int glyphwidth);
+
+#ifdef USEASSEMBLER
+#ifdef FIXEDBASE
+#ifdef MSBFIRST
+CARD32 *DrawTETextScanlineWidth6PMSBFirstFixedBase(CARD32 *base,
+                                                   unsigned int **glyphp,
+                                                   int line, int width,
+                                                   int glyphwidth);
+CARD32 *DrawTETextScanlineWidth8PMSBFirstFixedBase(CARD32 *base,
+                                                   unsigned int **glyphp,
+                                                   int line, int width,
+                                                   int glyphwidth);
+CARD32 *DrawTETextScanlineWidth9PMSBFirstFixedBase(CARD32 *base,
+                                                   unsigned int **glyphp,
+                                                   int line, int width,
+                                                   int glyphwidth);
+#else
+CARD32 *DrawTETextScanlineWidth6PLSBFirstFixedBase(CARD32 *base,
+                                                   unsigned int **glyphp,
+                                                   int line, int width,
+                                                   int glyphwidth);
+CARD32 *DrawTETextScanlineWidth8PLSBFirstFixedBase(CARD32 *base,
+                                                   unsigned int **glyphp,
+                                                   int line, int width,
+                                                   int glyphwidth);
+CARD32 *DrawTETextScanlineWidth9PLSBFirstFixedBase(CARD32 *base,
+                                                   unsigned int **glyphp,
+                                                   int line, int width,
+                                                   int glyphwidth);
+#endif
+#else
+#ifdef MSBFIRST
+CARD32 *DrawTETextScanlineWidth6PMSBFirst(CARD32 *base, unsigned int **glyphp,
+                                          int line, int width, int glyphwidth);
+CARD32 *DrawTETextScanlineWidth8PMSBFirst(CARD32 *base, unsigned int **glyphp,
+                                          int line, int width, int glyphwidth);
+CARD32 *DrawTETextScanlineWidth9PMSBFirst(CARD32 *base, unsigned int **glyphp,
+                                          int line, int width, int glyphwidth);
+#else
+CARD32 *DrawTETextScanlineWidth6PLSBFirst(CARD32 *base, unsigned int **glyphp,
+                                          int line, int width, int glyphwidth);
+CARD32 *DrawTETextScanlineWidth8PLSBFirst(CARD32 *base, unsigned int **glyphp,
+                                          int line, int width, int glyphwidth);
+CARD32 *DrawTETextScanlineWidth9PLSBFirst(CARD32 *base, unsigned int **glyphp,
+                                          int line, int width, int glyphwidth);
+#endif
+#endif
+#else
+static CARD32 *DrawTETextScanlineWidth6(CARD32 *base, unsigned int **glyphp,
+                                        int line, int width, int glyphwidth);
+static CARD32 *DrawTETextScanlineWidth8(CARD32 *base, unsigned int **glyphp,
+                                        int line, int width, int glyphwidth);
+static CARD32 *DrawTETextScanlineWidth9(CARD32 *base, unsigned int **glyphp,
+                                        int line, int width, int glyphwidth);
+#endif
+
+#define glyph_scanline_func EXPNAME(XAAGlyphScanlineFunc)
+#define glyph_get_scanline_func EXPNAME(XAAGetGlyphScanlineFunc)
+
+GlyphScanlineFuncPtr glyph_scanline_func[32] = {
+    DrawTETextScanlineGeneric, DrawTETextScanlineGeneric,
+    DrawTETextScanlineGeneric, DrawTETextScanlineGeneric,
+    DrawTETextScanlineGeneric,
+#ifdef USEASSEMBLER
+#ifdef FIXEDBASE
+#ifdef MSBFIRST
+    DrawTETextScanlineWidth6PMSBFirstFixedBase,
+    DrawTETextScanlineWidth7,
+    DrawTETextScanlineWidth8PMSBFirstFixedBase,
+    DrawTETextScanlineWidth9PMSBFirstFixedBase,
+#else
+    DrawTETextScanlineWidth6PLSBFirstFixedBase,
+    DrawTETextScanlineWidth7,
+    DrawTETextScanlineWidth8PLSBFirstFixedBase,
+    DrawTETextScanlineWidth9PLSBFirstFixedBase,
+#endif
+#else
+#ifdef MSBFIRST
+    DrawTETextScanlineWidth6PMSBFirst,
+    DrawTETextScanlineWidth7,
+    DrawTETextScanlineWidth8PMSBFirst,
+    DrawTETextScanlineWidth9PMSBFirst,
+#else
+    DrawTETextScanlineWidth6PLSBFirst,
+    DrawTETextScanlineWidth7,
+    DrawTETextScanlineWidth8PLSBFirst,
+    DrawTETextScanlineWidth9PLSBFirst,
+#endif
+#endif
+#else
+    DrawTETextScanlineWidth6, DrawTETextScanlineWidth7,
+    DrawTETextScanlineWidth8, DrawTETextScanlineWidth9,
+#endif
+    DrawTETextScanlineWidth10,
+    DrawTETextScanlineGeneric, DrawTETextScanlineWidth12,
+    DrawTETextScanlineGeneric, DrawTETextScanlineWidth14,
+    DrawTETextScanlineGeneric, DrawTETextScanlineWidth16,
+    DrawTETextScanlineGeneric, DrawTETextScanlineWidth18,
+    DrawTETextScanlineGeneric, DrawTETextScanlineGeneric,
+    DrawTETextScanlineGeneric, DrawTETextScanlineGeneric,
+    DrawTETextScanlineGeneric, DrawTETextScanlineWidth24,
+    DrawTETextScanlineGeneric, DrawTETextScanlineGeneric,
+    DrawTETextScanlineGeneric, DrawTETextScanlineGeneric,
+    DrawTETextScanlineGeneric, DrawTETextScanlineGeneric,
+    DrawTETextScanlineGeneric, DrawTETextScanlineGeneric
+};
+
+GlyphScanlineFuncPtr *
+glyph_get_scanline_func(void)
+{
+    return glyph_scanline_func;
+}
+
+/********************************************************************
+
+   Here we have TEGlyphRenders for a bunch of different color
+   expansion types.  The driver may provide its own renderer, but
+   this is the default one which renders using lower-level primitives
+   exported by the chipset driver.
+
+********************************************************************/
+
+/* This gets built for MSBFIRST or LSBFIRST with FIXEDBASE or not.
+	A total of 4 versions */
+
+void
+
+EXPNAME(XAATEGlyphRenderer) (ScrnInfoPtr pScrn,
+                             int x, int y, int w, int h, int skipleft,
+                             int startline, unsigned int **glyphs,
+                             int glyphWidth, int fg, int bg, int rop,
+                             unsigned planemask) {
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    CARD32 *base;
+    GlyphScanlineFuncPtr GlyphFunc = glyph_scanline_func[glyphWidth - 1];
+    int dwords = 0;
+
+    if ((bg != -1) && (infoRec->TEGlyphRendererFlags & TRANSPARENCY_ONLY)) {
+        (*infoRec->SetupForSolidFill) (pScrn, bg, rop, planemask);
+        (*infoRec->SubsequentSolidFillRect) (pScrn, x, y, w, h);
+        bg = -1;
+    }
+
+    (*infoRec->SetupForCPUToScreenColorExpandFill) (pScrn, fg, bg, rop,
+                                                    planemask);
+
+    if (skipleft &&
+        (!(infoRec->TEGlyphRendererFlags & LEFT_EDGE_CLIPPING) ||
+         (!(infoRec->TEGlyphRendererFlags & LEFT_EDGE_CLIPPING_NEGATIVE_X) &&
+          (skipleft > x)))) {
+        /* draw the first character only */
+
+        int count = h, line = startline;
+        int width = glyphWidth - skipleft;
+
+        if (width > w)
+            width = w;
+
+        (*infoRec->SubsequentCPUToScreenColorExpandFill) (pScrn, x, y, width, h,
+                                                          0);
+
+        base = (CARD32 *) infoRec->ColorExpandBase;
+
+        while (count--) {
+            register CARD32 tmp = SHIFT_R(glyphs[0][line++], skipleft);
+
+            WRITE_BITS(tmp);
+        }
+
+        w -= width;
+        if ((infoRec->TEGlyphRendererFlags & CPU_TRANSFER_PAD_QWORD) &&
+            ((((width + 31) >> 5) * h) & 1)) {
+            base = (CARD32 *) infoRec->ColorExpandBase;
+            base[0] = 0x00000000;
+        }
+        if (!w)
+            goto THE_END;
+        glyphs++;
+        x += width;
+        skipleft = 0;           /* nicely aligned again */
+    }
+
+    w += skipleft;
+    x -= skipleft;
+    dwords = ((w + 31) >> 5) * h;
+
+    (*infoRec->SubsequentCPUToScreenColorExpandFill) (pScrn, x, y, w, h,
+                                                      skipleft);
+
+    base = (CARD32 *) infoRec->ColorExpandBase;
+
+#ifndef FIXEDBASE
+    if ((((w + 31) >> 5) * h) <= infoRec->ColorExpandRange)
+        while (h--) {
+            base = (*GlyphFunc) (base, glyphs, startline++, w, glyphWidth);
+        }
+    else
+#endif
+        while (h--) {
+            (*GlyphFunc) (base, glyphs, startline++, w, glyphWidth);
+        }
+
+    if ((infoRec->TEGlyphRendererFlags & CPU_TRANSFER_PAD_QWORD) &&
+        (dwords & 1)) {
+        base = (CARD32 *) infoRec->ColorExpandBase;
+        base[0] = 0x00000000;
+    }
+
+ THE_END:
+
+    if (infoRec->TEGlyphRendererFlags & SYNC_AFTER_COLOR_EXPAND)
+        (*infoRec->Sync) (pScrn);
+    else
+        SET_SYNC_FLAG(infoRec);
+}
+
+/********************************************************************
+ 
+   This is the GlyphRenderer for TRIPLE_BITS_24BPP. It renders to a buffer
+   with the non FIXEDBASE LSB_FIRST code before tripling, and possibly
+   reversing the bits and sending them to the screen
+
+********************************************************************/
+
+void
+
+EXPNAME(XAATEGlyphRenderer3) (ScrnInfoPtr pScrn,
+                              int x, int y, int w, int h, int skipleft,
+                              int startline, unsigned int **glyphs,
+                              int glyphWidth, int fg, int bg, int rop,
+                              unsigned planemask) {
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    CARD32 *base, *mem;
+    GlyphScanlineFuncPtr GlyphFunc =
+        XAAGlyphScanlineFuncLSBFirst[glyphWidth - 1];
+    int dwords = 0;
+
+    if ((bg != -1) &&
+        ((infoRec->TEGlyphRendererFlags & TRANSPARENCY_ONLY) ||
+         ((infoRec->TEGlyphRendererFlags & RGB_EQUAL) &&
+          (!CHECK_RGB_EQUAL(bg))))) {
+        (*infoRec->SetupForSolidFill) (pScrn, bg, rop, planemask);
+        (*infoRec->SubsequentSolidFillRect) (pScrn, x, y, w, h);
+        bg = -1;
+    }
+
+    (*infoRec->SetupForCPUToScreenColorExpandFill) (pScrn, fg, bg, rop,
+                                                    planemask);
+
+    if (skipleft) {
+        /* draw the first character only */
+
+        int count = h, line = startline;
+        int width = glyphWidth - skipleft;
+        CARD32 bits;
+
+        if (width > w)
+            width = w;
+        (*infoRec->SubsequentCPUToScreenColorExpandFill) (pScrn, x, y, width, h,
+                                                          0);
+
+        base = (CARD32 *) infoRec->ColorExpandBase;
+
+        while (count--) {
+            bits = SHIFT_R(glyphs[0][line++], skipleft);
+            if (width >= 22) {
+                WRITE_BITS3(bits);
+            }
+            else if (width >= 11) {
+                WRITE_BITS2(bits);
+            }
+            else {
+                WRITE_BITS1(bits);
+            }
+        }
+
+        w -= width;
+        if ((infoRec->TEGlyphRendererFlags & CPU_TRANSFER_PAD_QWORD) &&
+            ((((3 * width + 31) >> 5) * h) & 1)) {
+            base = (CARD32 *) infoRec->ColorExpandBase;
+            base[0] = 0x00000000;
+        }
+        if (!w)
+            goto THE_END;
+        glyphs++;
+        x += width;
+        skipleft = 0;           /* nicely aligned again */
+    }
+
+    dwords = ((3 * w + 31) >> 5) * h;
+    mem = (CARD32 *) malloc(((w + 31) >> 3) * sizeof(char));
+    if (!mem)
+        return;
+
+    (*infoRec->SubsequentCPUToScreenColorExpandFill) (pScrn, x, y, w, h, 0);
+
+    base = (CARD32 *) infoRec->ColorExpandBase;
+
+#ifndef FIXEDBASE
+    if ((((3 * w + 31) >> 5) * h) <= infoRec->ColorExpandRange)
+        while (h--) {
+            (*GlyphFunc) (mem, glyphs, startline++, w, glyphWidth);
+            base = DrawTextScanline3(base, mem, w);
+        }
+    else
+#endif
+        while (h--) {
+            (*GlyphFunc) (mem, glyphs, startline++, w, glyphWidth);
+            DrawTextScanline3(base, mem, w);
+        }
+
+    free(mem);
+
+    if ((infoRec->TEGlyphRendererFlags & CPU_TRANSFER_PAD_QWORD) &&
+        (dwords & 1)) {
+        base = (CARD32 *) infoRec->ColorExpandBase;
+        base[0] = 0x00000000;
+    }
+
+ THE_END:
+
+    if (infoRec->TEGlyphRendererFlags & SYNC_AFTER_COLOR_EXPAND)
+        (*infoRec->Sync) (pScrn);
+    else
+        SET_SYNC_FLAG(infoRec);
+}
+
+#ifndef FIXEDBASE
+/*  Scanline version of above gets built for LSBFIRST and MSBFIRST */
+
+void
+
+EXPNAME(XAATEGlyphRendererScanline) (ScrnInfoPtr pScrn,
+                                     int x, int y, int w, int h, int skipleft,
+                                     int startline, unsigned int **glyphs,
+                                     int glyphWidth, int fg, int bg, int rop,
+                                     unsigned planemask) {
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int bufferNo;
+    CARD32 *base;
+    GlyphScanlineFuncPtr GlyphFunc = glyph_scanline_func[glyphWidth - 1];
+
+    if ((bg != -1) && (infoRec->TEGlyphRendererFlags & TRANSPARENCY_ONLY)) {
+        (*infoRec->SetupForSolidFill) (pScrn, bg, rop, planemask);
+        (*infoRec->SubsequentSolidFillRect) (pScrn, x, y, w, h);
+        bg = -1;
+    }
+
+    (*infoRec->SetupForScanlineCPUToScreenColorExpandFill) (pScrn, fg, bg, rop,
+                                                            planemask);
+
+    if (skipleft &&
+        (!(infoRec->TEGlyphRendererFlags & LEFT_EDGE_CLIPPING) ||
+         (!(infoRec->TEGlyphRendererFlags & LEFT_EDGE_CLIPPING_NEGATIVE_X) &&
+          (skipleft > x)))) {
+        /* draw the first character only */
+
+        int count = h, line = startline;
+        int width = glyphWidth - skipleft;
+
+        if (width > w)
+            width = w;
+
+        (*infoRec->SubsequentScanlineCPUToScreenColorExpandFill) (pScrn, x, y,
+                                                                  width, h, 0);
+
+        bufferNo = 0;
+
+        while (count--) {
+            register CARD32 tmp = SHIFT_R(glyphs[0][line++], skipleft);
+
+            base = (CARD32 *) infoRec->ScanlineColorExpandBuffers[bufferNo];
+            WRITE_BITS(tmp);
+            (*infoRec->SubsequentColorExpandScanline) (pScrn, bufferNo++);
+            if (bufferNo >= infoRec->NumScanlineColorExpandBuffers)
+                bufferNo = 0;
+        }
+
+        w -= width;
+        if (!w)
+            goto THE_END;
+        glyphs++;
+        x += width;
+        skipleft = 0;           /* nicely aligned again */
+    }
+
+    w += skipleft;
+    x -= skipleft;
+
+    (*infoRec->SubsequentScanlineCPUToScreenColorExpandFill) (pScrn, x, y, w, h,
+                                                              skipleft);
+
+    bufferNo = 0;
+
+    while (h--) {
+        base = (CARD32 *) infoRec->ScanlineColorExpandBuffers[bufferNo];
+        (*GlyphFunc) (base, glyphs, startline++, w, glyphWidth);
+        (*infoRec->SubsequentColorExpandScanline) (pScrn, bufferNo++);
+        if (bufferNo >= infoRec->NumScanlineColorExpandBuffers)
+            bufferNo = 0;
+    }
+
+ THE_END:
+
+    SET_SYNC_FLAG(infoRec);
+}
+
+void
+
+EXPNAME(XAATEGlyphRendererScanline3) (ScrnInfoPtr pScrn,
+                                      int x, int y, int w, int h, int skipleft,
+                                      int startline, unsigned int **glyphs,
+                                      int glyphWidth, int fg, int bg, int rop,
+                                      unsigned planemask) {
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int bufferNo;
+    CARD32 *base, *mem;
+    GlyphScanlineFuncPtr GlyphFunc =
+        XAAGlyphScanlineFuncLSBFirst[glyphWidth - 1];
+
+    if ((bg != -1) &&
+        ((infoRec->TEGlyphRendererFlags & TRANSPARENCY_ONLY) ||
+         ((infoRec->TEGlyphRendererFlags & RGB_EQUAL) &&
+          (!CHECK_RGB_EQUAL(bg))))) {
+        (*infoRec->SetupForSolidFill) (pScrn, bg, rop, planemask);
+        (*infoRec->SubsequentSolidFillRect) (pScrn, x, y, w, h);
+        bg = -1;
+    }
+
+    (*infoRec->SetupForScanlineCPUToScreenColorExpandFill) (pScrn, fg, bg, rop,
+                                                            planemask);
+
+    if (skipleft) {
+        /* draw the first character only */
+
+        int count = h, line = startline;
+        int width = glyphWidth - skipleft;
+        CARD32 bits;
+
+        if (width > w)
+            width = w;
+
+        (*infoRec->SubsequentScanlineCPUToScreenColorExpandFill) (pScrn, x, y,
+                                                                  width, h, 0);
+
+        bufferNo = 0;
+
+        while (count--) {
+            base = (CARD32 *) infoRec->ScanlineColorExpandBuffers[bufferNo];
+            bits = SHIFT_R(glyphs[0][line++], skipleft);
+            if (width >= 22) {
+                WRITE_BITS3(bits);
+            }
+            else if (width >= 11) {
+                WRITE_BITS2(bits);
+            }
+            else {
+                WRITE_BITS1(bits);
+            }
+            (*infoRec->SubsequentColorExpandScanline) (pScrn, bufferNo++);
+            if (bufferNo >= infoRec->NumScanlineColorExpandBuffers)
+                bufferNo = 0;
+        }
+
+        w -= width;
+        if (!w)
+            goto THE_END;
+        glyphs++;
+        x += width;
+        skipleft = 0;           /* nicely aligned again */
+    }
+
+    w += skipleft;
+    x -= skipleft;
+    mem = (CARD32 *) malloc(((w + 31) >> 3) * sizeof(char));
+    if (!mem)
+        return;
+
+    (*infoRec->SubsequentScanlineCPUToScreenColorExpandFill) (pScrn, x, y, w, h,
+                                                              skipleft);
+
+    bufferNo = 0;
+
+    while (h--) {
+        base = (CARD32 *) infoRec->ScanlineColorExpandBuffers[bufferNo];
+        (*GlyphFunc) (mem, glyphs, startline++, w, glyphWidth);
+        DrawTextScanline3(base, mem, w);
+        (*infoRec->SubsequentColorExpandScanline) (pScrn, bufferNo++);
+        if (bufferNo >= infoRec->NumScanlineColorExpandBuffers)
+            bufferNo = 0;
+    }
+
+    free(mem);
+
+ THE_END:
+
+    SET_SYNC_FLAG(infoRec);
+}
+
+#endif
+
+/********************************************************************
+
+   TRIPLE_BITS_24BPP scanline rendering code.
+
+********************************************************************/
+
+static CARD32 *
+DrawTextScanline3(CARD32 *base, CARD32 *mem, int width)
+{
+
+    while (width > 32) {
+        WRITE_BITS3(*mem);
+        mem++;
+        width -= 32;
+    }
+    if (width) {
+        if (width >= 22) {
+            WRITE_BITS3(*mem);
+        }
+        else if (width >= 11) {
+            WRITE_BITS2(*mem);
+        }
+        else {
+            WRITE_BITS1(*mem);
+        }
+    }
+
+    return base;
+}
+
+/********************************************************************
+
+   Generic TE scanline rendering code.
+
+********************************************************************/
+
+static CARD32 *
+DrawTETextScanlineGeneric(CARD32 *base,
+                          unsigned int **glyphp,
+                          int line, int width, int glyphwidth)
+{
+    CARD32 bits = (*glyphp)[line];
+    int shift = glyphwidth;
+
+    while (width > 32) {
+        while (shift < 32) {
+            glyphp++;
+            bits |= SHIFT_L((*glyphp)[line], shift);
+            shift += glyphwidth;
+        }
+        WRITE_BITS(bits);
+        shift &= 31;
+        if (shift)
+            bits = SHIFT_R((*glyphp)[line], (glyphwidth - shift));
+        else
+            bits = 0;
+        width -= 32;
+    }
+
+    if (width) {
+        width -= shift;
+        while (width > 0) {
+            glyphp++;
+            bits |= SHIFT_L((*glyphp)[line], shift);
+            shift += glyphwidth;
+            width -= glyphwidth;
+        }
+        WRITE_BITS(bits);
+    }
+
+    return base;
+}
+
+/********************************************************************
+
+   Loop unrolled TE font scanline rendering code
+
+********************************************************************/
+
+#ifndef USEASSEMBLER
+static CARD32 *
+DrawTETextScanlineWidth6(CARD32 *base,
+                         unsigned int **glyphp,
+                         int line, int width, int glyphwidth)
+{
+    while (1) {
+        unsigned int bits;
+
+        bits = glyphp[0][line];
+        bits |= SHIFT_L(glyphp[1][line], 6);
+        bits |= SHIFT_L(glyphp[2][line], 12);
+        bits |= SHIFT_L(glyphp[3][line], 18);
+        bits |= SHIFT_L(glyphp[4][line], 24);
+        bits |= SHIFT_L(glyphp[5][line], 30);
+        WRITE_IN_BITORDER(base, 0, bits);
+        CHECKRETURN(1);
+        bits = SHIFT_R(glyphp[5][line], 2);
+        bits |= SHIFT_L(glyphp[6][line], 4);
+        bits |= SHIFT_L(glyphp[7][line], 10);
+        bits |= SHIFT_L(glyphp[8][line], 16);
+        bits |= SHIFT_L(glyphp[9][line], 22);
+        bits |= SHIFT_L(glyphp[10][line], 28);
+        WRITE_IN_BITORDER(base, 1, bits);
+        CHECKRETURN(2);
+        bits = SHIFT_R(glyphp[10][line], 4);
+        bits |= SHIFT_L(glyphp[11][line], 2);
+        bits |= SHIFT_L(glyphp[12][line], 8);
+        bits |= SHIFT_L(glyphp[13][line], 14);
+        bits |= SHIFT_L(glyphp[14][line], 20);
+        bits |= SHIFT_L(glyphp[15][line], 26);
+        WRITE_IN_BITORDER(base, 2, bits);
+        CHECKRETURN(3);
+#ifndef FIXEDBASE
+        base += 3;
+#endif
+        width -= 96;
+        glyphp += 16;
+    }
+    return base;
+}
+#endif
+
+static CARD32 *
+DrawTETextScanlineWidth7(CARD32 *base,
+                         unsigned int **glyphp,
+                         int line, int width, int glyphwidth)
+{
+    while (1) {
+        unsigned int bits;
+
+        bits = glyphp[0][line];
+        bits |= SHIFT_L(glyphp[1][line], 7);
+        bits |= SHIFT_L(glyphp[2][line], 14);
+        bits |= SHIFT_L(glyphp[3][line], 21);
+        bits |= SHIFT_L(glyphp[4][line], 28);
+        WRITE_IN_BITORDER(base, 0, bits);
+        CHECKRETURN(1);
+        bits = SHIFT_R(glyphp[4][line], 4);
+        bits |= SHIFT_L(glyphp[5][line], 3);
+        bits |= SHIFT_L(glyphp[6][line], 10);
+        bits |= SHIFT_L(glyphp[7][line], 17);
+        bits |= SHIFT_L(glyphp[8][line], 24);
+        bits |= SHIFT_L(glyphp[9][line], 31);
+        WRITE_IN_BITORDER(base, 1, bits);
+        CHECKRETURN(2);
+        bits = SHIFT_R(glyphp[9][line], 1);
+        bits |= SHIFT_L(glyphp[10][line], 6);
+        bits |= SHIFT_L(glyphp[11][line], 13);
+        bits |= SHIFT_L(glyphp[12][line], 20);
+        bits |= SHIFT_L(glyphp[13][line], 27);
+        WRITE_IN_BITORDER(base, 2, bits);
+        CHECKRETURN(3);
+        bits = SHIFT_R(glyphp[13][line], 5);
+        bits |= SHIFT_L(glyphp[14][line], 2);
+        bits |= SHIFT_L(glyphp[15][line], 9);
+        bits |= SHIFT_L(glyphp[16][line], 16);
+        bits |= SHIFT_L(glyphp[17][line], 23);
+        bits |= SHIFT_L(glyphp[18][line], 30);
+        WRITE_IN_BITORDER(base, 3, bits);
+        CHECKRETURN(4);
+        bits = SHIFT_R(glyphp[18][line], 2);
+        bits |= SHIFT_L(glyphp[19][line], 5);
+        bits |= SHIFT_L(glyphp[20][line], 12);
+        bits |= SHIFT_L(glyphp[21][line], 19);
+        bits |= SHIFT_L(glyphp[22][line], 26);
+        WRITE_IN_BITORDER(base, 4, bits);
+        CHECKRETURN(5);
+        bits = SHIFT_R(glyphp[22][line], 6);
+        bits |= SHIFT_L(glyphp[23][line], 1);
+        bits |= SHIFT_L(glyphp[24][line], 8);
+        bits |= SHIFT_L(glyphp[25][line], 15);
+        bits |= SHIFT_L(glyphp[26][line], 22);
+        bits |= SHIFT_L(glyphp[27][line], 29);
+        WRITE_IN_BITORDER(base, 5, bits);
+        CHECKRETURN(6);
+        bits = SHIFT_R(glyphp[27][line], 3);
+        bits |= SHIFT_L(glyphp[28][line], 4);
+        bits |= SHIFT_L(glyphp[29][line], 11);
+        bits |= SHIFT_L(glyphp[30][line], 18);
+        bits |= SHIFT_L(glyphp[31][line], 25);
+        WRITE_IN_BITORDER(base, 6, bits);
+        CHECKRETURN(7);
+#ifndef FIXEDBASE
+        base += 7;
+#endif
+        width -= 224;
+        glyphp += 32;
+    }
+    return base;
+}
+
+#ifndef USEASSEMBLER
+static CARD32 *
+DrawTETextScanlineWidth8(CARD32 *base,
+                         unsigned int **glyphp,
+                         int line, int width, int glyphwidth)
+{
+    while (1) {
+        unsigned int bits;
+
+        bits = glyphp[0][line];
+        bits |= SHIFT_L(glyphp[1][line], 8);
+        bits |= SHIFT_L(glyphp[2][line], 16);
+        bits |= SHIFT_L(glyphp[3][line], 24);
+        WRITE_IN_BITORDER(base, 0, bits);
+        CHECKRETURN(1);
+        bits = glyphp[4][line];
+        bits |= SHIFT_L(glyphp[5][line], 8);
+        bits |= SHIFT_L(glyphp[6][line], 16);
+        bits |= SHIFT_L(glyphp[7][line], 24);
+        WRITE_IN_BITORDER(base, 1, bits);
+        CHECKRETURN(2);
+#ifndef FIXEDBASE
+        base += 2;
+#endif
+        width -= 64;
+        glyphp += 8;
+    }
+    return base;
+}
+#endif
+
+#ifndef USEASSEMBLER
+static CARD32 *
+DrawTETextScanlineWidth9(CARD32 *base,
+                         unsigned int **glyphp,
+                         int line, int width, int glyphwidth)
+{
+    while (1) {
+        unsigned int bits;
+
+        bits = glyphp[0][line];
+        bits |= SHIFT_L(glyphp[1][line], 9);
+        bits |= SHIFT_L(glyphp[2][line], 18);
+        bits |= SHIFT_L(glyphp[3][line], 27);
+        WRITE_IN_BITORDER(base, 0, bits);
+        CHECKRETURN(1);
+        bits = SHIFT_R(glyphp[3][line], 5);
+        bits |= SHIFT_L(glyphp[4][line], 4);
+        bits |= SHIFT_L(glyphp[5][line], 13);
+        bits |= SHIFT_L(glyphp[6][line], 22);
+        bits |= SHIFT_L(glyphp[7][line], 31);
+        WRITE_IN_BITORDER(base, 1, bits);
+        CHECKRETURN(2);
+        bits = SHIFT_R(glyphp[7][line], 1);
+        bits |= SHIFT_L(glyphp[8][line], 8);
+        bits |= SHIFT_L(glyphp[9][line], 17);
+        bits |= SHIFT_L(glyphp[10][line], 26);
+        WRITE_IN_BITORDER(base, 2, bits);
+        CHECKRETURN(3);
+        bits = SHIFT_R(glyphp[10][line], 6);
+        bits |= SHIFT_L(glyphp[11][line], 3);
+        bits |= SHIFT_L(glyphp[12][line], 12);
+        bits |= SHIFT_L(glyphp[13][line], 21);
+        bits |= SHIFT_L(glyphp[14][line], 30);
+        WRITE_IN_BITORDER(base, 3, bits);
+        CHECKRETURN(4);
+        bits = SHIFT_R(glyphp[14][line], 2);
+        bits |= SHIFT_L(glyphp[15][line], 7);
+        bits |= SHIFT_L(glyphp[16][line], 16);
+        bits |= SHIFT_L(glyphp[17][line], 25);
+        WRITE_IN_BITORDER(base, 4, bits);
+        CHECKRETURN(5);
+        bits = SHIFT_R(glyphp[17][line], 7);
+        bits |= SHIFT_L(glyphp[18][line], 2);
+        bits |= SHIFT_L(glyphp[19][line], 11);
+        bits |= SHIFT_L(glyphp[20][line], 20);
+        bits |= SHIFT_L(glyphp[21][line], 29);
+        WRITE_IN_BITORDER(base, 5, bits);
+        CHECKRETURN(6);
+        bits = SHIFT_R(glyphp[21][line], 3);
+        bits |= SHIFT_L(glyphp[22][line], 6);
+        bits |= SHIFT_L(glyphp[23][line], 15);
+        bits |= SHIFT_L(glyphp[24][line], 24);
+        WRITE_IN_BITORDER(base, 6, bits);
+        CHECKRETURN(7);
+        bits = SHIFT_R(glyphp[24][line], 8);
+        bits |= SHIFT_L(glyphp[25][line], 1);
+        bits |= SHIFT_L(glyphp[26][line], 10);
+        bits |= SHIFT_L(glyphp[27][line], 19);
+        bits |= SHIFT_L(glyphp[28][line], 28);
+        WRITE_IN_BITORDER(base, 7, bits);
+        CHECKRETURN(8);
+        bits = SHIFT_R(glyphp[28][line], 4);
+        bits |= SHIFT_L(glyphp[29][line], 5);
+        bits |= SHIFT_L(glyphp[30][line], 14);
+        bits |= SHIFT_L(glyphp[31][line], 23);
+        WRITE_IN_BITORDER(base, 8, bits);
+        CHECKRETURN(9);
+#ifndef FIXEDBASE
+        base += 9;
+#endif
+        width -= 288;
+        glyphp += 32;
+    }
+    return base;
+}
+#endif
+
+static CARD32 *
+DrawTETextScanlineWidth10(CARD32 *base,
+                          unsigned int **glyphp,
+                          int line, int width, int glyphwidth)
+{
+    while (1) {
+        unsigned int bits;
+
+        bits = glyphp[0][line];
+        bits |= SHIFT_L(glyphp[1][line], 10);
+        bits |= SHIFT_L(glyphp[2][line], 20);
+        bits |= SHIFT_L(glyphp[3][line], 30);
+        WRITE_IN_BITORDER(base, 0, bits);
+        CHECKRETURN(1);
+        bits = SHIFT_R(glyphp[3][line], 2);
+        bits |= SHIFT_L(glyphp[4][line], 8);
+        bits |= SHIFT_L(glyphp[5][line], 18);
+        bits |= SHIFT_L(glyphp[6][line], 28);
+        WRITE_IN_BITORDER(base, 1, bits);
+        CHECKRETURN(2);
+        bits = SHIFT_R(glyphp[6][line], 4);
+        bits |= SHIFT_L(glyphp[7][line], 6);
+        bits |= SHIFT_L(glyphp[8][line], 16);
+        bits |= SHIFT_L(glyphp[9][line], 26);
+        WRITE_IN_BITORDER(base, 2, bits);
+        CHECKRETURN(3);
+        bits = SHIFT_R(glyphp[9][line], 6);
+        bits |= SHIFT_L(glyphp[10][line], 4);
+        bits |= SHIFT_L(glyphp[11][line], 14);
+        bits |= SHIFT_L(glyphp[12][line], 24);
+        WRITE_IN_BITORDER(base, 3, bits);
+        CHECKRETURN(4);
+        bits = SHIFT_R(glyphp[12][line], 8);
+        bits |= SHIFT_L(glyphp[13][line], 2);
+        bits |= SHIFT_L(glyphp[14][line], 12);
+        bits |= SHIFT_L(glyphp[15][line], 22);
+        WRITE_IN_BITORDER(base, 4, bits);
+        CHECKRETURN(5);
+#ifndef FIXEDBASE
+        base += 5;
+#endif
+        width -= 160;
+        glyphp += 16;
+    }
+    return base;
+}
+
+static CARD32 *
+DrawTETextScanlineWidth12(CARD32 *base,
+                          unsigned int **glyphp,
+                          int line, int width, int glyphwidth)
+{
+    while (1) {
+        unsigned int bits;
+
+        bits = glyphp[0][line];
+        bits |= SHIFT_L(glyphp[1][line], 12);
+        bits |= SHIFT_L(glyphp[2][line], 24);
+        WRITE_IN_BITORDER(base, 0, bits);
+        CHECKRETURN(1);
+        bits = SHIFT_R(glyphp[2][line], 8);
+        bits |= SHIFT_L(glyphp[3][line], 4);
+        bits |= SHIFT_L(glyphp[4][line], 16);
+        bits |= SHIFT_L(glyphp[5][line], 28);
+        WRITE_IN_BITORDER(base, 1, bits);
+        CHECKRETURN(2);
+        bits = SHIFT_R(glyphp[5][line], 4);
+        bits |= SHIFT_L(glyphp[6][line], 8);
+        bits |= SHIFT_L(glyphp[7][line], 20);
+        WRITE_IN_BITORDER(base, 2, bits);
+        CHECKRETURN(3);
+#ifndef FIXEDBASE
+        base += 3;
+#endif
+        width -= 96;
+        glyphp += 8;
+    }
+    return base;
+}
+
+static CARD32 *
+DrawTETextScanlineWidth14(CARD32 *base,
+                          unsigned int **glyphp,
+                          int line, int width, int glyphwidth)
+{
+    while (1) {
+        unsigned int bits;
+
+        bits = glyphp[0][line];
+        bits |= SHIFT_L(glyphp[1][line], 14);
+        bits |= SHIFT_L(glyphp[2][line], 28);
+        WRITE_IN_BITORDER(base, 0, bits);
+        CHECKRETURN(1);
+        bits = SHIFT_R(glyphp[2][line], 4);
+        bits |= SHIFT_L(glyphp[3][line], 10);
+        bits |= SHIFT_L(glyphp[4][line], 24);
+        WRITE_IN_BITORDER(base, 1, bits);
+        CHECKRETURN(2);
+        bits = SHIFT_R(glyphp[4][line], 8);
+        bits |= SHIFT_L(glyphp[5][line], 6);
+        bits |= SHIFT_L(glyphp[6][line], 20);
+        WRITE_IN_BITORDER(base, 2, bits);
+        CHECKRETURN(3);
+        bits = SHIFT_R(glyphp[6][line], 12);
+        bits |= SHIFT_L(glyphp[7][line], 2);
+        bits |= SHIFT_L(glyphp[8][line], 16);
+        bits |= SHIFT_L(glyphp[9][line], 30);
+        WRITE_IN_BITORDER(base, 3, bits);
+        CHECKRETURN(4);
+        bits = SHIFT_R(glyphp[9][line], 2);
+        bits |= SHIFT_L(glyphp[10][line], 12);
+        bits |= SHIFT_L(glyphp[11][line], 26);
+        WRITE_IN_BITORDER(base, 4, bits);
+        CHECKRETURN(5);
+        bits = SHIFT_R(glyphp[11][line], 6);
+        bits |= SHIFT_L(glyphp[12][line], 8);
+        bits |= SHIFT_L(glyphp[13][line], 22);
+        WRITE_IN_BITORDER(base, 5, bits);
+        CHECKRETURN(6);
+        bits = SHIFT_R(glyphp[13][line], 10);
+        bits |= SHIFT_L(glyphp[14][line], 4);
+        bits |= SHIFT_L(glyphp[15][line], 18);
+        WRITE_IN_BITORDER(base, 6, bits);
+        CHECKRETURN(7);
+#ifndef FIXEDBASE
+        base += 7;
+#endif
+        width -= 224;
+        glyphp += 16;
+    }
+    return base;
+}
+
+static CARD32 *
+DrawTETextScanlineWidth16(CARD32 *base,
+                          unsigned int **glyphp,
+                          int line, int width, int glyphwidth)
+{
+    while (1) {
+        unsigned int bits;
+
+        bits = glyphp[0][line];
+        bits |= SHIFT_L(glyphp[1][line], 16);
+        WRITE_IN_BITORDER(base, 0, bits);
+        CHECKRETURN(1);
+        bits = glyphp[2][line];
+        bits |= SHIFT_L(glyphp[3][line], 16);
+        WRITE_IN_BITORDER(base, 1, bits);
+        CHECKRETURN(2);
+        bits = glyphp[4][line];
+        bits |= SHIFT_L(glyphp[5][line], 16);
+        WRITE_IN_BITORDER(base, 2, bits);
+        CHECKRETURN(3);
+        bits = glyphp[6][line];
+        bits |= SHIFT_L(glyphp[7][line], 16);
+        WRITE_IN_BITORDER(base, 3, bits);
+        CHECKRETURN(4);
+#ifndef FIXEDBASE
+        base += 4;
+#endif
+        width -= 128;
+        glyphp += 8;
+    }
+    return base;
+}
+
+static CARD32 *
+DrawTETextScanlineWidth18(CARD32 *base,
+                          unsigned int **glyphp,
+                          int line, int width, int glyphwidth)
+{
+    while (1) {
+        unsigned int bits;
+
+        bits = glyphp[0][line];
+        bits |= SHIFT_L(glyphp[1][line], 18);
+        WRITE_IN_BITORDER(base, 0, bits);
+        CHECKRETURN(1);
+        bits = SHIFT_R(glyphp[1][line], 14);
+        bits |= SHIFT_L(glyphp[2][line], 4);
+        bits |= SHIFT_L(glyphp[3][line], 22);
+        WRITE_IN_BITORDER(base, 1, bits);
+        CHECKRETURN(2);
+        bits = SHIFT_R(glyphp[3][line], 10);
+        bits |= SHIFT_L(glyphp[4][line], 8);
+        bits |= SHIFT_L(glyphp[5][line], 26);
+        WRITE_IN_BITORDER(base, 2, bits);
+        CHECKRETURN(3);
+        bits = SHIFT_R(glyphp[5][line], 6);
+        bits |= SHIFT_L(glyphp[6][line], 12);
+        bits |= SHIFT_L(glyphp[7][line], 30);
+        WRITE_IN_BITORDER(base, 3, bits);
+        CHECKRETURN(4);
+        bits = SHIFT_R(glyphp[7][line], 2);
+        bits |= SHIFT_L(glyphp[8][line], 16);
+        WRITE_IN_BITORDER(base, 4, bits);
+        CHECKRETURN(5);
+        bits = SHIFT_R(glyphp[8][line], 16);
+        bits |= SHIFT_L(glyphp[9][line], 2);
+        bits |= SHIFT_L(glyphp[10][line], 20);
+        WRITE_IN_BITORDER(base, 5, bits);
+        CHECKRETURN(6);
+        bits = SHIFT_R(glyphp[10][line], 12);
+        bits |= SHIFT_L(glyphp[11][line], 6);
+        bits |= SHIFT_L(glyphp[12][line], 24);
+        WRITE_IN_BITORDER(base, 6, bits);
+        CHECKRETURN(7);
+        bits = SHIFT_R(glyphp[12][line], 8);
+        bits |= SHIFT_L(glyphp[13][line], 10);
+        bits |= SHIFT_L(glyphp[14][line], 28);
+        WRITE_IN_BITORDER(base, 7, bits);
+        CHECKRETURN(8);
+        bits = SHIFT_R(glyphp[14][line], 4);
+        bits |= SHIFT_L(glyphp[15][line], 14);
+        WRITE_IN_BITORDER(base, 8, bits);
+        CHECKRETURN(9);
+#ifndef FIXEDBASE
+        base += 9;
+#endif
+        width -= 288;
+        glyphp += 16;
+    }
+    return base;
+}
+
+static CARD32 *
+DrawTETextScanlineWidth24(CARD32 *base,
+                          unsigned int **glyphp,
+                          int line, int width, int glyphwidth)
+{
+    while (1) {
+        unsigned int bits;
+
+        bits = glyphp[0][line];
+        bits |= SHIFT_L(glyphp[1][line], 24);
+        WRITE_IN_BITORDER(base, 0, bits);
+        CHECKRETURN(1);
+        bits = SHIFT_R(glyphp[1][line], 8);
+        bits |= SHIFT_L(glyphp[2][line], 16);
+        WRITE_IN_BITORDER(base, 1, bits);
+        CHECKRETURN(2);
+        bits = SHIFT_R(glyphp[2][line], 16);
+        bits |= SHIFT_L(glyphp[3][line], 8);
+        WRITE_IN_BITORDER(base, 2, bits);
+        CHECKRETURN(3);
+#ifndef FIXEDBASE
+        base += 3;
+#endif
+        width -= 96;
+        glyphp += 4;
+    }
+    return base;
+}
diff --git a/hw/xfree86/xaa/xaaTEText.c b/hw/xfree86/xaa/xaaTEText.c
new file mode 100644
index 000000000..0bb0d2cee
--- /dev/null
+++ b/hw/xfree86/xaa/xaaTEText.c
@@ -0,0 +1,295 @@
+
+/********************************************************************
+
+   In this file we have GC level replacements for PolyText8/16,
+   ImageText8/16, ImageGlyphBlt and PolyGlyphBlt for TE (fixed) fonts.
+   The idea is that everything in this file is device independent.
+   The mentioned GCOps are merely wrappers for XAAGlyphBltTEColorExpansion
+   which calculates the boxes containing arbitrarily clipped text
+   and passes them to the TEGlyphRenderer which will usually be a lower 
+   level XAA function which renders these clipped glyphs using
+   the basic color expansion functions exported by the chipset driver.
+   The TEGlyphRenderer itself may optionally be driver supplied to
+   facilitate work-arounds/optimizations at a higher level than usual.
+
+   v1.0 - Mark Vojkovich (mvojkovi@ucsd.edu)
+
+********************************************************************/
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include <X11/fonts/font.h>
+#include "scrnintstr.h"
+#include "dixfontstr.h"
+#include "xf86str.h"
+#include "xaa.h"
+#include "xaalocal.h"
+#include "gcstruct.h"
+#include "pixmapstr.h"
+
+static void XAAGlyphBltTEColorExpansion(ScrnInfoPtr pScrn, int xInit,
+                                        int yInit, FontPtr font, int fg, int bg,
+                                        int rop, unsigned int planemask,
+                                        RegionPtr cclip, int nglyph,
+                                        unsigned char *gBase,
+                                        CharInfoPtr * ppci);
+
+/********************************************************************
+
+   GC level replacements for PolyText8/16 and ImageText8/16
+   for TE fonts when using color expansion.
+
+********************************************************************/
+
+int
+XAAPolyText8TEColorExpansion(DrawablePtr pDraw,
+                             GCPtr pGC, int x, int y, int count, char *chars)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    unsigned long n;
+
+    (*pGC->font->get_glyphs) (pGC->font, (unsigned long) count,
+                              (unsigned char *) chars, Linear8Bit, &n,
+                              infoRec->CharInfo);
+
+    /* we have divorced XAAGlyphBltTEColorExpansion from the drawable */
+    if (n)
+        XAAGlyphBltTEColorExpansion(infoRec->pScrn, x + pDraw->x, y + pDraw->y,
+                                    pGC->font, pGC->fgPixel, -1, pGC->alu,
+                                    pGC->planemask, pGC->pCompositeClip, n,
+                                    FONTGLYPHS(pGC->font), infoRec->CharInfo);
+
+    return (x + (n * FONTMAXBOUNDS(pGC->font, characterWidth)));
+}
+
+int
+XAAPolyText16TEColorExpansion(DrawablePtr pDraw,
+                              GCPtr pGC,
+                              int x, int y, int count, unsigned short *chars)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    unsigned long n;
+
+    (*pGC->font->get_glyphs) (pGC->font, (unsigned long) count,
+                              (unsigned char *) chars,
+                              (FONTLASTROW(pGC->font) ==
+                               0) ? Linear16Bit : TwoD16Bit, &n,
+                              infoRec->CharInfo);
+
+    if (n)
+        XAAGlyphBltTEColorExpansion(infoRec->pScrn, x + pDraw->x, y + pDraw->y,
+                                    pGC->font, pGC->fgPixel, -1, pGC->alu,
+                                    pGC->planemask, pGC->pCompositeClip, n,
+                                    FONTGLYPHS(pGC->font), infoRec->CharInfo);
+
+    return (x + (n * FONTMAXBOUNDS(pGC->font, characterWidth)));
+}
+
+void
+XAAImageText8TEColorExpansion(DrawablePtr pDraw,
+                              GCPtr pGC, int x, int y, int count, char *chars)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    unsigned long n;
+
+    if (!RegionNumRects(pGC->pCompositeClip))
+        return;
+
+    (*pGC->font->get_glyphs) (pGC->font, (unsigned long) count,
+                              (unsigned char *) chars, Linear8Bit, &n,
+                              infoRec->CharInfo);
+
+    if (n)
+        XAAGlyphBltTEColorExpansion(infoRec->pScrn, x + pDraw->x, y + pDraw->y,
+                                    pGC->font, pGC->fgPixel, pGC->bgPixel,
+                                    GXcopy, pGC->planemask, pGC->pCompositeClip,
+                                    n, FONTGLYPHS(pGC->font),
+                                    infoRec->CharInfo);
+}
+
+void
+XAAImageText16TEColorExpansion(DrawablePtr pDraw,
+                               GCPtr pGC,
+                               int x, int y, int count, unsigned short *chars)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    unsigned long n;
+
+    if (!RegionNumRects(pGC->pCompositeClip))
+        return;
+
+    (*pGC->font->get_glyphs) (pGC->font, (unsigned long) count,
+                              (unsigned char *) chars,
+                              (FONTLASTROW(pGC->font) ==
+                               0) ? Linear16Bit : TwoD16Bit, &n,
+                              infoRec->CharInfo);
+
+    if (n)
+        XAAGlyphBltTEColorExpansion(infoRec->pScrn, x + pDraw->x, y + pDraw->y,
+                                    pGC->font, pGC->fgPixel, pGC->bgPixel,
+                                    GXcopy, pGC->planemask, pGC->pCompositeClip,
+                                    n, FONTGLYPHS(pGC->font),
+                                    infoRec->CharInfo);
+}
+
+/********************************************************************
+
+   GC level replacements for ImageGlyphBlt and PolyGlyphBlt for
+   TE fonts when using color expansion.
+
+********************************************************************/
+
+void
+XAAImageGlyphBltTEColorExpansion(DrawablePtr pDrawable,
+                                 GCPtr pGC,
+                                 int xInit, int yInit,
+                                 unsigned int nglyph,
+                                 CharInfoPtr * ppci, void *pglyphBase)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+
+    if (!RegionNumRects(pGC->pCompositeClip))
+        return;
+
+    XAAGlyphBltTEColorExpansion(infoRec->pScrn, xInit + pDrawable->x,
+                                yInit + pDrawable->y, pGC->font, pGC->fgPixel,
+                                pGC->bgPixel, GXcopy, pGC->planemask,
+                                pGC->pCompositeClip, nglyph,
+                                (unsigned char *) pglyphBase, ppci);
+}
+
+void
+XAAPolyGlyphBltTEColorExpansion(DrawablePtr pDrawable,
+                                GCPtr pGC,
+                                int xInit, int yInit,
+                                unsigned int nglyph,
+                                CharInfoPtr * ppci, void *pglyphBase)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+
+    if (!RegionNumRects(pGC->pCompositeClip))
+        return;
+
+    XAAGlyphBltTEColorExpansion(infoRec->pScrn, xInit + pDrawable->x,
+                                yInit + pDrawable->y, pGC->font, pGC->fgPixel,
+                                -1, pGC->alu, pGC->planemask,
+                                pGC->pCompositeClip, nglyph,
+                                (unsigned char *) pglyphBase, ppci);
+}
+
+/********************************************************************
+
+   XAAGlyphBltTEColorExpansion -
+
+   This guy computes the clipped pieces of text and sends it to
+   the lower-level function which will handle acceleration of 
+   arbitrarily clipped text.
+  
+********************************************************************/
+
+static void
+XAAGlyphBltTEColorExpansion(ScrnInfoPtr pScrn,
+                            int xInit, int yInit,
+                            FontPtr font,
+                            int fg, int bg,
+                            int rop,
+                            unsigned int planemask,
+                            RegionPtr cclip,
+                            int nglyph,
+                            unsigned char *gBase, CharInfoPtr * ppci)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    int skippix, skipglyphs;
+    int Left, Right, Top, Bottom;
+    int LeftEdge, RightEdge, ytop, ybot;
+    int nbox = RegionNumRects(cclip);
+    BoxPtr pbox = RegionRects(cclip);
+    unsigned int **glyphs = NULL;
+    int glyphWidth = FONTMAXBOUNDS(font, characterWidth);
+
+    /* find the size of the box */
+    Left = xInit;
+    Right = Left + (glyphWidth * nglyph);
+    Top = yInit - FONTASCENT(font);
+    Bottom = yInit + FONTDESCENT(font);
+
+    /* get into the first band that may contain part of our string */
+    while (nbox && (Top >= pbox->y2)) {
+        pbox++;
+        nbox--;
+    }
+
+    /* stop when the lower edge of the box is beyond our string */
+    while (nbox && (Bottom > pbox->y1)) {
+        LeftEdge = max(Left, pbox->x1);
+        RightEdge = min(Right, pbox->x2);
+
+        if (RightEdge > LeftEdge) {     /* we have something to draw */
+            unsigned int *fallbackBits = NULL;
+
+            ytop = max(Top, pbox->y1);
+            ybot = min(Bottom, pbox->y2);
+
+            if ((skippix = LeftEdge - Left)) {
+                skipglyphs = skippix / glyphWidth;
+                skippix %= glyphWidth;
+            }
+            else
+                skipglyphs = 0;
+
+            if (!glyphs) {
+                int count;
+
+                glyphs = (unsigned int **) (infoRec->PreAllocMem);
+
+                for (count = 0; count < nglyph; count++) {
+                    glyphs[count] = (unsigned int *)
+                        FONTGLYPHBITS(gBase, *ppci++);
+                    if (!glyphs[count]) {
+                        /* Glyphs with NULL bits do exist in the wild.
+                           Replace with blank bits in that case */
+
+                        if (!fallbackBits) {
+                            int fontHeight = Bottom - Top + 1;
+
+                            fallbackBits = calloc(glyphWidth * fontHeight, 1);
+                            if (!fallbackBits)
+                                return;
+                        }
+                        glyphs[count] = fallbackBits;
+                    }
+                }
+
+                /* our new unrolled TE code only writes DWORDS at a time 
+                   so it can read up to 6 characters past the last one 
+                   we're displaying */
+                glyphs[count + 0] = glyphs[0];
+                glyphs[count + 1] = glyphs[0];
+                glyphs[count + 2] = glyphs[0];
+                glyphs[count + 3] = glyphs[0];
+                glyphs[count + 4] = glyphs[0];
+                glyphs[count + 5] = glyphs[0];
+            }
+
+            /* x, y, w, h, skipleft, skiptop, glyphp, glyphWidth, fg, bg, rop, pm */
+
+            (*infoRec->TEGlyphRenderer) (pScrn,
+                                         LeftEdge, ytop, RightEdge - LeftEdge,
+                                         ybot - ytop, skippix, ytop - Top,
+                                         glyphs + skipglyphs, glyphWidth, fg,
+                                         bg, rop, planemask);
+
+            free(fallbackBits);
+        }
+
+        nbox--;
+        pbox++;
+    }
+}
diff --git a/hw/xfree86/xaa/xaaTables.c b/hw/xfree86/xaa/xaaTables.c
new file mode 100644
index 000000000..35641da59
--- /dev/null
+++ b/hw/xfree86/xaa/xaaTables.c
@@ -0,0 +1,152 @@
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+#include "xaalocal.h"
+/*
+ * This is a table of 24-bit values, indexed with an 8-bit byte value, then
+ * expands each bit to three consecutive bits. This is required for color
+ * expansion in 24bpp mode with the coprocessor in 8bpp mode, with LSB-first
+ * bit order within a byte.
+ */
+
+unsigned int byte_expand3[256] = {
+    0x000000, 0x000007, 0x000038, 0x00003F, 0x0001C0, 0x0001C7, 0x0001F8,
+        0x0001FF,
+    0x000E00, 0x000E07, 0x000E38, 0x000E3F, 0x000FC0, 0x000FC7, 0x000FF8,
+        0x000FFF,
+    0x007000, 0x007007, 0x007038, 0x00703F, 0x0071C0, 0x0071C7, 0x0071F8,
+        0x0071FF,
+    0x007E00, 0x007E07, 0x007E38, 0x007E3F, 0x007FC0, 0x007FC7, 0x007FF8,
+        0x007FFF,
+    0x038000, 0x038007, 0x038038, 0x03803F, 0x0381C0, 0x0381C7, 0x0381F8,
+        0x0381FF,
+    0x038E00, 0x038E07, 0x038E38, 0x038E3F, 0x038FC0, 0x038FC7, 0x038FF8,
+        0x038FFF,
+    0x03F000, 0x03F007, 0x03F038, 0x03F03F, 0x03F1C0, 0x03F1C7, 0x03F1F8,
+        0x03F1FF,
+    0x03FE00, 0x03FE07, 0x03FE38, 0x03FE3F, 0x03FFC0, 0x03FFC7, 0x03FFF8,
+        0x03FFFF,
+    0x1C0000, 0x1C0007, 0x1C0038, 0x1C003F, 0x1C01C0, 0x1C01C7, 0x1C01F8,
+        0x1C01FF,
+    0x1C0E00, 0x1C0E07, 0x1C0E38, 0x1C0E3F, 0x1C0FC0, 0x1C0FC7, 0x1C0FF8,
+        0x1C0FFF,
+    0x1C7000, 0x1C7007, 0x1C7038, 0x1C703F, 0x1C71C0, 0x1C71C7, 0x1C71F8,
+        0x1C71FF,
+    0x1C7E00, 0x1C7E07, 0x1C7E38, 0x1C7E3F, 0x1C7FC0, 0x1C7FC7, 0x1C7FF8,
+        0x1C7FFF,
+    0x1F8000, 0x1F8007, 0x1F8038, 0x1F803F, 0x1F81C0, 0x1F81C7, 0x1F81F8,
+        0x1F81FF,
+    0x1F8E00, 0x1F8E07, 0x1F8E38, 0x1F8E3F, 0x1F8FC0, 0x1F8FC7, 0x1F8FF8,
+        0x1F8FFF,
+    0x1FF000, 0x1FF007, 0x1FF038, 0x1FF03F, 0x1FF1C0, 0x1FF1C7, 0x1FF1F8,
+        0x1FF1FF,
+    0x1FFE00, 0x1FFE07, 0x1FFE38, 0x1FFE3F, 0x1FFFC0, 0x1FFFC7, 0x1FFFF8,
+        0x1FFFFF,
+    0xE00000, 0xE00007, 0xE00038, 0xE0003F, 0xE001C0, 0xE001C7, 0xE001F8,
+        0xE001FF,
+    0xE00E00, 0xE00E07, 0xE00E38, 0xE00E3F, 0xE00FC0, 0xE00FC7, 0xE00FF8,
+        0xE00FFF,
+    0xE07000, 0xE07007, 0xE07038, 0xE0703F, 0xE071C0, 0xE071C7, 0xE071F8,
+        0xE071FF,
+    0xE07E00, 0xE07E07, 0xE07E38, 0xE07E3F, 0xE07FC0, 0xE07FC7, 0xE07FF8,
+        0xE07FFF,
+    0xE38000, 0xE38007, 0xE38038, 0xE3803F, 0xE381C0, 0xE381C7, 0xE381F8,
+        0xE381FF,
+    0xE38E00, 0xE38E07, 0xE38E38, 0xE38E3F, 0xE38FC0, 0xE38FC7, 0xE38FF8,
+        0xE38FFF,
+    0xE3F000, 0xE3F007, 0xE3F038, 0xE3F03F, 0xE3F1C0, 0xE3F1C7, 0xE3F1F8,
+        0xE3F1FF,
+    0xE3FE00, 0xE3FE07, 0xE3FE38, 0xE3FE3F, 0xE3FFC0, 0xE3FFC7, 0xE3FFF8,
+        0xE3FFFF,
+    0xFC0000, 0xFC0007, 0xFC0038, 0xFC003F, 0xFC01C0, 0xFC01C7, 0xFC01F8,
+        0xFC01FF,
+    0xFC0E00, 0xFC0E07, 0xFC0E38, 0xFC0E3F, 0xFC0FC0, 0xFC0FC7, 0xFC0FF8,
+        0xFC0FFF,
+    0xFC7000, 0xFC7007, 0xFC7038, 0xFC703F, 0xFC71C0, 0xFC71C7, 0xFC71F8,
+        0xFC71FF,
+    0xFC7E00, 0xFC7E07, 0xFC7E38, 0xFC7E3F, 0xFC7FC0, 0xFC7FC7, 0xFC7FF8,
+        0xFC7FFF,
+    0xFF8000, 0xFF8007, 0xFF8038, 0xFF803F, 0xFF81C0, 0xFF81C7, 0xFF81F8,
+        0xFF81FF,
+    0xFF8E00, 0xFF8E07, 0xFF8E38, 0xFF8E3F, 0xFF8FC0, 0xFF8FC7, 0xFF8FF8,
+        0xFF8FFF,
+    0xFFF000, 0xFFF007, 0xFFF038, 0xFFF03F, 0xFFF1C0, 0xFFF1C7, 0xFFF1F8,
+        0xFFF1FF,
+    0xFFFE00, 0xFFFE07, 0xFFFE38, 0xFFFE3F, 0xFFFFC0, 0xFFFFC7, 0xFFFFF8,
+        0xFFFFFF
+};
+
+/*
+ * This is a table of 24-bit values, indexed with an 8-bit byte value,
+ * that reverses the bit order of a byte and then expands each bit to three
+ * consecutive bits. This is required for color expansion in 24bpp mode
+ * with the coprocessor in 8bpp mode, with MSB-first bit order within a
+ * byte.
+ */
+
+unsigned int byte_reversed_expand3[256] = {
+    0x000000, 0x0000E0, 0x00001C, 0x0000FC, 0x008003, 0x0080E3, 0x00801F,
+        0x0080FF,
+    0x007000, 0x0070E0, 0x00701C, 0x0070FC, 0x00F003, 0x00F0E3, 0x00F01F,
+        0x00F0FF,
+    0x000E00, 0x000EE0, 0x000E1C, 0x000EFC, 0x008E03, 0x008EE3, 0x008E1F,
+        0x008EFF,
+    0x007E00, 0x007EE0, 0x007E1C, 0x007EFC, 0x00FE03, 0x00FEE3, 0x00FE1F,
+        0x00FEFF,
+    0xC00100, 0xC001E0, 0xC0011C, 0xC001FC, 0xC08103, 0xC081E3, 0xC0811F,
+        0xC081FF,
+    0xC07100, 0xC071E0, 0xC0711C, 0xC071FC, 0xC0F103, 0xC0F1E3, 0xC0F11F,
+        0xC0F1FF,
+    0xC00F00, 0xC00FE0, 0xC00F1C, 0xC00FFC, 0xC08F03, 0xC08FE3, 0xC08F1F,
+        0xC08FFF,
+    0xC07F00, 0xC07FE0, 0xC07F1C, 0xC07FFC, 0xC0FF03, 0xC0FFE3, 0xC0FF1F,
+        0xC0FFFF,
+    0x380000, 0x3800E0, 0x38001C, 0x3800FC, 0x388003, 0x3880E3, 0x38801F,
+        0x3880FF,
+    0x387000, 0x3870E0, 0x38701C, 0x3870FC, 0x38F003, 0x38F0E3, 0x38F01F,
+        0x38F0FF,
+    0x380E00, 0x380EE0, 0x380E1C, 0x380EFC, 0x388E03, 0x388EE3, 0x388E1F,
+        0x388EFF,
+    0x387E00, 0x387EE0, 0x387E1C, 0x387EFC, 0x38FE03, 0x38FEE3, 0x38FE1F,
+        0x38FEFF,
+    0xF80100, 0xF801E0, 0xF8011C, 0xF801FC, 0xF88103, 0xF881E3, 0xF8811F,
+        0xF881FF,
+    0xF87100, 0xF871E0, 0xF8711C, 0xF871FC, 0xF8F103, 0xF8F1E3, 0xF8F11F,
+        0xF8F1FF,
+    0xF80F00, 0xF80FE0, 0xF80F1C, 0xF80FFC, 0xF88F03, 0xF88FE3, 0xF88F1F,
+        0xF88FFF,
+    0xF87F00, 0xF87FE0, 0xF87F1C, 0xF87FFC, 0xF8FF03, 0xF8FFE3, 0xF8FF1F,
+        0xF8FFFF,
+    0x070000, 0x0700E0, 0x07001C, 0x0700FC, 0x078003, 0x0780E3, 0x07801F,
+        0x0780FF,
+    0x077000, 0x0770E0, 0x07701C, 0x0770FC, 0x07F003, 0x07F0E3, 0x07F01F,
+        0x07F0FF,
+    0x070E00, 0x070EE0, 0x070E1C, 0x070EFC, 0x078E03, 0x078EE3, 0x078E1F,
+        0x078EFF,
+    0x077E00, 0x077EE0, 0x077E1C, 0x077EFC, 0x07FE03, 0x07FEE3, 0x07FE1F,
+        0x07FEFF,
+    0xC70100, 0xC701E0, 0xC7011C, 0xC701FC, 0xC78103, 0xC781E3, 0xC7811F,
+        0xC781FF,
+    0xC77100, 0xC771E0, 0xC7711C, 0xC771FC, 0xC7F103, 0xC7F1E3, 0xC7F11F,
+        0xC7F1FF,
+    0xC70F00, 0xC70FE0, 0xC70F1C, 0xC70FFC, 0xC78F03, 0xC78FE3, 0xC78F1F,
+        0xC78FFF,
+    0xC77F00, 0xC77FE0, 0xC77F1C, 0xC77FFC, 0xC7FF03, 0xC7FFE3, 0xC7FF1F,
+        0xC7FFFF,
+    0x3F0000, 0x3F00E0, 0x3F001C, 0x3F00FC, 0x3F8003, 0x3F80E3, 0x3F801F,
+        0x3F80FF,
+    0x3F7000, 0x3F70E0, 0x3F701C, 0x3F70FC, 0x3FF003, 0x3FF0E3, 0x3FF01F,
+        0x3FF0FF,
+    0x3F0E00, 0x3F0EE0, 0x3F0E1C, 0x3F0EFC, 0x3F8E03, 0x3F8EE3, 0x3F8E1F,
+        0x3F8EFF,
+    0x3F7E00, 0x3F7EE0, 0x3F7E1C, 0x3F7EFC, 0x3FFE03, 0x3FFEE3, 0x3FFE1F,
+        0x3FFEFF,
+    0xFF0100, 0xFF01E0, 0xFF011C, 0xFF01FC, 0xFF8103, 0xFF81E3, 0xFF811F,
+        0xFF81FF,
+    0xFF7100, 0xFF71E0, 0xFF711C, 0xFF71FC, 0xFFF103, 0xFFF1E3, 0xFFF11F,
+        0xFFF1FF,
+    0xFF0F00, 0xFF0FE0, 0xFF0F1C, 0xFF0FFC, 0xFF8F03, 0xFF8FE3, 0xFF8F1F,
+        0xFF8FFF,
+    0xFF7F00, 0xFF7FE0, 0xFF7F1C, 0xFF7FFC, 0xFFFF03, 0xFFFFE3, 0xFFFF1F,
+        0xFFFFFF,
+};
diff --git a/hw/xfree86/xaa/xaaWideLine.c b/hw/xfree86/xaa/xaaWideLine.c
new file mode 100644
index 000000000..b8a53c1c8
--- /dev/null
+++ b/hw/xfree86/xaa/xaaWideLine.c
@@ -0,0 +1,924 @@
+/*
+
+XAAPolylinesWideSolid does not maintain a span list and subsequently does
+not follow the "touch-each-pixel-once" rules for wide lines and arcs.
+This means it can only be used in the case where we have
+miSpansEasyRop(pGC->alu).  Since we clip spans on the fly, we
+limited usage of this function to one rect situations. This
+function is used only for solid lines. 
+
+  Adapted from miWideLine by Mark Vojkovich (mvojkovi@ucsd.edu)
+Original mi code written by Keith Packard.
+
+*/
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <math.h>
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include <X11/X.h>
+#include "windowstr.h"
+#include "gcstruct.h"
+#include "regionstr.h"
+#include "miwideline.h"
+#include "mi.h"
+#include "xf86str.h"
+#include "xaa.h"
+#include "xaalocal.h"
+
+#define DRAW_POINT(pScrn, x, y) \
+  if(hardClip) (*infoRec->SubsequentSolidFillRect)(pScrn, x, y, 1, 1); \
+  else XAAPointHelper(pScrn, x, y)
+
+#define FILL_RECT(pScrn, x, y, w, h) \
+  if(hardClip) (*infoRec->SubsequentSolidFillRect)(pScrn, x, y, w, h); \
+  else XAAFillRectHelper(pScrn, x, y, w, h)
+
+#define FILL_SPAN(pScrn, x, y, w) \
+  if(hardClip) (*infoRec->SubsequentSolidFillRect)(pScrn, x, y, w, 1); \
+  else XAASpanHelper(pScrn, x, y, w)
+
+#define CLIPSTEPEDGE(edgey,edge,edgeleft) \
+    if (ybase == edgey) { \
+	if (edgeleft) { \
+	    if (edge->x > xcl) \
+		xcl = edge->x; \
+	} else { \
+	    if (edge->x < xcr) \
+		xcr = edge->x; \
+	} \
+	edgey++; \
+	edge->x += edge->stepx; \
+	edge->e += edge->dx; \
+	if (edge->e > 0) { \
+	    edge->x += edge->signdx; \
+	    edge->e -= edge->dy; \
+	} \
+    }
+
+static void
+XAAPointHelper(ScrnInfoPtr pScrn, int x, int y)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    BoxPtr extents = infoRec->ClipBox;
+
+    if ((x >= extents->x1) && (x < extents->x2) &&
+        (y >= extents->y1) && (y < extents->y2))
+        (*infoRec->SubsequentSolidFillRect) (pScrn, x, y, 1, 1);
+}
+
+static void
+XAAFillRectHelper(ScrnInfoPtr pScrn, int x1, int y1, int dx, int dy)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    BoxPtr extents = infoRec->ClipBox;
+    int x2 = x1 + dx;
+    int y2 = y1 + dy;
+
+    if (x1 < extents->x1)
+        x1 = extents->x1;
+    if (x2 >= extents->x2)
+        x2 = extents->x2;
+    if ((dx = x2 - x1) < 1)
+        return;
+    if (y1 < extents->y1)
+        y1 = extents->y1;
+    if (y2 >= extents->y2)
+        y2 = extents->y2;
+    if ((dy = y2 - y1) < 1)
+        return;
+
+    (*infoRec->SubsequentSolidFillRect) (pScrn, x1, y1, dx, dy);
+}
+
+static void
+XAASpanHelper(ScrnInfoPtr pScrn, int x1, int y, int width)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn);
+    BoxPtr extents = infoRec->ClipBox;
+    int x2;
+
+    if ((y < extents->y1) || (y >= extents->y2))
+        return;
+
+    x2 = x1 + width;
+    if (x1 < extents->x1)
+        x1 = extents->x1;
+    if (x2 > extents->x2)
+        x2 = extents->x2;
+    width = x2 - x1;
+
+    if (width > 0)
+        (*infoRec->SubsequentSolidFillRect) (pScrn, x1, y, width, 1);
+
+}
+
+#define FixError(x, dx, dy, e, sign, step, h)	{	\
+	   e += (h) * dx;				\
+	   x += (h) * step;				\
+	   if(e > 0) {					\
+		x += e * sign/dy;			\
+		e %= dy;				\
+	   	if(e) {					\
+		   x += sign;				\
+		   e -= dy;				\
+		}					\
+	   } 	 					\
+}
+
+static void
+XAAFillPolyHelper(GCPtr pGC, int y,     /* start y coordinate */
+                  int overall_height,   /* height of entire segment */
+                  PolyEdgePtr left, PolyEdgePtr right,
+                  int left_count, int right_count)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    BoxPtr extents = infoRec->ClipBox;
+    int left_x, left_e, left_stepx, left_signdx, left_dy, left_dx;
+    int right_x, right_e, right_stepx, right_signdx, right_dy, right_dx;
+    int height, left_height, right_height;
+    int xorg;
+    Bool hardClip;
+
+    if ((y >= extents->y2) || ((y + overall_height) <= extents->y1))
+        return;
+
+    /* Muffle compiler */
+    left_x = left_e = left_stepx = left_signdx = left_dy = left_dx = 0;
+    right_x = right_e = right_stepx = right_signdx = right_dy = right_dx = 0;
+
+    left_height = right_height = 0;
+    xorg = 0;
+
+    hardClip = (infoRec->ClippingFlags & HARDWARE_CLIP_SOLID_FILL);
+
+    while ((left_count || left_height) && (right_count || right_height)) {
+        if (!left_height && left_count) {
+            left_height = left->height;
+            left_x = left->x + xorg;
+            left_stepx = left->stepx;
+            left_signdx = left->signdx;
+            left_e = left->e;
+            left_dy = left->dy;
+            left_dx = left->dx;
+            left_count--;
+            left++;
+        }
+        if (!right_height && right_count) {
+            right_height = right->height;
+            right_x = right->x + xorg + 1;
+            right_stepx = right->stepx;
+            right_signdx = right->signdx;
+            right_e = right->e;
+            right_dy = right->dy;
+            right_dx = right->dx;
+            right_count--;
+            right++;
+        }
+
+        height = (left_height > right_height) ? right_height : left_height;
+
+        left_height -= height;
+        right_height -= height;
+
+        if (hardClip && infoRec->SubsequentSolidFillTrap && (height > 6)) {
+            int right_DX, left_DX;
+
+            right_DX = (right_dx * right_signdx) + (right_stepx * right_dy);
+            left_DX = (left_dx * left_signdx) + (left_stepx * left_dy);
+
+            (*infoRec->SubsequentSolidFillTrap) (infoRec->pScrn, y, height,
+                                                 left_x, left_DX, left_dy,
+                                                 left_e, right_x - 1, right_DX,
+                                                 right_dy, right_e);
+
+            FixError(left_x, left_dx, left_dy, left_e, left_signdx,
+                     left_stepx, height);
+            FixError(right_x, right_dx, right_dy, right_e, right_signdx,
+                     right_stepx, height);
+            y += height;
+            continue;
+        }
+
+        while (height--) {
+            if (right_x > left_x) {
+                FILL_SPAN(infoRec->pScrn, left_x, y, right_x - left_x);
+            }
+            y++;
+
+            left_x += left_stepx;
+            left_e += left_dx;
+            if (left_e > 0) {
+                left_x += left_signdx;
+                left_e -= left_dy;
+            }
+            right_x += right_stepx;
+            right_e += right_dx;
+            if (right_e > 0) {
+                right_x += right_signdx;
+                right_e -= right_dy;
+            }
+
+        }
+    }
+}
+
+static void
+XAAWideSegment(GCPtr pGC,
+               int x1, int y1, int x2, int y2,
+               Bool projectLeft, Bool projectRight,
+               LineFacePtr leftFace, LineFacePtr rightFace)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    double l, L, r;
+    double xa, ya;
+    double projectXoff, projectYoff;
+    double k;
+    double maxy;
+    int x, y;
+    int dx, dy;
+    int finaly;
+    PolyEdgePtr left, right;
+    PolyEdgePtr top, bottom;
+    int lefty, righty, topy, bottomy;
+    int signdx;
+    PolyEdgeRec lefts[2], rights[2];
+    LineFacePtr tface;
+    int lw = pGC->lineWidth;
+    Bool hardClip = (infoRec->ClippingFlags & HARDWARE_CLIP_SOLID_FILL);
+
+    /* draw top-to-bottom always */
+    if ((y2 < y1) || ((y2 == y1) && (x2 < x1))) {
+        x = x1;
+        x1 = x2;
+        x2 = x;
+
+        y = y1;
+        y1 = y2;
+        y2 = y;
+
+        x = projectLeft;
+        projectLeft = projectRight;
+        projectRight = x;
+
+        tface = leftFace;
+        leftFace = rightFace;
+        rightFace = tface;
+    }
+
+    dy = y2 - y1;
+    signdx = 1;
+    dx = x2 - x1;
+    if (dx < 0)
+        signdx = -1;
+
+    leftFace->x = x1;
+    leftFace->y = y1;
+    leftFace->dx = dx;
+    leftFace->dy = dy;
+
+    rightFace->x = x2;
+    rightFace->y = y2;
+    rightFace->dx = -dx;
+    rightFace->dy = -dy;
+
+    if (!dy) {
+        rightFace->xa = 0;
+        rightFace->ya = (double) lw / 2.0;
+        rightFace->k = -(double) (lw * dx) / 2.0;
+        leftFace->xa = 0;
+        leftFace->ya = -rightFace->ya;
+        leftFace->k = rightFace->k;
+        x = x1;
+        if (projectLeft)
+            x -= (lw >> 1);
+        y = y1 - (lw >> 1);
+        dx = x2 - x;
+        if (projectRight)
+            dx += ((lw + 1) >> 1);
+        dy = lw;
+        FILL_RECT(infoRec->pScrn, x, y, dx, dy);
+    }
+    else if (!dx) {
+        leftFace->xa = (double) lw / 2.0;
+        leftFace->ya = 0;
+        leftFace->k = (double) (lw * dy) / 2.0;
+        rightFace->xa = -leftFace->xa;
+        rightFace->ya = 0;
+        rightFace->k = leftFace->k;
+        y = y1;
+        if (projectLeft)
+            y -= lw >> 1;
+        x = x1 - (lw >> 1);
+        dy = y2 - y;
+        if (projectRight)
+            dy += ((lw + 1) >> 1);
+        dx = lw;
+        FILL_RECT(infoRec->pScrn, x, y, dx, dy);
+    }
+    else {
+        l = ((double) lw) / 2.0;
+        L = sqrt((double) (dx * dx + dy * dy));
+
+        if (dx < 0) {
+            right = &rights[1];
+            left = &lefts[0];
+            top = &rights[0];
+            bottom = &lefts[1];
+        }
+        else {
+            right = &rights[0];
+            left = &lefts[1];
+            top = &lefts[0];
+            bottom = &rights[1];
+        }
+        r = l / L;
+
+        /* coord of upper bound at integral y */
+        ya = -r * dx;
+        xa = r * dy;
+
+        projectXoff = -ya;
+        projectYoff = xa;
+
+        /* xa * dy - ya * dx */
+        k = l * L;
+
+        leftFace->xa = xa;
+        leftFace->ya = ya;
+        leftFace->k = k;
+        rightFace->xa = -xa;
+        rightFace->ya = -ya;
+        rightFace->k = k;
+
+        if (projectLeft)
+            righty = miPolyBuildEdge(xa - projectXoff, ya - projectYoff,
+                                     k, dx, dy, x1, y1, 0, right);
+        else
+            righty = miPolyBuildEdge(xa, ya, k, dx, dy, x1, y1, 0, right);
+
+        /* coord of lower bound at integral y */
+        ya = -ya;
+        xa = -xa;
+
+        /* xa * dy - ya * dx */
+        k = -k;
+
+        if (projectLeft)
+            lefty = miPolyBuildEdge(xa - projectXoff, ya - projectYoff,
+                                    k, dx, dy, x1, y1, 1, left);
+        else
+            lefty = miPolyBuildEdge(xa, ya, k, dx, dy, x1, y1, 1, left);
+
+        /* coord of top face at integral y */
+
+        if (signdx > 0) {
+            ya = -ya;
+            xa = -xa;
+        }
+
+        if (projectLeft) {
+            double xap = xa - projectXoff;
+            double yap = ya - projectYoff;
+
+            topy = miPolyBuildEdge(xap, yap, xap * dx + yap * dy,
+                                   -dy, dx, x1, y1, dx > 0, top);
+        }
+        else
+            topy = miPolyBuildEdge(xa, ya, 0.0, -dy, dx, x1, y1, dx > 0, top);
+
+        /* coord of bottom face at integral y */
+
+        if (projectRight) {
+            double xap = xa + projectXoff;
+            double yap = ya + projectYoff;
+
+            bottomy = miPolyBuildEdge(xap, yap, xap * dx + yap * dy,
+                                      -dy, dx, x2, y2, dx < 0, bottom);
+            maxy = -ya + projectYoff;
+        }
+        else {
+            bottomy = miPolyBuildEdge(xa, ya, 0.0,
+                                      -dy, dx, x2, y2, dx < 0, bottom);
+            maxy = -ya;
+        }
+
+        finaly = ICEIL(maxy) + y2;
+
+        if (dx < 0) {
+            left->height = bottomy - lefty;
+            right->height = finaly - righty;
+            top->height = righty - topy;
+        }
+        else {
+            right->height = bottomy - righty;
+            left->height = finaly - lefty;
+            top->height = lefty - topy;
+        }
+        bottom->height = finaly - bottomy;
+        XAAFillPolyHelper(pGC, topy,
+                          bottom->height + bottomy - topy, lefts, rights, 2, 2);
+    }
+}
+
+static void
+XAALineArcI(GCPtr pGC, int xorg, int yorg)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    int x, y, e, ex;
+    int slw = pGC->lineWidth;
+    Bool hardClip = (infoRec->ClippingFlags & HARDWARE_CLIP_SOLID_FILL);
+
+    y = (slw >> 1) + 1;
+    if (slw & 1)
+        e = -((y << 2) + 3);
+    else
+        e = -(y << 3);
+    ex = -4;
+    x = 0;
+    while (y) {
+        e += (y << 3) - 4;
+        while (e >= 0) {
+            x++;
+            e += (ex = -((x << 3) + 4));
+        }
+        y--;
+        slw = (x << 1) + 1;
+        if ((e == ex) && (slw > 1))
+            slw--;
+
+        FILL_SPAN(infoRec->pScrn, xorg - x, yorg - y, slw);
+
+        if ((y != 0) && ((slw > 1) || (e != ex))) {
+            FILL_SPAN(infoRec->pScrn, xorg - x, yorg + y, slw);
+        }
+    }
+}
+
+static void
+XAALineArcD(GCPtr pGC,
+            double xorg,
+            double yorg,
+            PolyEdgePtr edge1,
+            int edgey1,
+            Bool edgeleft1, PolyEdgePtr edge2, int edgey2, Bool edgeleft2)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    double radius, x0, y0, el, er, yk, xlk, xrk, k;
+    int xbase, ybase, y, boty, xl, xr, xcl, xcr;
+    int ymin, ymax;
+    Bool edge1IsMin, edge2IsMin;
+    int ymin1, ymin2;
+    Bool hardClip = (infoRec->ClippingFlags & HARDWARE_CLIP_SOLID_FILL);
+
+    xbase = floor(xorg);
+    x0 = xorg - xbase;
+    ybase = ICEIL(yorg);
+    y0 = yorg - ybase;
+
+    xlk = x0 + x0 + 1.0;
+    xrk = x0 + x0 - 1.0;
+    yk = y0 + y0 - 1.0;
+    radius = ((double) pGC->lineWidth) / 2.0;
+    y = floor(radius - y0 + 1.0);
+    ybase -= y;
+    ymin = ybase;
+    ymax = 65536;
+    edge1IsMin = FALSE;
+    ymin1 = edgey1;
+    if (edge1->dy >= 0) {
+        if (!edge1->dy) {
+            if (edgeleft1)
+                edge1IsMin = TRUE;
+            else
+                ymax = edgey1;
+            edgey1 = 65536;
+        }
+        else if ((edge1->signdx < 0) == edgeleft1)
+            edge1IsMin = TRUE;
+    }
+    edge2IsMin = FALSE;
+    ymin2 = edgey2;
+    if (edge2->dy >= 0) {
+        if (!edge2->dy) {
+            if (edgeleft2)
+                edge2IsMin = TRUE;
+            else
+                ymax = edgey2;
+            edgey2 = 65536;
+        }
+        else if ((edge2->signdx < 0) == edgeleft2)
+            edge2IsMin = TRUE;
+    }
+    if (edge1IsMin) {
+        ymin = ymin1;
+        if (edge2IsMin && (ymin1 > ymin2))
+            ymin = ymin2;
+    }
+    else if (edge2IsMin)
+        ymin = ymin2;
+    el = radius * radius - ((y + y0) * (y + y0)) - (x0 * x0);
+    er = el + xrk;
+    xl = 1;
+    xr = 0;
+    if (x0 < 0.5) {
+        xl = 0;
+        el -= xlk;
+    }
+    boty = (y0 < -0.5) ? 1 : 0;
+    if (ybase + y - boty > ymax)
+        boty = ymax - ybase - y;
+    while (y > boty) {
+        k = (y << 1) + yk;
+        er += k;
+        while (er > 0.0) {
+            xr++;
+            er += xrk - (xr << 1);
+        }
+        el += k;
+        while (el >= 0.0) {
+            xl--;
+            el += (xl << 1) - xlk;
+        }
+        y--;
+        ybase++;
+        if (ybase < ymin)
+            continue;
+        xcl = xl + xbase;
+        xcr = xr + xbase;
+        CLIPSTEPEDGE(edgey1, edge1, edgeleft1);
+        CLIPSTEPEDGE(edgey2, edge2, edgeleft2);
+        if (xcr >= xcl) {
+            FILL_SPAN(infoRec->pScrn, xcl, ybase, xcr - xcl + 1);
+        }
+    }
+    er = xrk - (xr << 1) - er;
+    el = (xl << 1) - xlk - el;
+    boty = floor(-y0 - radius + 1.0);
+    if (ybase + y - boty > ymax)
+        boty = ymax - ybase - y;
+    while (y > boty) {
+        k = (y << 1) + yk;
+        er -= k;
+        while ((er >= 0.0) && (xr >= 0)) {
+            xr--;
+            er += xrk - (xr << 1);
+        }
+        el -= k;
+        while ((el > 0.0) && (xl <= 0)) {
+            xl++;
+            el += (xl << 1) - xlk;
+        }
+        y--;
+        ybase++;
+        if (ybase < ymin)
+            continue;
+        xcl = xl + xbase;
+        xcr = xr + xbase;
+        CLIPSTEPEDGE(edgey1, edge1, edgeleft1);
+        CLIPSTEPEDGE(edgey2, edge2, edgeleft2);
+        if (xcr >= xcl) {
+            FILL_SPAN(infoRec->pScrn, xcl, ybase, xcr - xcl + 1);
+        }
+    }
+}
+
+static void
+XAALineArc(GCPtr pGC,
+           LineFacePtr leftFace,
+           LineFacePtr rightFace, double xorg, double yorg, Bool isInt)
+{
+    int xorgi, yorgi;
+    PolyEdgeRec edge1, edge2;
+    int edgey1, edgey2;
+    Bool edgeleft1, edgeleft2;
+
+    if (isInt) {
+        xorgi = leftFace ? leftFace->x : rightFace->x;
+        yorgi = leftFace ? leftFace->y : rightFace->y;
+    }
+    else {                      /* Muffle compiler */
+        xorgi = yorgi = 0;
+    }
+    edgey1 = 65536;
+    edgey2 = 65536;
+    edge1.x = 0;                /* not used, keep memory checkers happy */
+    edge1.dy = -1;
+    edge2.x = 0;                /* not used, keep memory checkers happy */
+    edge2.dy = -1;
+    edgeleft1 = FALSE;
+    edgeleft2 = FALSE;
+
+    if ((pGC->lineWidth > 2) &&
+        ((pGC->capStyle == CapRound && pGC->joinStyle != JoinRound) ||
+         (pGC->joinStyle == JoinRound && pGC->capStyle == CapButt))) {
+        if (isInt) {
+            xorg = (double) xorgi;
+            yorg = (double) yorgi;
+        }
+
+        if (leftFace && rightFace)
+            miRoundJoinClip(leftFace, rightFace, &edge1, &edge2,
+                            &edgey1, &edgey2, &edgeleft1, &edgeleft2);
+        else if (leftFace)
+            edgey1 = miRoundCapClip(leftFace, isInt, &edge1, &edgeleft1);
+        else if (rightFace)
+            edgey2 = miRoundCapClip(rightFace, isInt, &edge2, &edgeleft2);
+
+        isInt = FALSE;
+    }
+
+    if (isInt) {
+        if (pGC->lineWidth == 1) {
+            XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+            Bool hardClip = (infoRec->ClippingFlags & HARDWARE_CLIP_SOLID_FILL);
+
+            DRAW_POINT(infoRec->pScrn, xorgi, yorgi);
+        }
+        else
+            XAALineArcI(pGC, xorgi, yorgi);
+    }
+    else
+        XAALineArcD(pGC, xorg, yorg, &edge1, edgey1, edgeleft1,
+                    &edge2, edgey2, edgeleft2);
+
+}
+
+static void
+XAALineJoin(GCPtr pGC, LineFacePtr pLeft, LineFacePtr pRight)
+{
+    double mx = 0, my = 0;
+    double denom = 0;
+    PolyVertexRec vertices[4];
+    PolySlopeRec slopes[4];
+    int edgecount;
+    PolyEdgeRec left[4], right[4];
+    int nleft, nright;
+    int y, height;
+    int swapslopes;
+    int joinStyle = pGC->joinStyle;
+    int lw = pGC->lineWidth;
+
+    if (lw == 1) {
+        /* Lines going in the same direction have no join */
+        if ((pLeft->dx >= 0) == (pRight->dx <= 0))
+            return;
+        if (joinStyle != JoinRound) {
+            denom = -pLeft->dx * (double) pRight->dy + pRight->dx *
+                (double) pLeft->dy;
+            if (denom == 0.0)
+                return;         /* no join to draw */
+        }
+        if (joinStyle != JoinMiter) {
+            XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+            Bool hardClip = (infoRec->ClippingFlags & HARDWARE_CLIP_SOLID_FILL);
+
+            DRAW_POINT(infoRec->pScrn, pLeft->x, pLeft->y);
+            return;
+        }
+    }
+    else {
+        if (joinStyle == JoinRound) {
+            XAALineArc(pGC, pLeft, pRight, (double) 0.0, (double) 0.0, TRUE);
+            return;
+        }
+        denom = -pLeft->dx * (double) pRight->dy + pRight->dx *
+            (double) pLeft->dy;
+        if (denom == 0.0)
+            return;             /* no join to draw */
+    }
+
+    swapslopes = 0;
+    if (denom > 0) {
+        pLeft->xa = -pLeft->xa;
+        pLeft->ya = -pLeft->ya;
+        pLeft->dx = -pLeft->dx;
+        pLeft->dy = -pLeft->dy;
+    }
+    else {
+        swapslopes = 1;
+        pRight->xa = -pRight->xa;
+        pRight->ya = -pRight->ya;
+        pRight->dx = -pRight->dx;
+        pRight->dy = -pRight->dy;
+    }
+
+    vertices[0].x = pRight->xa;
+    vertices[0].y = pRight->ya;
+    slopes[0].dx = -pRight->dy;
+    slopes[0].dy = pRight->dx;
+    slopes[0].k = 0;
+
+    vertices[1].x = 0;
+    vertices[1].y = 0;
+    slopes[1].dx = pLeft->dy;
+    slopes[1].dy = -pLeft->dx;
+    slopes[1].k = 0;
+
+    vertices[2].x = pLeft->xa;
+    vertices[2].y = pLeft->ya;
+
+    if (joinStyle == JoinMiter) {
+        my = (pLeft->dy * (pRight->xa * pRight->dy - pRight->ya * pRight->dx) -
+              pRight->dy * (pLeft->xa * pLeft->dy - pLeft->ya * pLeft->dx)) /
+            denom;
+        if (pLeft->dy != 0)
+            mx = pLeft->xa + (my - pLeft->ya) *
+                (double) pLeft->dx / (double) pLeft->dy;
+        else
+            mx = pRight->xa + (my - pRight->ya) *
+                (double) pRight->dx / (double) pRight->dy;
+
+        /* check miter limit */
+        if ((mx * mx + my * my) * 4 > SQSECANT * lw * lw)
+            joinStyle = JoinBevel;
+    }
+
+    if (joinStyle == JoinMiter) {
+        slopes[2].dx = pLeft->dx;
+        slopes[2].dy = pLeft->dy;
+        slopes[2].k = pLeft->k;
+        if (swapslopes) {
+            slopes[2].dx = -slopes[2].dx;
+            slopes[2].dy = -slopes[2].dy;
+            slopes[2].k = -slopes[2].k;
+        }
+        vertices[3].x = mx;
+        vertices[3].y = my;
+        slopes[3].dx = pRight->dx;
+        slopes[3].dy = pRight->dy;
+        slopes[3].k = pRight->k;
+        if (swapslopes) {
+            slopes[3].dx = -slopes[3].dx;
+            slopes[3].dy = -slopes[3].dy;
+            slopes[3].k = -slopes[3].k;
+        }
+        edgecount = 4;
+    }
+    else {
+        double scale, dx, dy, adx, ady;
+
+        adx = dx = pRight->xa - pLeft->xa;
+        ady = dy = pRight->ya - pLeft->ya;
+        if (adx < 0)
+            adx = -adx;
+        if (ady < 0)
+            ady = -ady;
+        scale = ady;
+        if (adx > ady)
+            scale = adx;
+        slopes[2].dx = (dx * 65536) / scale;
+        slopes[2].dy = (dy * 65536) / scale;
+        slopes[2].k = ((pLeft->xa + pRight->xa) * slopes[2].dy -
+                       (pLeft->ya + pRight->ya) * slopes[2].dx) / 2.0;
+        edgecount = 3;
+    }
+
+    y = miPolyBuildPoly(vertices, slopes, edgecount, pLeft->x, pLeft->y,
+                        left, right, &nleft, &nright, &height);
+    XAAFillPolyHelper(pGC, y, height, left, right, nleft, nright);
+}
+
+void
+XAAPolylinesWideSolid(DrawablePtr pDrawable,
+                      GCPtr pGC, int mode, int npt, DDXPointPtr pPts)
+{
+    XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    int x1, y1, x2, y2;
+    Bool projectLeft, projectRight;
+    LineFaceRec leftFace, rightFace, prevRightFace, firstFace;
+    int first = TRUE;
+    Bool somethingDrawn = FALSE;
+    Bool selfJoin = FALSE;
+    int xorg = pDrawable->x;
+    int yorg = pDrawable->y;
+    Bool hardClip = FALSE;
+
+    if (!RegionNumRects(pGC->pCompositeClip))
+        return;
+
+    if (RegionNumRects(pGC->pCompositeClip) != 1) {
+        miWideLine(pDrawable, pGC, mode, npt, pPts);
+        return;
+    }
+
+    x2 = pPts->x;
+    y2 = pPts->y;
+    if (npt > 1) {
+        if (mode == CoordModePrevious) {
+            int nptTmp;
+            register DDXPointPtr pPtsTmp;
+
+            x1 = x2;
+            y1 = y2;
+            nptTmp = npt;
+            pPtsTmp = pPts + 1;
+            while (--nptTmp) {
+                x1 += pPtsTmp->x;
+                y1 += pPtsTmp->y;
+                ++pPtsTmp;
+            }
+            if ((x2 == x1) && (y2 == y1))
+                selfJoin = TRUE;
+        }
+        else if ((x2 == pPts[npt - 1].x) && (y2 == pPts[npt - 1].y))
+            selfJoin = TRUE;
+    }
+
+    projectLeft = ((pGC->capStyle == CapProjecting) && !selfJoin);
+    projectRight = FALSE;
+
+    (*infoRec->SetupForSolidFill) (infoRec->pScrn, pGC->fgPixel, pGC->alu,
+                                   pGC->planemask);
+
+    infoRec->ClipBox = &pGC->pCompositeClip->extents;
+
+    if (infoRec->ClippingFlags & HARDWARE_CLIP_SOLID_FILL) {
+        hardClip = TRUE;
+        (*infoRec->SetClippingRectangle) (infoRec->pScrn,
+                                          infoRec->ClipBox->x1,
+                                          infoRec->ClipBox->y1,
+                                          infoRec->ClipBox->x2 - 1,
+                                          infoRec->ClipBox->y2 - 1);
+    }
+
+    x2 += xorg;
+    y2 += yorg;
+    while (--npt) {
+        x1 = x2;
+        y1 = y2;
+        ++pPts;
+        x2 = pPts->x;
+        y2 = pPts->y;
+        if (mode == CoordModePrevious) {
+            x2 += x1;
+            y2 += y1;
+        }
+        else {
+            x2 += xorg;
+            y2 += yorg;
+        }
+        if ((x1 != x2) || (y1 != y2)) {
+            somethingDrawn = TRUE;
+            if ((npt == 1) && (pGC->capStyle == CapProjecting) && !selfJoin)
+                projectRight = TRUE;
+            XAAWideSegment(pGC, x1, y1, x2, y2,
+                           projectLeft, projectRight, &leftFace, &rightFace);
+            if (first) {
+                if (selfJoin)
+                    firstFace = leftFace;
+                else if (pGC->capStyle == CapRound) {
+                    if (pGC->lineWidth == 1) {
+                        DRAW_POINT(infoRec->pScrn, x1, y1);
+                    }
+                    else
+                        XAALineArc(pGC, &leftFace, (LineFacePtr) NULL,
+                                   (double) 0.0, (double) 0.0, TRUE);
+                }
+            }
+            else
+                XAALineJoin(pGC, &leftFace, &prevRightFace);
+
+            prevRightFace = rightFace;
+            first = FALSE;
+            projectLeft = FALSE;
+        }
+        if (npt == 1 && somethingDrawn) {
+            if (selfJoin)
+                XAALineJoin(pGC, &firstFace, &rightFace);
+            else if (pGC->capStyle == CapRound) {
+                if (pGC->lineWidth == 1) {
+                    DRAW_POINT(infoRec->pScrn, x2, y2);
+                }
+                else
+                    XAALineArc(pGC, (LineFacePtr) NULL, &rightFace,
+                               (double) 0.0, (double) 0.0, TRUE);
+            }
+        }
+    }
+    /* handle crock where all points are coincedent */
+    if (!somethingDrawn) {
+        projectLeft = (pGC->capStyle == CapProjecting);
+        XAAWideSegment(pGC, x2, y2, x2, y2, projectLeft, projectLeft,
+                       &leftFace, &rightFace);
+        if (pGC->capStyle == CapRound) {
+            XAALineArc(pGC, &leftFace, (LineFacePtr) NULL,
+                       (double) 0.0, (double) 0.0, TRUE);
+            rightFace.dx = -1;  /* sleezy hack to make it work */
+            XAALineArc(pGC, (LineFacePtr) NULL, &rightFace,
+                       (double) 0.0, (double) 0.0, TRUE);
+        }
+    }
+
+    infoRec->ClipBox = NULL;
+    if (hardClip)
+        (*infoRec->DisableClipping) (infoRec->pScrn);
+
+    SET_SYNC_FLAG(infoRec);
+}
diff --git a/hw/xfree86/xaa/xaacexp.h b/hw/xfree86/xaa/xaacexp.h
new file mode 100644
index 000000000..6fde54c65
--- /dev/null
+++ b/hw/xfree86/xaa/xaacexp.h
@@ -0,0 +1,126 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <X11/Xarch.h>
+
+#ifndef FIXEDBASE
+#define CHECKRETURN(b) if(width <= ((b) * 32)) return(base + (b))
+#else
+#define CHECKRETURN(b) if(width <= ((b) * 32)) return(base)
+#endif
+
+#if X_BYTE_ORDER == X_BIG_ENDIAN
+#define SHIFT_L(value, shift) ((value) >> (shift))
+#define SHIFT_R(value, shift) ((value) << (shift))
+#else
+#define SHIFT_L(value, shift) ((value) << (shift))
+#define SHIFT_R(value, shift) ((value) >> (shift))
+#endif
+
+#ifndef MSBFIRST
+#ifdef FIXEDBASE
+#define WRITE_IN_BITORDER(dest, offset, data) *(dest) = data;
+#else
+#define WRITE_IN_BITORDER(dest, offset, data) *(dest + offset) = data;
+#endif
+#else
+#ifdef FIXEDBASE
+#define WRITE_IN_BITORDER(dest, offset, data) *(dest) = SWAP_BITS_IN_BYTES(data);
+#else
+#define WRITE_IN_BITORDER(dest, offset, data) *(dest + offset) = SWAP_BITS_IN_BYTES(data)
+#endif
+#endif
+
+#ifdef FIXEDBASE
+#ifdef MSBFIRST
+#define WRITE_BITS(b)   *base = SWAP_BITS_IN_BYTES(b)
+#define WRITE_BITS1(b) { \
+	*base = byte_reversed_expand3[(b) & 0xFF] | \
+		byte_reversed_expand3[((b) & 0xFF00) >> 8] << 24; }
+#define WRITE_BITS2(b) { \
+	*base = byte_reversed_expand3[(b) & 0xFF] | \
+		byte_reversed_expand3[((b) & 0xFF00) >> 8] << 24; \
+	*base = byte_reversed_expand3[((b) & 0xFF00) >> 8] >> 8 | \
+		byte_reversed_expand3[((b) & 0xFF0000) >> 16] << 16; }
+#define WRITE_BITS3(b) { \
+	*base = byte_reversed_expand3[(b) & 0xFF] | \
+		byte_reversed_expand3[((b) & 0xFF00) >> 8] << 24; \
+	*base = byte_reversed_expand3[((b) & 0xFF00) >> 8] >> 8 | \
+		byte_reversed_expand3[((b) & 0xFF0000) >> 16] << 16; \
+	*base = byte_reversed_expand3[((b) & 0xFF0000) >> 16] >> 16 | \
+		byte_reversed_expand3[((b) & 0xFF000000) >> 24] << 8; }
+#else
+#define WRITE_BITS(b)   *base = (b)
+#define WRITE_BITS1(b) { \
+	*base = byte_expand3[(b) & 0xFF] | \
+		byte_expand3[((b) & 0xFF00) >> 8] << 24; }
+#define WRITE_BITS2(b) { \
+	*base = byte_expand3[(b) & 0xFF] | \
+		byte_expand3[((b) & 0xFF00) >> 8] << 24; \
+	*base = byte_expand3[((b) & 0xFF00) >> 8] >> 8 | \
+		byte_expand3[((b) & 0xFF0000) >> 16] << 16; }
+#define WRITE_BITS3(b) { \
+	*base = byte_expand3[(b) & 0xFF] | \
+		byte_expand3[((b) & 0xFF00) >> 8] << 24; \
+	*base = byte_expand3[((b) & 0xFF00) >> 8] >> 8 | \
+		byte_expand3[((b) & 0xFF0000) >> 16] << 16; \
+	*base = byte_expand3[((b) & 0xFF0000) >> 16] >> 16 | \
+		byte_expand3[((b) & 0xFF000000) >> 24] << 8; }
+#endif
+#else
+#ifdef MSBFIRST
+#define WRITE_BITS(b)   *(base++) = SWAP_BITS_IN_BYTES(b)
+#define WRITE_BITS1(b) { \
+	*(base++) = byte_reversed_expand3[(b) & 0xFF] | \
+		byte_reversed_expand3[((b) & 0xFF00) >> 8] << 24; }
+#define WRITE_BITS2(b) { \
+	*(base) = byte_reversed_expand3[(b) & 0xFF] | \
+		byte_reversed_expand3[((b) & 0xFF00) >> 8] << 24; \
+	*(base + 1) = byte_reversed_expand3[((b) & 0xFF00) >> 8] >> 8 | \
+		byte_reversed_expand3[((b) & 0xFF0000) >> 16] << 16; \
+	base += 2; }
+#define WRITE_BITS3(b) { \
+	*(base) = byte_reversed_expand3[(b) & 0xFF] | \
+		byte_reversed_expand3[((b) & 0xFF00) >> 8] << 24; \
+	*(base + 1) = byte_reversed_expand3[((b) & 0xFF00) >> 8] >> 8 | \
+		byte_reversed_expand3[((b) & 0xFF0000) >> 16] << 16; \
+	*(base + 2) = byte_reversed_expand3[((b) & 0xFF0000) >> 16] >> 16 | \
+		byte_reversed_expand3[((b) & 0xFF000000) >> 24] << 8; \
+	base += 3; }
+#else
+#define WRITE_BITS(b)   *(base++) = (b)
+#define WRITE_BITS1(b) { \
+	*(base++) = byte_expand3[(b) & 0xFF] | \
+		byte_expand3[((b) & 0xFF00) >> 8] << 24; }
+#define WRITE_BITS2(b) { \
+	*(base) = byte_expand3[(b) & 0xFF] | \
+		byte_expand3[((b) & 0xFF00) >> 8] << 24; \
+	*(base + 1) = byte_expand3[((b) & 0xFF00) >> 8] >> 8 | \
+		byte_expand3[((b) & 0xFF0000) >> 16] << 16; \
+	base += 2; }
+#define WRITE_BITS3(b) { \
+	*(base) = byte_expand3[(b) & 0xFF] | \
+		byte_expand3[((b) & 0xFF00) >> 8] << 24; \
+	*(base + 1) = byte_expand3[((b) & 0xFF00) >> 8] >> 8 | \
+		byte_expand3[((b) & 0xFF0000) >> 16] << 16; \
+	*(base + 2) = byte_expand3[((b) & 0xFF0000) >> 16] >> 16 | \
+		byte_expand3[((b) & 0xFF000000) >> 24] << 8; \
+	base += 3; }
+#endif
+#endif
+
+#ifdef FIXEDBASE
+#ifdef MSBFIRST
+#define EXPNAME(x) x##MSBFirstFixedBase
+#else
+#define EXPNAME(x) x##LSBFirstFixedBase
+#endif
+#else
+#ifdef MSBFIRST
+#define EXPNAME(x) x##MSBFirst
+#else
+#define EXPNAME(x) x##LSBFirst
+#endif
+#endif
diff --git a/hw/xfree86/xaa/xaalocal.h b/hw/xfree86/xaa/xaalocal.h
new file mode 100644
index 000000000..76eb1070e
--- /dev/null
+++ b/hw/xfree86/xaa/xaalocal.h
@@ -0,0 +1,1437 @@
+
+#ifndef _XAALOCAL_H
+#define _XAALOCAL_H
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+/* This file is very unorganized ! */
+
+#include "gcstruct.h"
+#include "regionstr.h"
+#include "xf86fbman.h"
+#include "xaa.h"
+#include "mi.h"
+#include "picturestr.h"
+
+#define GCWhenForced		(GCArcMode << 1)
+
+#define DO_COLOR_8x8		0x00000001
+#define DO_MONO_8x8		0x00000002
+#define DO_CACHE_BLT		0x00000003
+#define DO_COLOR_EXPAND		0x00000004
+#define DO_CACHE_EXPAND		0x00000005
+#define DO_IMAGE_WRITE		0x00000006
+#define DO_PIXMAP_COPY		0x00000007
+#define DO_SOLID		0x00000008
+
+typedef CARD32 *(*GlyphScanlineFuncPtr) (CARD32 *base, unsigned int **glyphp,
+                                         int line, int nglyph, int width);
+
+typedef CARD32 *(*StippleScanlineProcPtr) (CARD32 *, CARD32 *, int, int, int);
+
+typedef void (*RectFuncPtr) (ScrnInfoPtr, int, int, int, int, int, int,
+                             XAACacheInfoPtr);
+typedef void (*TrapFuncPtr) (ScrnInfoPtr, int, int, int, int, int, int,
+                             int, int, int, int, int, int, XAACacheInfoPtr);
+
+typedef struct _XAAScreen {
+    CreateGCProcPtr CreateGC;
+    CloseScreenProcPtr CloseScreen;
+    GetImageProcPtr GetImage;
+    GetSpansProcPtr GetSpans;
+    CopyWindowProcPtr CopyWindow;
+    WindowExposuresProcPtr WindowExposures;
+    CreatePixmapProcPtr CreatePixmap;
+    DestroyPixmapProcPtr DestroyPixmap;
+    ChangeWindowAttributesProcPtr ChangeWindowAttributes;
+    XAAInfoRecPtr AccelInfoRec;
+    Bool (*EnterVT) (ScrnInfoPtr);
+    void (*LeaveVT) (ScrnInfoPtr);
+    int (*SetDGAMode) (ScrnInfoPtr, int, DGADevicePtr);
+    void (*EnableDisableFBAccess) (ScrnInfoPtr, Bool);
+    CompositeProcPtr Composite;
+    GlyphsProcPtr Glyphs;
+} XAAScreenRec, *XAAScreenPtr;
+
+#define	OPS_ARE_PIXMAP		0x00000001
+#define OPS_ARE_ACCEL		0x00000002
+
+typedef struct _XAAGC {
+    GCOps *wrapOps;
+    GCFuncs *wrapFuncs;
+    GCOps *XAAOps;
+    int DashLength;
+    unsigned char *DashPattern;
+    unsigned long changes;
+    unsigned long flags;
+} XAAGCRec, *XAAGCPtr;
+
+#define REDUCIBILITY_CHECKED	0x00000001
+#define REDUCIBLE_TO_8x8	0x00000002
+#define REDUCIBLE_TO_2_COLOR	0x00000004
+#define DIRTY			0x00010000
+#define OFFSCREEN		0x00020000
+#define DGA_PIXMAP		0x00040000
+#define SHARED_PIXMAP		0x00080000
+#define LOCKED_PIXMAP		0x00100000
+
+#define REDUCIBILITY_MASK \
+ (REDUCIBILITY_CHECKED | REDUCIBLE_TO_8x8 | REDUCIBLE_TO_2_COLOR)
+
+typedef struct _XAAPixmap {
+    unsigned long flags;
+    CARD32 pattern0;
+    CARD32 pattern1;
+    int fg;
+    int bg;
+    FBAreaPtr offscreenArea;
+    Bool freeData;
+} XAAPixmapRec, *XAAPixmapPtr;
+
+extern _X_EXPORT Bool
+ XAACreateGC(GCPtr pGC);
+
+extern _X_EXPORT Bool
+ XAAInitAccel(ScreenPtr pScreen, XAAInfoRecPtr infoRec);
+
+extern _X_EXPORT RegionPtr
+
+XAABitBlt(DrawablePtr pSrcDrawable,
+          DrawablePtr pDstDrawable,
+          GC * pGC,
+          int srcx,
+          int srcy,
+          int width,
+          int height,
+          int dstx,
+          int dsty,
+          void (*doBitBlt) (DrawablePtr, DrawablePtr, GCPtr, RegionPtr,
+                            DDXPointPtr), unsigned long bitPlane);
+
+extern _X_EXPORT void
+
+XAAScreenToScreenBitBlt(ScrnInfoPtr pScrn,
+                        int nbox,
+                        DDXPointPtr pptSrc,
+                        BoxPtr pbox,
+                        int xdir, int ydir, int alu, unsigned int planemask);
+
+extern _X_EXPORT void
+
+XAADoBitBlt(DrawablePtr pSrc,
+            DrawablePtr pDst, GC * pGC, RegionPtr prgnDst, DDXPointPtr pptSrc);
+
+extern _X_EXPORT void
+
+XAADoImageWrite(DrawablePtr pSrc,
+                DrawablePtr pDst,
+                GC * pGC, RegionPtr prgnDst, DDXPointPtr pptSrc);
+
+extern _X_EXPORT void
+
+XAADoImageRead(DrawablePtr pSrc,
+               DrawablePtr pDst,
+               GC * pGC, RegionPtr prgnDst, DDXPointPtr pptSrc);
+
+extern _X_EXPORT void
+ XAACopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc);
+
+extern _X_EXPORT RegionPtr
+
+XAACopyArea(DrawablePtr pSrcDrawable,
+            DrawablePtr pDstDrawable,
+            GC * pGC,
+            int srcx, int srcy, int width, int height, int dstx, int dsty);
+
+extern _X_EXPORT void
+ XAAValidateCopyArea(GCPtr pGC, unsigned long changes, DrawablePtr pDraw);
+
+extern _X_EXPORT void
+ XAAValidatePutImage(GCPtr pGC, unsigned long changes, DrawablePtr pDraw);
+
+extern _X_EXPORT void
+ XAAValidateCopyPlane(GCPtr pGC, unsigned long changes, DrawablePtr pDraw);
+
+extern _X_EXPORT void
+ XAAValidatePushPixels(GCPtr pGC, unsigned long changes, DrawablePtr pDraw);
+
+extern _X_EXPORT void
+ XAAValidateFillSpans(GCPtr pGC, unsigned long changes, DrawablePtr pDraw);
+
+extern _X_EXPORT void
+ XAAValidatePolyGlyphBlt(GCPtr pGC, unsigned long changes, DrawablePtr pDraw);
+
+extern _X_EXPORT void
+ XAAValidateImageGlyphBlt(GCPtr pGC, unsigned long changes, DrawablePtr pDraw);
+
+extern _X_EXPORT void
+ XAAValidatePolylines(GCPtr pGC, unsigned long changes, DrawablePtr pDraw);
+
+extern _X_EXPORT RegionPtr
+
+XAACopyPlaneColorExpansion(DrawablePtr pSrc,
+                           DrawablePtr pDst,
+                           GCPtr pGC,
+                           int srcx,
+                           int srcy,
+                           int width,
+                           int height,
+                           int dstx, int dsty, unsigned long bitPlane);
+
+extern _X_EXPORT void
+
+XAAPushPixelsSolidColorExpansion(GCPtr pGC,
+                                 PixmapPtr pBitMap,
+                                 DrawablePtr pDrawable,
+                                 int dx, int dy, int xOrg, int yOrg);
+
+extern _X_EXPORT void
+
+XAAWriteBitmapColorExpandMSBFirstFixedBase(ScrnInfoPtr pScrn,
+                                           int x, int y, int w, int h,
+                                           unsigned char *src,
+                                           int srcwidth,
+                                           int skipleft,
+                                           int fg, int bg,
+                                           int rop, unsigned int planemask);
+
+extern _X_EXPORT void
+
+XAAWriteBitmapColorExpand3MSBFirstFixedBase(ScrnInfoPtr pScrn,
+                                            int x, int y, int w, int h,
+                                            unsigned char *src,
+                                            int srcwidth,
+                                            int skipleft,
+                                            int fg, int bg,
+                                            int rop, unsigned int planemask);
+
+extern _X_EXPORT void
+
+XAAWriteBitmapColorExpandMSBFirst(ScrnInfoPtr pScrn,
+                                  int x, int y, int w, int h,
+                                  unsigned char *src,
+                                  int srcwidth,
+                                  int skipleft,
+                                  int fg, int bg,
+                                  int rop, unsigned int planemask);
+
+extern _X_EXPORT void
+
+XAAWriteBitmapColorExpand3MSBFirst(ScrnInfoPtr pScrn,
+                                   int x, int y, int w, int h,
+                                   unsigned char *src,
+                                   int srcwidth,
+                                   int skipleft,
+                                   int fg, int bg,
+                                   int rop, unsigned int planemask);
+
+extern _X_EXPORT void
+
+XAAWriteBitmapColorExpandLSBFirstFixedBase(ScrnInfoPtr pScrn,
+                                           int x, int y, int w, int h,
+                                           unsigned char *src,
+                                           int srcwidth,
+                                           int skipleft,
+                                           int fg, int bg,
+                                           int rop, unsigned int planemask);
+
+extern _X_EXPORT void
+
+XAAWriteBitmapColorExpand3LSBFirstFixedBase(ScrnInfoPtr pScrn,
+                                            int x, int y, int w, int h,
+                                            unsigned char *src,
+                                            int srcwidth,
+                                            int skipleft,
+                                            int fg, int bg,
+                                            int rop, unsigned int planemask);
+
+extern _X_EXPORT void
+
+XAAWriteBitmapColorExpandLSBFirst(ScrnInfoPtr pScrn,
+                                  int x, int y, int w, int h,
+                                  unsigned char *src,
+                                  int srcwidth,
+                                  int skipleft,
+                                  int fg, int bg,
+                                  int rop, unsigned int planemask);
+
+extern _X_EXPORT void
+
+XAAWriteBitmapColorExpand3LSBFirst(ScrnInfoPtr pScrn,
+                                   int x, int y, int w, int h,
+                                   unsigned char *src,
+                                   int srcwidth,
+                                   int skipleft,
+                                   int fg, int bg,
+                                   int rop, unsigned int planemask);
+
+extern _X_EXPORT void
+
+XAAWriteBitmapScanlineColorExpandMSBFirst(ScrnInfoPtr pScrn,
+                                          int x, int y, int w, int h,
+                                          unsigned char *src,
+                                          int srcwidth,
+                                          int skipleft,
+                                          int fg, int bg,
+                                          int rop, unsigned int planemask);
+
+extern _X_EXPORT void
+
+XAAWriteBitmapScanlineColorExpand3MSBFirst(ScrnInfoPtr pScrn,
+                                           int x, int y, int w, int h,
+                                           unsigned char *src,
+                                           int srcwidth,
+                                           int skipleft,
+                                           int fg, int bg,
+                                           int rop, unsigned int planemask);
+
+extern _X_EXPORT void
+
+XAAWriteBitmapScanlineColorExpandMSBFirstFixedBase(ScrnInfoPtr pScrn,
+                                                   int x, int y, int w, int h,
+                                                   unsigned char *src,
+                                                   int srcwidth,
+                                                   int skipleft,
+                                                   int fg, int bg,
+                                                   int rop,
+                                                   unsigned int planemask);
+
+extern _X_EXPORT void
+
+XAAWriteBitmapScanlineColorExpand3MSBFirstFixedBase(ScrnInfoPtr pScrn,
+                                                    int x, int y, int w, int h,
+                                                    unsigned char *src,
+                                                    int srcwidth,
+                                                    int skipleft,
+                                                    int fg, int bg,
+                                                    int rop,
+                                                    unsigned int planemask);
+
+extern _X_EXPORT void
+
+XAAWriteBitmapScanlineColorExpandLSBFirst(ScrnInfoPtr pScrn,
+                                          int x, int y, int w, int h,
+                                          unsigned char *src,
+                                          int srcwidth,
+                                          int skipleft,
+                                          int fg, int bg,
+                                          int rop, unsigned int planemask);
+
+extern _X_EXPORT void
+
+XAAWriteBitmapScanlineColorExpand3LSBFirst(ScrnInfoPtr pScrn,
+                                           int x, int y, int w, int h,
+                                           unsigned char *src,
+                                           int srcwidth,
+                                           int skipleft,
+                                           int fg, int bg,
+                                           int rop, unsigned int planemask);
+
+extern _X_EXPORT void
+
+XAAWriteBitmapScanlineColorExpandLSBFirstFixedBase(ScrnInfoPtr pScrn,
+                                                   int x, int y, int w, int h,
+                                                   unsigned char *src,
+                                                   int srcwidth,
+                                                   int skipleft,
+                                                   int fg, int bg,
+                                                   int rop,
+                                                   unsigned int planemask);
+
+extern _X_EXPORT void
+
+XAAWriteBitmapScanlineColorExpand3LSBFirstFixedBase(ScrnInfoPtr pScrn,
+                                                    int x, int y, int w, int h,
+                                                    unsigned char *src,
+                                                    int srcwidth,
+                                                    int skipleft,
+                                                    int fg, int bg,
+                                                    int rop,
+                                                    unsigned int planemask);
+
+extern _X_EXPORT void
+
+XAAWritePixmap(ScrnInfoPtr pScrn,
+               int x, int y, int w, int h,
+               unsigned char *src,
+               int srcwidth,
+               int rop,
+               unsigned int planemask,
+               int transparency_color, int bpp, int depth);
+
+extern _X_EXPORT void
+
+XAAWritePixmapScanline(ScrnInfoPtr pScrn,
+                       int x, int y, int w, int h,
+                       unsigned char *src,
+                       int srcwidth,
+                       int rop,
+                       unsigned int planemask,
+                       int transparency_color, int bpp, int depth);
+
+typedef void (*ClipAndRenderRectsFunc) (GCPtr, int, BoxPtr, int, int);
+
+extern _X_EXPORT void
+
+XAAClipAndRenderRects(GCPtr pGC,
+                      ClipAndRenderRectsFunc func,
+                      int nrectFill, xRectangle *prectInit, int xorg, int yorg);
+
+typedef void (*ClipAndRenderSpansFunc) (GCPtr, int, DDXPointPtr, int *,
+                                        int, int, int);
+
+extern _X_EXPORT void
+
+XAAClipAndRenderSpans(GCPtr pGC,
+                      DDXPointPtr ppt,
+                      int *pwidth,
+                      int nspans,
+                      int fSorted,
+                      ClipAndRenderSpansFunc func, int xorg, int yorg);
+
+extern _X_EXPORT void
+
+XAAFillSolidRects(ScrnInfoPtr pScrn,
+                  int fg, int rop,
+                  unsigned int planemask, int nBox, BoxPtr pBox);
+
+extern _X_EXPORT void
+
+XAAFillMono8x8PatternRects(ScrnInfoPtr pScrn,
+                           int fg, int bg, int rop,
+                           unsigned int planemask,
+                           int nBox,
+                           BoxPtr pBox, int pat0, int pat1, int xorg, int yorg);
+
+extern _X_EXPORT void
+
+XAAFillMono8x8PatternRectsScreenOrigin(ScrnInfoPtr pScrn,
+                                       int fg, int bg, int rop,
+                                       unsigned int planemask,
+                                       int nBox,
+                                       BoxPtr pBox,
+                                       int pat0, int pat1, int xorg, int yorg);
+
+extern _X_EXPORT void
+
+XAAFillColor8x8PatternRectsScreenOrigin(ScrnInfoPtr pScrn,
+                                        int rop,
+                                        unsigned int planemask,
+                                        int nBox,
+                                        BoxPtr pBox,
+                                        int xorigin, int yorigin,
+                                        XAACacheInfoPtr pCache);
+
+extern _X_EXPORT void
+
+XAAFillColor8x8PatternRects(ScrnInfoPtr pScrn,
+                            int rop,
+                            unsigned int planemask,
+                            int nBox,
+                            BoxPtr pBox,
+                            int xorigin, int yorigin, XAACacheInfoPtr pCache);
+
+extern _X_EXPORT void
+
+XAAFillCacheBltRects(ScrnInfoPtr pScrn,
+                     int rop,
+                     unsigned int planemask,
+                     int nBox,
+                     BoxPtr pBox, int xorg, int yorg, XAACacheInfoPtr pCache);
+
+extern _X_EXPORT void
+
+XAAFillCacheExpandRects(ScrnInfoPtr pScrn,
+                        int fg, int bg, int rop,
+                        unsigned int planemask,
+                        int nBox,
+                        BoxPtr pBox, int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillImageWriteRects(ScrnInfoPtr pScrn,
+                       int rop,
+                       unsigned int planemask,
+                       int nBox,
+                       BoxPtr pBox, int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAPolyFillRect(DrawablePtr pDraw,
+                GCPtr pGC, int nrectFill, xRectangle *prectInit);
+
+extern _X_EXPORT void
+
+XAATEGlyphRendererMSBFirstFixedBase(ScrnInfoPtr pScrn,
+                                    int x, int y, int w, int h, int skipleft,
+                                    int startline, unsigned int **glyphs,
+                                    int glyphWidth, int fg, int bg, int rop,
+                                    unsigned planemask);
+
+extern _X_EXPORT void
+
+XAATEGlyphRenderer3MSBFirstFixedBase(ScrnInfoPtr pScrn,
+                                     int x, int y, int w, int h, int skipleft,
+                                     int startline, unsigned int **glyphs,
+                                     int glyphWidth, int fg, int bg, int rop,
+                                     unsigned planemask);
+
+extern _X_EXPORT void
+
+XAATEGlyphRendererMSBFirst(ScrnInfoPtr pScrn,
+                           int x, int y, int w, int h, int skipleft,
+                           int startline, unsigned int **glyphs, int glyphWidth,
+                           int fg, int bg, int rop, unsigned planemask);
+
+extern _X_EXPORT void
+
+XAATEGlyphRenderer3MSBFirst(ScrnInfoPtr pScrn,
+                            int x, int y, int w, int h, int skipleft,
+                            int startline, unsigned int **glyphs,
+                            int glyphWidth, int fg, int bg, int rop,
+                            unsigned planemask);
+
+extern _X_EXPORT void
+
+XAATEGlyphRendererLSBFirstFixedBase(ScrnInfoPtr pScrn,
+                                    int x, int y, int w, int h, int skipleft,
+                                    int startline, unsigned int **glyphs,
+                                    int glyphWidth, int fg, int bg, int rop,
+                                    unsigned planemask);
+
+extern _X_EXPORT void
+
+XAATEGlyphRenderer3LSBFirstFixedBase(ScrnInfoPtr pScrn,
+                                     int x, int y, int w, int h, int skipleft,
+                                     int startline, unsigned int **glyphs,
+                                     int glyphWidth, int fg, int bg, int rop,
+                                     unsigned planemask);
+
+extern _X_EXPORT void
+
+XAATEGlyphRendererLSBFirst(ScrnInfoPtr pScrn,
+                           int x, int y, int w, int h, int skipleft,
+                           int startline, unsigned int **glyphs, int glyphWidth,
+                           int fg, int bg, int rop, unsigned planemask);
+
+extern _X_EXPORT void
+
+XAATEGlyphRenderer3LSBFirst(ScrnInfoPtr pScrn,
+                            int x, int y, int w, int h, int skipleft,
+                            int startline, unsigned int **glyphs,
+                            int glyphWidth, int fg, int bg, int rop,
+                            unsigned planemask);
+
+extern _X_EXPORT void
+
+XAATEGlyphRendererScanlineMSBFirst(ScrnInfoPtr pScrn,
+                                   int x, int y, int w, int h, int skipleft,
+                                   int startline, unsigned int **glyphs,
+                                   int glyphWidth, int fg, int bg, int rop,
+                                   unsigned planemask);
+
+extern _X_EXPORT void
+
+XAATEGlyphRendererScanline3MSBFirst(ScrnInfoPtr pScrn,
+                                    int x, int y, int w, int h, int skipleft,
+                                    int startline, unsigned int **glyphs,
+                                    int glyphWidth, int fg, int bg, int rop,
+                                    unsigned planemask);
+
+extern _X_EXPORT void
+
+XAATEGlyphRendererScanlineLSBFirst(ScrnInfoPtr pScrn,
+                                   int x, int y, int w, int h, int skipleft,
+                                   int startline, unsigned int **glyphs,
+                                   int glyphWidth, int fg, int bg, int rop,
+                                   unsigned planemask);
+
+extern _X_EXPORT void
+
+XAATEGlyphRendererScanline3LSBFirst(ScrnInfoPtr pScrn,
+                                    int x, int y, int w, int h, int skipleft,
+                                    int startline, unsigned int **glyphs,
+                                    int glyphWidth, int fg, int bg, int rop,
+                                    unsigned planemask);
+
+extern _X_EXPORT CARD32 *(*XAAGlyphScanlineFuncMSBFirstFixedBase[32]) (CARD32
+                                                                       *base,
+                                                                       unsigned
+                                                                       int
+                                                                       **glyphp,
+                                                                       int line,
+                                                                       int
+                                                                       nglyph,
+                                                                       int
+                                                                       width);
+
+extern _X_EXPORT CARD32 *(*XAAGlyphScanlineFuncMSBFirst[32]) (CARD32 *base,
+                                                              unsigned int
+                                                              **glyphp,
+                                                              int line,
+                                                              int nglyph,
+                                                              int width);
+
+extern _X_EXPORT CARD32 *(*XAAGlyphScanlineFuncLSBFirstFixedBase[32]) (CARD32
+                                                                       *base,
+                                                                       unsigned
+                                                                       int
+                                                                       **glyphp,
+                                                                       int line,
+                                                                       int
+                                                                       nglyph,
+                                                                       int
+                                                                       width);
+
+extern _X_EXPORT CARD32 *(*XAAGlyphScanlineFuncLSBFirst[32]) (CARD32 *base,
+                                                              unsigned int
+                                                              **glyphp,
+                                                              int line,
+                                                              int nglyph,
+                                                              int width);
+
+extern _X_EXPORT GlyphScanlineFuncPtr
+    *XAAGetGlyphScanlineFuncMSBFirstFixedBase(void);
+extern _X_EXPORT GlyphScanlineFuncPtr *XAAGetGlyphScanlineFuncMSBFirst(void);
+extern _X_EXPORT GlyphScanlineFuncPtr
+    *XAAGetGlyphScanlineFuncLSBFirstFixedBase(void);
+extern _X_EXPORT GlyphScanlineFuncPtr *XAAGetGlyphScanlineFuncLSBFirst(void);
+
+extern _X_EXPORT void
+
+XAAFillColorExpandRectsLSBFirst(ScrnInfoPtr pScrn,
+                                int fg, int bg, int rop,
+                                unsigned int planemask,
+                                int nBox,
+                                BoxPtr pBox,
+                                int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillColorExpandRects3LSBFirst(ScrnInfoPtr pScrn,
+                                 int fg, int bg, int rop,
+                                 unsigned int planemask,
+                                 int nBox,
+                                 BoxPtr pBox,
+                                 int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillColorExpandRectsLSBFirstFixedBase(ScrnInfoPtr pScrn,
+                                         int fg, int bg, int rop,
+                                         unsigned int planemask,
+                                         int nBox,
+                                         BoxPtr pBox,
+                                         int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillColorExpandRects3LSBFirstFixedBase(ScrnInfoPtr pScrn,
+                                          int fg, int bg, int rop,
+                                          unsigned int planemask,
+                                          int nBox,
+                                          BoxPtr pBox,
+                                          int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillColorExpandRectsMSBFirst(ScrnInfoPtr pScrn,
+                                int fg, int bg, int rop,
+                                unsigned int planemask,
+                                int nBox,
+                                BoxPtr pBox,
+                                int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillColorExpandRects3MSBFirst(ScrnInfoPtr pScrn,
+                                 int fg, int bg, int rop,
+                                 unsigned int planemask,
+                                 int nBox,
+                                 BoxPtr pBox,
+                                 int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillColorExpandRectsMSBFirstFixedBase(ScrnInfoPtr pScrn,
+                                         int fg, int bg, int rop,
+                                         unsigned int planemask,
+                                         int nBox,
+                                         BoxPtr pBox,
+                                         int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillColorExpandRects3MSBFirstFixedBase(ScrnInfoPtr pScrn,
+                                          int fg, int bg, int rop,
+                                          unsigned int planemask,
+                                          int nBox,
+                                          BoxPtr pBox,
+                                          int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillScanlineColorExpandRectsLSBFirst(ScrnInfoPtr pScrn,
+                                        int fg, int bg, int rop,
+                                        unsigned int planemask,
+                                        int nBox,
+                                        BoxPtr pBox,
+                                        int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillScanlineColorExpandRects3LSBFirst(ScrnInfoPtr pScrn,
+                                         int fg, int bg, int rop,
+                                         unsigned int planemask,
+                                         int nBox,
+                                         BoxPtr pBox,
+                                         int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillScanlineColorExpandRectsMSBFirst(ScrnInfoPtr pScrn,
+                                        int fg, int bg, int rop,
+                                        unsigned int planemask,
+                                        int nBox,
+                                        BoxPtr pBox,
+                                        int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillScanlineColorExpandRects3MSBFirst(ScrnInfoPtr pScrn,
+                                         int fg, int bg, int rop,
+                                         unsigned int planemask,
+                                         int nBox,
+                                         BoxPtr pBox,
+                                         int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillColorExpandSpansLSBFirst(ScrnInfoPtr pScrn,
+                                int fg, int bg, int rop,
+                                unsigned int planemask,
+                                int n,
+                                DDXPointPtr ppt,
+                                int *pwidth,
+                                int fSorted,
+                                int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillColorExpandSpans3LSBFirst(ScrnInfoPtr pScrn,
+                                 int fg, int bg, int rop,
+                                 unsigned int planemask,
+                                 int n,
+                                 DDXPointPtr ppt,
+                                 int *pwidth,
+                                 int fSorted,
+                                 int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillColorExpandSpansLSBFirstFixedBase(ScrnInfoPtr pScrn,
+                                         int fg, int bg, int rop,
+                                         unsigned int planemask,
+                                         int n,
+                                         DDXPointPtr ppt,
+                                         int *pwidth,
+                                         int fSorted,
+                                         int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillColorExpandSpans3LSBFirstFixedBase(ScrnInfoPtr pScrn,
+                                          int fg, int bg, int rop,
+                                          unsigned int planemask,
+                                          int n,
+                                          DDXPointPtr ppt,
+                                          int *pwidth,
+                                          int fSorted,
+                                          int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillColorExpandSpansMSBFirst(ScrnInfoPtr pScrn,
+                                int fg, int bg, int rop,
+                                unsigned int planemask,
+                                int n,
+                                DDXPointPtr ppt,
+                                int *pwidth,
+                                int fSorted,
+                                int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillColorExpandSpans3MSBFirst(ScrnInfoPtr pScrn,
+                                 int fg, int bg, int rop,
+                                 unsigned int planemask,
+                                 int n,
+                                 DDXPointPtr ppt,
+                                 int *pwidth,
+                                 int fSorted,
+                                 int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillColorExpandSpansMSBFirstFixedBase(ScrnInfoPtr pScrn,
+                                         int fg, int bg, int rop,
+                                         unsigned int planemask,
+                                         int n,
+                                         DDXPointPtr ppt,
+                                         int *pwidth,
+                                         int fSorted,
+                                         int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillColorExpandSpans3MSBFirstFixedBase(ScrnInfoPtr pScrn,
+                                          int fg, int bg, int rop,
+                                          unsigned int planemask,
+                                          int n,
+                                          DDXPointPtr ppt,
+                                          int *pwidth,
+                                          int fSorted,
+                                          int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillScanlineColorExpandSpansLSBFirst(ScrnInfoPtr pScrn,
+                                        int fg, int bg, int rop,
+                                        unsigned int planemask,
+                                        int n,
+                                        DDXPointPtr ppt,
+                                        int *pwidth,
+                                        int fSorted,
+                                        int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillScanlineColorExpandSpans3LSBFirst(ScrnInfoPtr pScrn,
+                                         int fg, int bg, int rop,
+                                         unsigned int planemask,
+                                         int n,
+                                         DDXPointPtr ppt,
+                                         int *pwidth,
+                                         int fSorted,
+                                         int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAPutImage(DrawablePtr pDraw,
+            GCPtr pGC,
+            int depth,
+            int x, int y, int w, int h, int leftPad, int format, char *pImage);
+
+extern _X_EXPORT void
+
+XAAFillScanlineColorExpandSpansMSBFirst(ScrnInfoPtr pScrn,
+                                        int fg, int bg, int rop,
+                                        unsigned int planemask,
+                                        int n,
+                                        DDXPointPtr ppt,
+                                        int *pwidth,
+                                        int fSorted,
+                                        int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillScanlineColorExpandSpans3MSBFirst(ScrnInfoPtr pScrn,
+                                         int fg, int bg, int rop,
+                                         unsigned int planemask,
+                                         int n,
+                                         DDXPointPtr ppt,
+                                         int *pwidth,
+                                         int fSorted,
+                                         int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT CARD32 *(*XAAStippleScanlineFuncMSBFirstFixedBase[6]) (CARD32
+                                                                        *base,
+                                                                        CARD32
+                                                                        *src,
+                                                                        int
+                                                                        offset,
+                                                                        int
+                                                                        width,
+                                                                        int
+                                                                        dwords);
+
+extern _X_EXPORT CARD32 *(*XAAStippleScanlineFuncMSBFirst[6]) (CARD32 *base,
+                                                               CARD32 *src,
+                                                               int offset,
+                                                               int width,
+                                                               int dwords);
+
+extern _X_EXPORT CARD32 *(*XAAStippleScanlineFuncLSBFirstFixedBase[6]) (CARD32
+                                                                        *base,
+                                                                        CARD32
+                                                                        *src,
+                                                                        int
+                                                                        offset,
+                                                                        int
+                                                                        width,
+                                                                        int
+                                                                        dwords);
+
+extern _X_EXPORT CARD32 *(*XAAStippleScanlineFuncLSBFirst[6]) (CARD32 *base,
+                                                               CARD32 *src,
+                                                               int offset,
+                                                               int width,
+                                                               int dwords);
+
+extern _X_EXPORT StippleScanlineProcPtr
+    *XAAGetStippleScanlineFuncMSBFirstFixedBase(void);
+extern _X_EXPORT StippleScanlineProcPtr
+    *XAAGetStippleScanlineFuncMSBFirst(void);
+extern _X_EXPORT StippleScanlineProcPtr
+    *XAAGetStippleScanlineFuncLSBFirstFixedBase(void);
+extern _X_EXPORT StippleScanlineProcPtr
+    *XAAGetStippleScanlineFuncLSBFirst(void);
+extern _X_EXPORT StippleScanlineProcPtr
+    *XAAGetStippleScanlineFunc3MSBFirstFixedBase(void);
+extern _X_EXPORT StippleScanlineProcPtr
+    *XAAGetStippleScanlineFunc3MSBFirst(void);
+extern _X_EXPORT StippleScanlineProcPtr
+    *XAAGetStippleScanlineFunc3LSBFirstFixedBase(void);
+extern _X_EXPORT StippleScanlineProcPtr
+    *XAAGetStippleScanlineFunc3LSBFirst(void);
+
+extern _X_EXPORT int
+
+XAAPolyText8TEColorExpansion(DrawablePtr pDraw,
+                             GCPtr pGC, int x, int y, int count, char *chars);
+
+extern _X_EXPORT int
+
+XAAPolyText16TEColorExpansion(DrawablePtr pDraw,
+                              GCPtr pGC,
+                              int x, int y, int count, unsigned short *chars);
+
+extern _X_EXPORT void
+
+XAAImageText8TEColorExpansion(DrawablePtr pDraw,
+                              GCPtr pGC, int x, int y, int count, char *chars);
+
+extern _X_EXPORT void
+
+XAAImageText16TEColorExpansion(DrawablePtr pDraw,
+                               GCPtr pGC,
+                               int x, int y, int count, unsigned short *chars);
+
+extern _X_EXPORT void
+
+XAAImageGlyphBltTEColorExpansion(DrawablePtr pDrawable,
+                                 GCPtr pGC,
+                                 int xInit, int yInit,
+                                 unsigned int nglyph,
+                                 CharInfoPtr * ppci, void *pglyphBase);
+
+extern _X_EXPORT void
+
+XAAPolyGlyphBltTEColorExpansion(DrawablePtr pDrawable,
+                                GCPtr pGC,
+                                int xInit, int yInit,
+                                unsigned int nglyph,
+                                CharInfoPtr * ppci, void *pglyphBase);
+
+extern _X_EXPORT int
+
+XAAPolyText8NonTEColorExpansion(DrawablePtr pDraw,
+                                GCPtr pGC,
+                                int x, int y, int count, char *chars);
+
+extern _X_EXPORT int
+
+XAAPolyText16NonTEColorExpansion(DrawablePtr pDraw,
+                                 GCPtr pGC,
+                                 int x, int y,
+                                 int count, unsigned short *chars);
+
+extern _X_EXPORT void
+
+XAAImageText8NonTEColorExpansion(DrawablePtr pDraw,
+                                 GCPtr pGC,
+                                 int x, int y, int count, char *chars);
+
+extern _X_EXPORT void
+
+XAAImageText16NonTEColorExpansion(DrawablePtr pDraw,
+                                  GCPtr pGC,
+                                  int x, int y,
+                                  int count, unsigned short *chars);
+
+extern _X_EXPORT void
+
+XAAImageGlyphBltNonTEColorExpansion(DrawablePtr pDrawable,
+                                    GCPtr pGC,
+                                    int xInit, int yInit,
+                                    unsigned int nglyph,
+                                    CharInfoPtr * ppci, void *pglyphBase);
+
+extern _X_EXPORT void
+
+XAAPolyGlyphBltNonTEColorExpansion(DrawablePtr pDrawable,
+                                   GCPtr pGC,
+                                   int xInit, int yInit,
+                                   unsigned int nglyph,
+                                   CharInfoPtr * ppci, void *pglyphBase);
+
+extern _X_EXPORT void XAANonTEGlyphRenderer(ScrnInfoPtr pScrn,
+                                            int x, int y, int n,
+                                            NonTEGlyphPtr glyphs,
+                                            BoxPtr pbox,
+                                            int fg, int rop,
+                                            unsigned int planemask);
+
+extern _X_EXPORT void
+
+XAAFillSolidSpans(ScrnInfoPtr pScrn,
+                  int fg, int rop,
+                  unsigned int planemask,
+                  int n, DDXPointPtr ppt, int *pwidth, int fSorted);
+
+extern _X_EXPORT void
+
+XAAFillMono8x8PatternSpans(ScrnInfoPtr pScrn,
+                           int fg, int bg, int rop,
+                           unsigned int planemask,
+                           int n,
+                           DDXPointPtr ppt,
+                           int *pwidth, int fSorted,
+                           int patx, int paty, int xorg, int yorg);
+
+extern _X_EXPORT void
+
+XAAFillMono8x8PatternSpansScreenOrigin(ScrnInfoPtr pScrn,
+                                       int fg, int bg, int rop,
+                                       unsigned int planemask,
+                                       int n,
+                                       DDXPointPtr ppt,
+                                       int *pwidth, int fSorted,
+                                       int patx, int paty, int xorg, int yorg);
+
+extern _X_EXPORT void
+
+XAAFillColor8x8PatternSpansScreenOrigin(ScrnInfoPtr pScrn,
+                                        int rop,
+                                        unsigned int planemask,
+                                        int n,
+                                        DDXPointPtr ppt,
+                                        int *pwidth, int fSorted,
+                                        XAACacheInfoPtr,
+                                        int xorigin, int yorigin);
+
+extern _X_EXPORT void
+
+XAAFillColor8x8PatternSpans(ScrnInfoPtr pScrn,
+                            int rop,
+                            unsigned int planemask,
+                            int n,
+                            DDXPointPtr ppt,
+                            int *pwidth, int fSorted,
+                            XAACacheInfoPtr, int xorigin, int yorigin);
+
+extern _X_EXPORT void
+
+XAAFillCacheBltSpans(ScrnInfoPtr pScrn,
+                     int rop,
+                     unsigned int planemask,
+                     int n,
+                     DDXPointPtr points,
+                     int *widths,
+                     int fSorted, XAACacheInfoPtr pCache, int xorg, int yorg);
+
+extern _X_EXPORT void
+
+XAAFillCacheExpandSpans(ScrnInfoPtr pScrn,
+                        int fg, int bg, int rop,
+                        unsigned int planemask,
+                        int n,
+                        DDXPointPtr ppt,
+                        int *pwidth,
+                        int fSorted, int xorg, int yorg, PixmapPtr pPix);
+
+extern _X_EXPORT void
+
+XAAFillSpans(DrawablePtr pDrawable,
+             GC * pGC,
+             int nInit, DDXPointPtr pptInit, int *pwidth, int fSorted);
+
+extern _X_EXPORT void
+ XAAInitPixmapCache(ScreenPtr pScreen, RegionPtr areas, void *data);
+
+extern _X_EXPORT void
+
+XAAWriteBitmapToCache(ScrnInfoPtr pScrn,
+                      int x, int y, int w, int h,
+                      unsigned char *src, int srcwidth, int fg, int bg);
+
+extern _X_EXPORT void
+
+XAAWriteBitmapToCacheLinear(ScrnInfoPtr pScrn,
+                            int x, int y, int w, int h,
+                            unsigned char *src, int srcwidth, int fg, int bg);
+
+extern _X_EXPORT void
+
+XAAWritePixmapToCache(ScrnInfoPtr pScrn,
+                      int x, int y, int w, int h,
+                      unsigned char *src, int srcwidth, int bpp, int depth);
+
+extern _X_EXPORT void
+
+XAAWritePixmapToCacheLinear(ScrnInfoPtr pScrn,
+                            int x, int y, int w, int h,
+                            unsigned char *src,
+                            int srcwidth, int bpp, int depth);
+
+extern _X_EXPORT void
+ XAASolidHorVertLineAsRects(ScrnInfoPtr pScrn, int x, int y, int len, int dir);
+
+extern _X_EXPORT void
+
+XAASolidHorVertLineAsTwoPoint(ScrnInfoPtr pScrn,
+                              int x, int y, int len, int dir);
+
+extern _X_EXPORT void
+
+XAASolidHorVertLineAsBresenham(ScrnInfoPtr pScrn,
+                               int x, int y, int len, int dir);
+
+extern _X_EXPORT void
+
+XAAPolyRectangleThinSolid(DrawablePtr pDrawable,
+                          GCPtr pGC, int nRectsInit, xRectangle *pRectsInit);
+
+extern _X_EXPORT void
+
+XAAPolylinesWideSolid(DrawablePtr pDrawable,
+                      GCPtr pGC, int mode, int npt, DDXPointPtr pPts);
+
+extern _X_EXPORT void
+
+XAAFillPolygonSolid(DrawablePtr pDrawable,
+                    GCPtr pGC,
+                    int shape, int mode, int count, DDXPointPtr ptsIn);
+
+extern _X_EXPORT void
+
+XAAFillPolygonStippled(DrawablePtr pDrawable,
+                       GCPtr pGC,
+                       int shape, int mode, int count, DDXPointPtr ptsIn);
+
+extern _X_EXPORT void
+
+XAAFillPolygonTiled(DrawablePtr pDrawable,
+                    GCPtr pGC,
+                    int shape, int mode, int count, DDXPointPtr ptsIn);
+
+extern _X_EXPORT int
+
+XAAIsEasyPolygon(DDXPointPtr ptsIn,
+                 int count,
+                 BoxPtr extents,
+                 int origin,
+                 DDXPointPtr * topPoint, int *topY, int *bottomY, int shape);
+
+extern _X_EXPORT void
+
+XAAFillPolygonHelper(ScrnInfoPtr pScrn,
+                     DDXPointPtr ptsIn,
+                     int count,
+                     DDXPointPtr topPoint,
+                     int y,
+                     int maxy,
+                     int origin,
+                     RectFuncPtr RectFunc,
+                     TrapFuncPtr TrapFunc,
+                     int xorg, int yorg, XAACacheInfoPtr pCache);
+
+extern _X_EXPORT void
+ XAAPolySegment(DrawablePtr pDrawable, GCPtr pGC, int nseg, xSegment * pSeg);
+
+extern _X_EXPORT void
+
+XAAPolyLines(DrawablePtr pDrawable,
+             GCPtr pGC, int mode, int npt, DDXPointPtr pptInit);
+
+extern _X_EXPORT void
+
+XAAPolySegmentDashed(DrawablePtr pDrawable,
+                     GCPtr pGC, int nseg, xSegment * pSeg);
+
+extern _X_EXPORT void
+
+XAAPolyLinesDashed(DrawablePtr pDrawable,
+                   GCPtr pGC, int mode, int npt, DDXPointPtr pptInit);
+
+extern _X_EXPORT void
+ XAAWriteMono8x8PatternToCache(ScrnInfoPtr pScrn, XAACacheInfoPtr pCache);
+
+extern _X_EXPORT void
+
+XAAWriteColor8x8PatternToCache(ScrnInfoPtr pScrn,
+                               PixmapPtr pPix, XAACacheInfoPtr pCache);
+
+extern _X_EXPORT void
+
+XAARotateMonoPattern(int *pat0, int *pat1,
+                     int xoffset, int yoffset, Bool msbfirst);
+
+extern _X_EXPORT void XAAComputeDash(GCPtr pGC);
+
+extern _X_EXPORT void XAAMoveDWORDS_FixedBase(register CARD32 *dest,
+                                              register CARD32 *src,
+                                              register int dwords);
+
+extern _X_EXPORT void XAAMoveDWORDS_FixedSrc(register CARD32 *dest,
+                                             register CARD32 *src,
+                                             register int dwords);
+
+extern _X_EXPORT void XAAMoveDWORDS(register CARD32 *dest,
+                                    register CARD32 *src, register int dwords);
+
+extern _X_EXPORT int
+
+XAAGetRectClipBoxes(GCPtr pGC,
+                    BoxPtr pboxClippedBase,
+                    int nrectFill, xRectangle *prectInit);
+
+extern _X_EXPORT void
+ XAASetupOverlay8_32Planar(ScreenPtr);
+
+extern _X_EXPORT void
+ XAAPolyFillArcSolid(DrawablePtr pDraw, GCPtr pGC, int narcs, xArc * parcs);
+
+extern _X_EXPORT XAACacheInfoPtr XAACacheTile(ScrnInfoPtr Scrn, PixmapPtr pPix);
+
+extern _X_EXPORT XAACacheInfoPtr
+XAACacheMonoStipple(ScrnInfoPtr Scrn, PixmapPtr pPix);
+
+extern _X_EXPORT XAACacheInfoPtr
+XAACachePlanarMonoStipple(ScrnInfoPtr Scrn, PixmapPtr pPix);
+
+typedef XAACacheInfoPtr(*XAACachePlanarMonoStippleProc) (ScrnInfoPtr,
+                                                         PixmapPtr);
+extern _X_EXPORT XAACachePlanarMonoStippleProc
+XAAGetCachePlanarMonoStipple(void);
+
+extern _X_EXPORT XAACacheInfoPtr
+XAACacheStipple(ScrnInfoPtr Scrn, PixmapPtr pPix, int fg, int bg);
+
+extern _X_EXPORT XAACacheInfoPtr
+XAACacheMono8x8Pattern(ScrnInfoPtr Scrn, int pat0, int pat1);
+
+extern _X_EXPORT XAACacheInfoPtr
+XAACacheColor8x8Pattern(ScrnInfoPtr Scrn, PixmapPtr pPix, int fg, int bg);
+
+extern _X_EXPORT void
+ XAATileCache(ScrnInfoPtr pScrn, XAACacheInfoPtr pCache, int w, int h);
+
+extern _X_EXPORT void XAAClosePixmapCache(ScreenPtr pScreen);
+void XAAInvalidatePixmapCache(ScreenPtr pScreen);
+
+extern _X_EXPORT Bool XAACheckStippleReducibility(PixmapPtr pPixmap);
+extern _X_EXPORT Bool XAACheckTileReducibility(PixmapPtr pPixmap,
+                                               Bool checkMono);
+
+extern _X_EXPORT int XAAStippledFillChooser(GCPtr pGC);
+extern _X_EXPORT int XAAOpaqueStippledFillChooser(GCPtr pGC);
+extern _X_EXPORT int XAATiledFillChooser(GCPtr pGC);
+
+extern _X_EXPORT void XAAMoveInOffscreenPixmaps(ScreenPtr pScreen);
+extern _X_EXPORT void XAAMoveOutOffscreenPixmaps(ScreenPtr pScreen);
+extern _X_EXPORT void XAARemoveAreaCallback(FBAreaPtr area);
+extern _X_EXPORT void XAAMoveOutOffscreenPixmap(PixmapPtr pPix);
+extern _X_EXPORT Bool XAAInitStateWrap(ScreenPtr pScreen,
+                                       XAAInfoRecPtr infoRec);
+
+extern _X_EXPORT void
+
+XAAComposite(CARD8 op,
+             PicturePtr pSrc,
+             PicturePtr pMask,
+             PicturePtr pDst,
+             INT16 xSrc,
+             INT16 ySrc,
+             INT16 xMask,
+             INT16 yMask, INT16 xDst, INT16 yDst, CARD16 width, CARD16 height);
+
+extern _X_EXPORT Bool
+
+XAADoComposite(CARD8 op,
+               PicturePtr pSrc,
+               PicturePtr pMask,
+               PicturePtr pDst,
+               INT16 xSrc,
+               INT16 ySrc,
+               INT16 xMask,
+               INT16 yMask,
+               INT16 xDst, INT16 yDst, CARD16 width, CARD16 height);
+
+extern _X_EXPORT void
+
+XAAGlyphs(CARD8 op,
+          PicturePtr pSrc,
+          PicturePtr pDst,
+          PictFormatPtr maskFormat,
+          INT16 xSrc,
+          INT16 ySrc, int nlist, GlyphListPtr list, GlyphPtr * glyphs);
+
+extern _X_EXPORT Bool
+
+XAADoGlyphs(CARD8 op,
+            PicturePtr pSrc,
+            PicturePtr pDst,
+            PictFormatPtr maskFormat,
+            INT16 xSrc,
+            INT16 ySrc, int nlist, GlyphListPtr list, GlyphPtr * glyphs);
+
+/* helpers */
+extern _X_EXPORT void
+ XAA_888_plus_PICT_a8_to_8888(CARD32 color, CARD8 *alphaPtr,    /* in bytes */
+                              int alphaPitch, CARD32 *dstPtr, int dstPitch,     /* in dwords */
+                              int width, int height);
+
+extern _X_EXPORT Bool
+
+XAAGetRGBAFromPixel(CARD32 pixel,
+                    CARD16 *red,
+                    CARD16 *green, CARD16 *blue, CARD16 *alpha, CARD32 format);
+
+extern _X_EXPORT Bool
+
+XAAGetPixelFromRGBA(CARD32 *pixel,
+                    CARD16 red,
+                    CARD16 green, CARD16 blue, CARD16 alpha, CARD32 format);
+
+/* XXX should be static */
+extern _X_EXPORT GCOps XAAFallbackOps;
+extern _X_EXPORT GCOps *XAAGetFallbackOps(void);
+extern _X_EXPORT GCFuncs XAAGCFuncs;
+extern _X_EXPORT DevPrivateKey XAAGetScreenKey(void);
+extern _X_EXPORT DevPrivateKey XAAGetGCKey(void);
+extern _X_EXPORT DevPrivateKey XAAGetPixmapKey(void);
+
+extern _X_EXPORT unsigned int XAAShiftMasks[32];
+
+extern _X_EXPORT unsigned int byte_expand3[256], byte_reversed_expand3[256];
+
+extern _X_EXPORT CARD32 XAAReverseBitOrder(CARD32 data);
+
+#define GET_XAASCREENPTR_FROM_SCREEN(pScreen)\
+    dixLookupPrivate(&(pScreen)->devPrivates, XAAGetScreenKey())
+
+#define GET_XAASCREENPTR_FROM_GC(pGC)\
+    dixLookupPrivate(&(pGC)->pScreen->devPrivates, XAAGetScreenKey())
+
+#define GET_XAASCREENPTR_FROM_DRAWABLE(pDraw)\
+    dixLookupPrivate(&(pDraw)->pScreen->devPrivates, XAAGetScreenKey())
+
+#define GET_XAAINFORECPTR_FROM_SCREEN(pScreen)\
+((XAAScreenPtr)dixLookupPrivate(&(pScreen)->devPrivates, XAAGetScreenKey()))->AccelInfoRec
+
+#define GET_XAAINFORECPTR_FROM_GC(pGC)\
+((XAAScreenPtr)dixLookupPrivate(&(pGC)->pScreen->devPrivates, XAAGetScreenKey()))->AccelInfoRec
+
+#define GET_XAAINFORECPTR_FROM_DRAWABLE(pDraw)\
+((XAAScreenPtr)dixLookupPrivate(&(pDraw)->pScreen->devPrivates, XAAGetScreenKey()))->AccelInfoRec
+
+#define GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn)\
+((XAAScreenPtr)dixLookupPrivate(&(pScrn)->pScreen->devPrivates, XAAGetScreenKey()))->AccelInfoRec
+
+#define XAA_GET_PIXMAP_PRIVATE(pix)\
+    (XAAPixmapPtr)dixLookupPrivate(&(pix)->devPrivates, XAAGetPixmapKey())
+
+#define CHECK_RGB_EQUAL(c) (!((((c) >> 8) ^ (c)) & 0xffff))
+
+#define CHECK_FG(pGC, flags) \
+	(!(flags & RGB_EQUAL) || CHECK_RGB_EQUAL(pGC->fgPixel))
+
+#define CHECK_BG(pGC, flags) \
+	(!(flags & RGB_EQUAL) || CHECK_RGB_EQUAL(pGC->bgPixel))
+
+#define CHECK_ROP(pGC, flags) \
+	(!(flags & GXCOPY_ONLY) || (pGC->alu == GXcopy))
+
+#define CHECK_ROPSRC(pGC, flags) \
+	(!(flags & ROP_NEEDS_SOURCE) || ((pGC->alu != GXclear) && \
+	(pGC->alu != GXnoop) && (pGC->alu != GXinvert) && \
+	(pGC->alu != GXset)))
+
+#define CHECK_PLANEMASK(pGC, flags) \
+	(!(flags & NO_PLANEMASK) || \
+	((pGC->planemask & infoRec->FullPlanemasks[pGC->depth - 1]) == \
+          infoRec->FullPlanemasks[pGC->depth - 1]))
+
+#define CHECK_COLORS(pGC, flags) \
+	(!(flags & RGB_EQUAL) || \
+	(CHECK_RGB_EQUAL(pGC->fgPixel) && CHECK_RGB_EQUAL(pGC->bgPixel)))
+
+#define CHECK_NO_GXCOPY(pGC, flags) \
+	((pGC->alu != GXcopy) || !(flags & NO_GXCOPY) || \
+	((pGC->planemask & infoRec->FullPlanemask) != infoRec->FullPlanemask))
+
+#define IS_OFFSCREEN_PIXMAP(pPix)\
+        ((XAA_GET_PIXMAP_PRIVATE((PixmapPtr)(pPix)))->offscreenArea)
+
+#define PIXMAP_IS_SHARED(pPix)\
+        ((XAA_GET_PIXMAP_PRIVATE((PixmapPtr)(pPix)))->flags & SHARED_PIXMAP)
+
+#define OFFSCREEN_PIXMAP_LOCKED(pPix)\
+        ((XAA_GET_PIXMAP_PRIVATE((PixmapPtr)(pPix)))->flags & LOCKED_PIXMAP)
+
+#define XAA_DEPTH_BUG(pGC) \
+        ((pGC->depth == 32) && (pGC->bgPixel == 0xffffffff))
+
+#define DELIST_OFFSCREEN_PIXMAP(pPix) { \
+	PixmapLinkPtr _pLink, _prev; \
+	_pLink = infoRec->OffscreenPixmaps; \
+	_prev = NULL; \
+	while(_pLink) { \
+	    if(_pLink->pPix == pPix) { \
+		if(_prev) _prev->next = _pLink->next; \
+		else infoRec->OffscreenPixmaps = _pLink->next; \
+		free(_pLink); \
+		break; \
+	    } \
+	    _prev = _pLink; \
+	    _pLink = _pLink->next; \
+        }}
+
+#define SWAP_BITS_IN_BYTES(v) \
+ (((0x01010101 & (v)) << 7) | ((0x02020202 & (v)) << 5) | \
+  ((0x04040404 & (v)) << 3) | ((0x08080808 & (v)) << 1) | \
+  ((0x10101010 & (v)) >> 1) | ((0x20202020 & (v)) >> 3) | \
+  ((0x40404040 & (v)) >> 5) | ((0x80808080 & (v)) >> 7))
+
+/*
+ * Moved XAAPixmapCachePrivate here from xaaPCache.c, since driver
+ * replacements for CacheMonoStipple need access to it
+ */
+
+typedef struct {
+    int Num512x512;
+    int Current512;
+    XAACacheInfoPtr Info512;
+    int Num256x256;
+    int Current256;
+    XAACacheInfoPtr Info256;
+    int Num128x128;
+    int Current128;
+    XAACacheInfoPtr Info128;
+    int NumMono;
+    int CurrentMono;
+    XAACacheInfoPtr InfoMono;
+    int NumColor;
+    int CurrentColor;
+    XAACacheInfoPtr InfoColor;
+    int NumPartial;
+    int CurrentPartial;
+    XAACacheInfoPtr InfoPartial;
+    DDXPointRec MonoOffsets[64];
+    DDXPointRec ColorOffsets[64];
+} XAAPixmapCachePrivate, *XAAPixmapCachePrivatePtr;
+
+#endif                          /* _XAALOCAL_H */
diff --git a/hw/xfree86/xaa/xaarop.h b/hw/xfree86/xaa/xaarop.h
new file mode 100644
index 000000000..84aa9baba
--- /dev/null
+++ b/hw/xfree86/xaa/xaarop.h
@@ -0,0 +1,268 @@
+#ifndef _XAAROP_H
+#define _XAAROP_H
+
+#define ROP_DST		0x00000001
+#define ROP_SRC		0x00000002
+#define ROP_PAT		0x00000004
+
+#define ROP_0		0x00
+#define ROP_DPSoon	0x01
+#define ROP_DPSona	0x02
+#define ROP_PSon	0x03
+#define ROP_SDPona	0x04
+#define ROP_DPon	0x05
+#define ROP_PDSxnon	0x06
+#define ROP_PDSaon	0x07
+#define ROP_SDPnaa	0x08
+#define ROP_PDSxon	0x09
+#define ROP_DPna	0x0A
+#define ROP_PSDnaon	0x0B
+#define ROP_SPna	0x0C
+#define ROP_PDSnaon	0x0D
+#define ROP_PDSonon	0x0E
+#define ROP_Pn		0x0F
+#define ROP_PDSona	0x10
+#define ROP_DSon	0x11
+#define ROP_SDPxnon	0x12
+#define ROP_SDPaon	0x13
+#define ROP_DPSxnon	0x14
+#define ROP_DPSaon	0x15
+#define ROP_PSDPSanaxx	0x16
+#define ROP_SSPxDSxaxn	0x17
+#define ROP_SPxPDxa	0x18
+#define ROP_SDPSanaxn	0x19
+#define ROP_PDSPaox	0x1A
+#define ROP_SDPSxaxn	0x1B
+#define ROP_PSDPaox	0x1C
+#define ROP_DSPDxaxn	0x1D
+#define ROP_PDSox	0x1E
+#define ROP_PDSoan	0x1F
+#define ROP_DPSnaa	0x20
+#define ROP_SDPxon	0x21
+#define ROP_DSna	0x22
+#define ROP_SPDnaon	0x23
+#define ROP_SPxDSxa	0x24
+#define ROP_PDSPanaxn	0x25
+#define ROP_SDPSaox	0x26
+#define ROP_SDPSxnox	0x27
+#define ROP_DPSxa	0x28
+#define ROP_PSDPSaoxxn	0x29
+#define ROP_DPSana	0x2A
+#define ROP_SSPxPDxaxn	0x2B
+#define ROP_SPDSoax	0x2C
+#define ROP_PSDnox	0x2D
+#define ROP_PSDPxox	0x2E
+#define ROP_PSDnoan	0x2F
+#define ROP_PSna	0x30
+#define ROP_SDPnaon	0x31
+#define ROP_SDPSoox	0x32
+#define ROP_Sn		0x33
+#define ROP_SPDSaox	0x34
+#define ROP_SPDSxnox	0x35
+#define ROP_SDPox	0x36
+#define ROP_SDPoan	0x37
+#define ROP_PSDPoax	0x38
+#define ROP_SPDnox	0x39
+#define ROP_SPDSxox	0x3A
+#define ROP_SPDnoan	0x3B
+#define ROP_PSx		0x3C
+#define ROP_SPDSonox	0x3D
+#define ROP_SPDSnaox	0x3E
+#define ROP_PSan	0x3F
+#define ROP_PSDnaa	0x40
+#define ROP_DPSxon	0x41
+#define ROP_SDxPDxa	0x42
+#define ROP_SPDSanaxn	0x43
+#define ROP_SDna	0x44
+#define ROP_DPSnaon	0x45
+#define ROP_DSPDaox	0x46
+#define ROP_PSDPxaxn	0x47
+#define ROP_SDPxa	0x48
+#define ROP_PDSPDaoxxn	0x49
+#define ROP_DPSDoax	0x4A
+#define ROP_PDSnox	0x4B
+#define ROP_SDPana	0x4C
+#define ROP_SSPxDSxoxn	0x4D
+#define ROP_PDSPxox	0x4E
+#define ROP_PDSnoan	0x4F
+#define ROP_PDna	0x50
+#define ROP_DSPnaon	0x51
+#define ROP_DPSDaox	0x52
+#define ROP_SPDSxaxn	0x53
+#define ROP_DPSonon	0x54
+#define ROP_Dn		0x55
+#define ROP_DPSox	0x56
+#define ROP_DPSoan	0x57
+#define ROP_PDSPoax	0x58
+#define ROP_DPSnox	0x59
+#define ROP_DPx		0x5A
+#define ROP_DPSDonox	0x5B
+#define ROP_DPSDxox	0x5C
+#define ROP_DPSnoan	0x5D
+#define ROP_DPSDnaox	0x5E
+#define ROP_DPan	0x5F
+#define ROP_PDSxa	0x60
+#define ROP_DSPDSaoxxn	0x61
+#define ROP_DSPDoax	0x62
+#define ROP_SDPnox	0x63
+#define ROP_SDPSoax	0x64
+#define ROP_DSPnox	0x65
+#define ROP_DSx		0x66
+#define ROP_SDPSonox	0x67
+#define ROP_DSPDSonoxxn	0x68
+#define ROP_PDSxxn	0x69
+#define ROP_DPSax	0x6A
+#define ROP_PSDPSoaxxn	0x6B
+#define ROP_SDPax	0x6C
+#define ROP_PDSPDoaxxn	0x6D
+#define ROP_SDPSnoax	0x6E
+#define ROP_PDSxnan	0x6F
+#define ROP_PDSana	0x70
+#define ROP_SSDxPDxaxn	0x71
+#define ROP_SDPSxox	0x72
+#define ROP_SDPnoan	0x73
+#define ROP_DSPDxox	0x74
+#define ROP_DSPnoan	0x75
+#define ROP_SDPSnaox	0x76
+#define ROP_DSan	0x77
+#define ROP_PDSax	0x78
+#define ROP_DSPDSoaxxn	0x79
+#define ROP_DPSDnoax	0x7A
+#define ROP_SDPxnan	0x7B
+#define ROP_SPDSnoax	0x7C
+#define ROP_DPSxnan	0x7D
+#define ROP_SPxDSxo	0x7E
+#define ROP_DPSaan	0x7F
+#define ROP_DPSaa	0x80
+#define ROP_SPxDSxon	0x81
+#define ROP_DPSxna	0x82
+#define ROP_SPDSnoaxn	0x83
+#define ROP_SDPxna	0x84
+#define ROP_PDSPnoaxn	0x85
+#define ROP_DSPDSoaxx	0x86
+#define ROP_PDSaxn	0x87
+#define ROP_DSa		0x88
+#define ROP_SDPSnaoxn	0x89
+#define ROP_DSPnoa	0x8A
+#define ROP_DSPDxoxn	0x8B
+#define ROP_SDPnoa	0x8C
+#define ROP_SDPSxoxn	0x8D
+#define ROP_SSDxPDxax	0x8E
+#define ROP_PDSanan	0x8F
+#define ROP_PDSxna	0x90
+#define ROP_SDPSnoaxn	0x91
+#define ROP_DPSDPoaxx	0x92
+#define ROP_SPDaxn	0x93
+#define ROP_PSDPSoaxx	0x94
+#define ROP_DPSaxn	0x95
+#define ROP_DPSxx	0x96
+#define ROP_PSDPSonoxx	0x97
+#define ROP_SDPSonoxn	0x98
+#define ROP_DSxn	0x99
+#define ROP_DPSnax	0x9A
+#define ROP_SDPSoaxn	0x9B
+#define ROP_SPDnax	0x9C
+#define ROP_DSPDoaxn	0x9D
+#define ROP_DSPDSaoxx	0x9E
+#define ROP_PDSxan	0x9F
+#define ROP_DPa		0xA0
+#define ROP_PDSPnaoxn	0xA1
+#define ROP_DPSnoa	0xA2
+#define ROP_DPSDxoxn	0xA3
+#define ROP_PDSPonoxn	0xA4
+#define ROP_PDxn	0xA5
+#define ROP_DSPnax	0xA6
+#define ROP_PDSPoaxn	0xA7
+#define ROP_DPSoa	0xA8
+#define ROP_DPSoxn	0xA9
+#define ROP_D		0xAA
+#define ROP_DPSono	0xAB
+#define ROP_SPDSxax	0xAC
+#define ROP_DPSDaoxn	0xAD
+#define ROP_DSPnao	0xAE
+#define ROP_DPno	0xAF
+#define ROP_PDSnoa	0xB0
+#define ROP_PDSPxoxn	0xB1
+#define ROP_SSPxDSxox	0xB2
+#define ROP_SDPanan	0xB3
+#define ROP_PSDnax	0xB4
+#define ROP_DPSDoaxn	0xB5
+#define ROP_DPSDPaoxx	0xB6
+#define ROP_SDPxan	0xB7
+#define ROP_PSDPxax	0xB8
+#define ROP_DSPDaoxn	0xB9
+#define ROP_DPSnao	0xBA
+#define ROP_DSno	0xBB
+#define ROP_SPDSanax	0xBC
+#define ROP_SDxPDxan	0xBD
+#define ROP_DPSxo	0xBE
+#define ROP_DPSano	0xBF
+#define ROP_Psa		0xC0
+#define ROP_SPDSnaoxn	0xC1
+#define ROP_SPDSonoxn	0xC2
+#define ROP_PSxn	0xC3
+#define ROP_SPDnoa	0xC4
+#define ROP_SPDSxoxn	0xC5
+#define ROP_SDPnax	0xC6
+#define ROP_PSDPoaxn	0xC7
+#define ROP_SDPoa	0xC8
+#define ROP_SPDoxn	0xC9
+#define ROP_DPSDxax	0xCA
+#define ROP_SPDSaoxn	0xCB
+#define ROP_S		0xCC
+#define ROP_SDPono	0xCD
+#define ROP_SDPnao	0xCE
+#define ROP_SPno	0xCF
+#define ROP_PSDnoa	0xD0
+#define ROP_PSDPxoxn	0xD1
+#define ROP_PDSnax	0xD2
+#define ROP_SPDSoaxn	0xD3
+#define ROP_SSPxPDxax	0xD4
+#define ROP_DPSanan	0xD5
+#define ROP_PSDPSaoxx	0xD6
+#define ROP_DPSxan	0xD7
+#define ROP_PDSPxax	0xD8
+#define ROP_SDPSaoxn	0xD9
+#define ROP_DPSDanax	0xDA
+#define ROP_SPxDSxan	0xDB
+#define ROP_SPDnao	0xDC
+#define ROP_SDno	0xDD
+#define ROP_SDPxo	0xDE
+#define ROP_SDPano	0xDF
+#define ROP_PDSoa	0xE0
+#define ROP_PDSoxn	0xE1
+#define ROP_DSPDxax	0xE2
+#define ROP_PSDPaoxn	0xE3
+#define ROP_SDPSxax	0xE4
+#define ROP_PDSPaoxn	0xE5
+#define ROP_SDPSanax	0xE6
+#define ROP_SPxPDxan	0xE7
+#define ROP_SSPxDSxax	0xE8
+#define ROP_DSPDSanaxxn	0xE9
+#define ROP_DPSao	0xEA
+#define ROP_DPSxno	0xEB
+#define ROP_SDPao	0xEC
+#define ROP_SDPxno	0xED
+#define ROP_DSo		0xEE
+#define ROP_SDPnoo	0xEF
+#define ROP_P		0xF0
+#define ROP_PDSono	0xF1
+#define ROP_PDSnao	0xF2
+#define ROP_PSno	0xF3
+#define ROP_PSDnao	0xF4
+#define ROP_PDno	0xF5
+#define ROP_PDSxo	0xF6
+#define ROP_PDSano	0xF7
+#define ROP_PDSao	0xF8
+#define ROP_PDSxno	0xF9
+#define ROP_DPo		0xFA
+#define ROP_DPSnoo	0xFB
+#define ROP_PSo		0xFC
+#define ROP_PSDnoo	0xFD
+#define ROP_DPSoo	0xFE
+#define ROP_1		0xFF
+
+#define NO_SRC_ROP(rop) \
+   ((rop == GXnoop) || (rop == GXset) || (rop == GXclear) || (rop == GXinvert))
+
+#endif                          /* _XAAROP_H */
diff --git a/hw/xfree86/xaa/xaawrap.h b/hw/xfree86/xaa/xaawrap.h
new file mode 100644
index 000000000..2d2d7881a
--- /dev/null
+++ b/hw/xfree86/xaa/xaawrap.h
@@ -0,0 +1,75 @@
+
+#define XAA_SCREEN_PROLOGUE(pScreen, field)\
+  ((pScreen)->field = \
+   ((XAAScreenPtr)dixLookupPrivate(&(pScreen)->devPrivates, XAAGetScreenKey()))->field)
+
+#define XAA_SCREEN_EPILOGUE(pScreen, field, wrapper)\
+    ((pScreen)->field = wrapper)
+
+#define XAA_GC_FUNC_PROLOGUE(pGC)\
+    XAAGCPtr pGCPriv = (XAAGCPtr)dixLookupPrivate(&(pGC)->devPrivates, XAAGetGCKey()); \
+    (pGC)->funcs = pGCPriv->wrapFuncs;\
+    if(pGCPriv->flags)\
+	(pGC)->ops = pGCPriv->wrapOps
+
+#define XAA_GC_FUNC_EPILOGUE(pGC)\
+    pGCPriv->wrapFuncs = (pGC)->funcs;\
+    (pGC)->funcs = &XAAGCFuncs;\
+    if(pGCPriv->flags) {\
+	pGCPriv->wrapOps = (pGC)->ops;\
+	(pGC)->ops = (pGCPriv->flags & OPS_ARE_ACCEL) ? pGCPriv->XAAOps :\
+				&XAAPixmapOps;\
+    }
+
+#define XAA_GC_OP_PROLOGUE(pGC)\
+    XAAGCPtr pGCPriv = (XAAGCPtr)dixLookupPrivate(&(pGC)->devPrivates, XAAGetGCKey()); \
+    GCFuncs *oldFuncs = pGC->funcs;\
+    pGC->funcs = pGCPriv->wrapFuncs;\
+    pGC->ops = pGCPriv->wrapOps
+
+#define XAA_GC_OP_PROLOGUE_WITH_RETURN(pGC)\
+    XAAGCPtr pGCPriv = (XAAGCPtr)dixLookupPrivate(&(pGC)->devPrivates, XAAGetGCKey()); \
+    GCFuncs *oldFuncs = pGC->funcs;\
+    if(!RegionNumRects(pGC->pCompositeClip)) return; \
+    pGC->funcs = pGCPriv->wrapFuncs;\
+    pGC->ops = pGCPriv->wrapOps
+
+#define XAA_GC_OP_EPILOGUE(pGC)\
+    pGCPriv->wrapOps = pGC->ops;\
+    pGC->funcs = oldFuncs;\
+    pGC->ops   = pGCPriv->XAAOps
+
+#define XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw)\
+    XAAGCPtr pGCPriv = (XAAGCPtr)dixLookupPrivate(&(pGC)->devPrivates, XAAGetGCKey()); \
+    XAAPixmapPtr pixPriv = XAA_GET_PIXMAP_PRIVATE((PixmapPtr)(pDraw));\
+    GCFuncs *oldFuncs = pGC->funcs;\
+    pGC->funcs = pGCPriv->wrapFuncs;\
+    pGC->ops = pGCPriv->wrapOps; \
+    SYNC_CHECK(pGC)
+
+#define XAA_PIXMAP_OP_EPILOGUE(pGC)\
+    pGCPriv->wrapOps = pGC->ops;\
+    pGC->funcs = oldFuncs;\
+    pGC->ops   = &XAAPixmapOps;\
+    pixPriv->flags |= DIRTY
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#define XAA_RENDER_PROLOGUE(pScreen,field)\
+    (GetPictureScreen(pScreen)->field = \
+     ((XAAScreenPtr)dixLookupPrivate(&(pScreen)->devPrivates, XAAGetScreenKey()))->field)
+
+#define XAA_RENDER_EPILOGUE(pScreen, field, wrapper)\
+    (GetPictureScreen(pScreen)->field = wrapper)
+
+/* This also works fine for drawables */
+
+#define SYNC_CHECK(pGC) {\
+     XAAInfoRecPtr infoRec =\
+((XAAScreenPtr)dixLookupPrivate(&(pGC)->pScreen->devPrivates, XAAGetScreenKey()))->AccelInfoRec;	\
+    if(infoRec->NeedToSync) {\
+	(*infoRec->Sync)(infoRec->pScrn);\
+	infoRec->NeedToSync = FALSE;\
+    }}
diff --git a/include/gcstruct.h b/include/gcstruct.h
index cb1b56655..bd4f918fe 100644
--- a/include/gcstruct.h
+++ b/include/gcstruct.h
@@ -254,6 +254,7 @@ typedef struct _GC {
     unsigned int arcMode:1;
     unsigned int subWindowMode:1;
     unsigned int graphicsExposures:1;
+    unsigned int clientClipType:2;      /* CT_<kind> */
     unsigned int miTranslate:1; /* should mi things translate? */
     unsigned int tileIsPixel:1; /* tile is solid pixel */
     unsigned int fExpose:1;     /* Call exposure handling */
@@ -275,8 +276,8 @@ typedef struct _GC {
     RegionPtr clientClip;
     unsigned int stateChanges; /* masked with GC_<kind> */
     unsigned int serialNumber;
-    const GCFuncs *funcs;
-    const GCOps *ops;
+    /*const*/ GCFuncs *funcs;
+    /*const*/ GCOps *ops;
     PrivateRec *devPrivates;
     RegionPtr pCompositeClip;
 } GC;
diff --git a/mi/Makefile.am b/mi/Makefile.am
index 110c3f5dd..014c7453b 100644
--- a/mi/Makefile.am
+++ b/mi/Makefile.am
@@ -42,6 +42,8 @@ libmi_la_SOURCES = 	\
 	mipushpxl.c	\
 	miscanfill.h	\
 	miscrinit.c	\
+	mispans.c \
+	mispans.h	\
 	misprite.c	\
 	misprite.h	\
 	mistruct.h	\
diff --git a/mi/mi.h b/mi/mi.h
index 2cd3066c1..9160cfcea 100644
--- a/mi/mi.h
+++ b/mi/mi.h
@@ -486,6 +486,7 @@ extern _X_EXPORT WindowPtr miSpriteTrace(SpritePtr pSprite, int x, int y);
 
 extern _X_EXPORT WindowPtr miXYToWindow(ScreenPtr pScreen, SpritePtr pSprite, int x, int y);
 
+extern _X_EXPORT void miSegregateChildren(WindowPtr pWin, RegionPtr pReg, int depth);
 /* mizerarc.c */
 
 extern _X_EXPORT void miZeroPolyArc(DrawablePtr /*pDraw */ ,
diff --git a/mi/mifillarc.c b/mi/mifillarc.c
index 888519edf..19c928361 100644
--- a/mi/mifillarc.c
+++ b/mi/mifillarc.c
@@ -50,7 +50,7 @@ Author:  Bob Scheifler, MIT X Consortium
 #define Dsin(d)	sin((double)d*(M_PI/11520.0))
 #define Dcos(d)	cos((double)d*(M_PI/11520.0))
 
-static void
+void
 miFillArcSetup(xArc * arc, miFillArcRec * info)
 {
     info->y = arc->height >> 1;
@@ -276,7 +276,7 @@ miGetPieEdge(xArc * arc, int angle, miSliceEdgePtr edge, Bool top, Bool left)
     miGetArcEdge(arc, edge, k, top, left);
 }
 
-static void
+void
 miFillArcSliceSetup(xArc * arc, miArcSliceRec * slice, GCPtr pGC)
 {
     int angle1, angle2;
diff --git a/mi/mifillarc.h b/mi/mifillarc.h
index 61ab2538d..243ec4418 100644
--- a/mi/mifillarc.h
+++ b/mi/mifillarc.h
@@ -175,4 +175,14 @@ typedef struct _miArcSlice {
 #define miFillInArcLower(slw) (((iny + dy) != 0) && \
 			       ((slw > 1) || (ine != inxk)))
 
+void miFillArcSetup(xArc * /*arc */,
+                    miFillArcRec * /*info */
+);
+
+void miFillArcSliceSetup(xArc * /*arc */,
+                         miArcSliceRec * /*slice */,
+                         GCPtr /*pGC */
+);
+
 #endif                          /* __MIFILLARC_H__ */
+
diff --git a/mi/mispans.c b/mi/mispans.c
new file mode 100644
index 000000000..0f89880e2
--- /dev/null
+++ b/mi/mispans.c
@@ -0,0 +1,530 @@
+/***********************************************************
+
+Copyright 1989, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1989 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include "misc.h"
+#include "pixmapstr.h"
+#include "gcstruct.h"
+#include "mispans.h"
+
+/*
+
+These routines maintain lists of Spans, in order to implement the
+``touch-each-pixel-once'' rules of wide lines and arcs.
+
+Written by Joel McCormack, Summer 1989.
+
+*/
+
+void
+miInitSpanGroup(SpanGroup * spanGroup)
+{
+    spanGroup->size = 0;
+    spanGroup->count = 0;
+    spanGroup->group = NULL;
+    spanGroup->ymin = MAXSHORT;
+    spanGroup->ymax = MINSHORT;
+}                               /* InitSpanGroup */
+
+#define YMIN(spans) (spans->points[0].y)
+#define YMAX(spans)  (spans->points[spans->count-1].y)
+
+static void
+miSubtractSpans(SpanGroup * spanGroup, Spans * sub)
+{
+    int i, subCount, spansCount;
+    int ymin, ymax, xmin, xmax;
+    Spans *spans;
+    DDXPointPtr subPt, spansPt;
+    int *subWid, *spansWid;
+    int extra;
+
+    ymin = YMIN(sub);
+    ymax = YMAX(sub);
+    spans = spanGroup->group;
+    for (i = spanGroup->count; i; i--, spans++) {
+        if (YMIN(spans) <= ymax && ymin <= YMAX(spans)) {
+            subCount = sub->count;
+            subPt = sub->points;
+            subWid = sub->widths;
+            spansCount = spans->count;
+            spansPt = spans->points;
+            spansWid = spans->widths;
+            extra = 0;
+            for (;;) {
+                while (spansCount && spansPt->y < subPt->y) {
+                    spansPt++;
+                    spansWid++;
+                    spansCount--;
+                }
+                if (!spansCount)
+                    break;
+                while (subCount && subPt->y < spansPt->y) {
+                    subPt++;
+                    subWid++;
+                    subCount--;
+                }
+                if (!subCount)
+                    break;
+                if (subPt->y == spansPt->y) {
+                    xmin = subPt->x;
+                    xmax = xmin + *subWid;
+                    if (xmin >= spansPt->x + *spansWid || spansPt->x >= xmax) {
+                        ;
+                    }
+                    else if (xmin <= spansPt->x) {
+                        if (xmax >= spansPt->x + *spansWid) {
+                            memmove(spansPt, spansPt + 1,
+                                    sizeof *spansPt * (spansCount - 1));
+                            memmove(spansWid, spansWid + 1,
+                                    sizeof *spansWid * (spansCount - 1));
+                            spansPt--;
+                            spansWid--;
+                            spans->count--;
+                            extra++;
+                        }
+                        else {
+                            *spansWid = *spansWid - (xmax - spansPt->x);
+                            spansPt->x = xmax;
+                        }
+                    }
+                    else {
+                        if (xmax >= spansPt->x + *spansWid) {
+                            *spansWid = xmin - spansPt->x;
+                        }
+                        else {
+                            if (!extra) {
+                                DDXPointPtr newPt;
+                                int *newwid;
+
+#define EXTRA 8
+                                newPt =
+                                    (DDXPointPtr) realloc(spans->points,
+                                                          (spans->count +
+                                                           EXTRA) *
+                                                          sizeof(DDXPointRec));
+                                if (!newPt)
+                                    break;
+                                spansPt = newPt + (spansPt - spans->points);
+                                spans->points = newPt;
+                                newwid =
+                                    (int *) realloc(spans->widths,
+                                                    (spans->count +
+                                                     EXTRA) * sizeof(int));
+                                if (!newwid)
+                                    break;
+                                spansWid = newwid + (spansWid - spans->widths);
+                                spans->widths = newwid;
+                                extra = EXTRA;
+                            }
+                            memmove(spansPt + 1, spansPt,
+                                    sizeof *spansPt * (spansCount));
+                            memmove(spansWid + 1, spansWid,
+                                    sizeof *spansWid * (spansCount));
+                            spans->count++;
+                            extra--;
+                            *spansWid = xmin - spansPt->x;
+                            spansWid++;
+                            spansPt++;
+                            *spansWid = *spansWid - (xmax - spansPt->x);
+                            spansPt->x = xmax;
+                        }
+                    }
+                }
+                spansPt++;
+                spansWid++;
+                spansCount--;
+            }
+        }
+    }
+}
+
+void
+miAppendSpans(SpanGroup * spanGroup, SpanGroup * otherGroup, Spans * spans)
+{
+    int ymin, ymax;
+    int spansCount;
+
+    spansCount = spans->count;
+    if (spansCount > 0) {
+        if (spanGroup->size == spanGroup->count) {
+            spanGroup->size = (spanGroup->size + 8) * 2;
+            spanGroup->group = (Spans *)
+                realloc(spanGroup->group, sizeof(Spans) * spanGroup->size);
+        }
+
+        spanGroup->group[spanGroup->count] = *spans;
+        (spanGroup->count)++;
+        ymin = spans->points[0].y;
+        if (ymin < spanGroup->ymin)
+            spanGroup->ymin = ymin;
+        ymax = spans->points[spansCount - 1].y;
+        if (ymax > spanGroup->ymax)
+            spanGroup->ymax = ymax;
+        if (otherGroup && otherGroup->ymin < ymax && ymin < otherGroup->ymax) {
+            miSubtractSpans(otherGroup, spans);
+        }
+    }
+    else {
+        free(spans->points);
+        free(spans->widths);
+    }
+}                               /* AppendSpans */
+
+void
+miFreeSpanGroup(SpanGroup * spanGroup)
+{
+    free(spanGroup->group);
+}
+
+static void
+QuickSortSpansX(DDXPointRec points[], int widths[], int numSpans)
+{
+    int x;
+    int i, j, m;
+    DDXPointPtr r;
+
+/* Always called with numSpans > 1 */
+/* Sorts only by x, as all y should be the same */
+
+#define ExchangeSpans(a, b)				    \
+{							    \
+    DDXPointRec 	tpt;				    \
+    int    		tw;				    \
+							    \
+    tpt = points[a]; points[a] = points[b]; points[b] = tpt;    \
+    tw = widths[a]; widths[a] = widths[b]; widths[b] = tw;  \
+}
+
+    do {
+        if (numSpans < 9) {
+            /* Do insertion sort */
+            int xprev;
+
+            xprev = points[0].x;
+            i = 1;
+            do {                /* while i != numSpans */
+                x = points[i].x;
+                if (xprev > x) {
+                    /* points[i] is out of order.  Move into proper location. */
+                    DDXPointRec tpt;
+                    int tw, k;
+
+                    for (j = 0; x >= points[j].x; j++) {
+                    }
+                    tpt = points[i];
+                    tw = widths[i];
+                    for (k = i; k != j; k--) {
+                        points[k] = points[k - 1];
+                        widths[k] = widths[k - 1];
+                    }
+                    points[j] = tpt;
+                    widths[j] = tw;
+                    x = points[i].x;
+                }               /* if out of order */
+                xprev = x;
+                i++;
+            } while (i != numSpans);
+            return;
+        }
+
+        /* Choose partition element, stick in location 0 */
+        m = numSpans / 2;
+        if (points[m].x > points[0].x)
+            ExchangeSpans(m, 0);
+        if (points[m].x > points[numSpans - 1].x)
+            ExchangeSpans(m, numSpans - 1);
+        if (points[m].x > points[0].x)
+            ExchangeSpans(m, 0);
+        x = points[0].x;
+
+        /* Partition array */
+        i = 0;
+        j = numSpans;
+        do {
+            r = &(points[i]);
+            do {
+                r++;
+                i++;
+            } while (i != numSpans && r->x < x);
+            r = &(points[j]);
+            do {
+                r--;
+                j--;
+            } while (x < r->x);
+            if (i < j)
+                ExchangeSpans(i, j);
+        } while (i < j);
+
+        /* Move partition element back to middle */
+        ExchangeSpans(0, j);
+
+        /* Recurse */
+        if (numSpans - j - 1 > 1)
+            QuickSortSpansX(&points[j + 1], &widths[j + 1], numSpans - j - 1);
+        numSpans = j;
+    } while (numSpans > 1);
+}                               /* QuickSortSpans */
+
+static int
+UniquifySpansX(Spans * spans, DDXPointRec * newPoints, int *newWidths)
+{
+    int newx1, newx2, oldpt, i, y;
+    DDXPointRec *oldPoints;
+    int *oldWidths;
+    int *startNewWidths;
+
+/* Always called with numSpans > 1 */
+/* Uniquify the spans, and stash them into newPoints and newWidths.  Return the
+   number of unique spans. */
+
+    startNewWidths = newWidths;
+
+    oldPoints = spans->points;
+    oldWidths = spans->widths;
+
+    y = oldPoints->y;
+    newx1 = oldPoints->x;
+    newx2 = newx1 + *oldWidths;
+
+    for (i = spans->count - 1; i != 0; i--) {
+        oldPoints++;
+        oldWidths++;
+        oldpt = oldPoints->x;
+        if (oldpt > newx2) {
+            /* Write current span, start a new one */
+            newPoints->x = newx1;
+            newPoints->y = y;
+            *newWidths = newx2 - newx1;
+            newPoints++;
+            newWidths++;
+            newx1 = oldpt;
+            newx2 = oldpt + *oldWidths;
+        }
+        else {
+            /* extend current span, if old extends beyond new */
+            oldpt = oldpt + *oldWidths;
+            if (oldpt > newx2)
+                newx2 = oldpt;
+        }
+    }                           /* for */
+
+    /* Write final span */
+    newPoints->x = newx1;
+    *newWidths = newx2 - newx1;
+    newPoints->y = y;
+
+    return (newWidths - startNewWidths) + 1;
+}                               /* UniquifySpansX */
+
+static void
+miDisposeSpanGroup(SpanGroup * spanGroup)
+{
+    int i;
+    Spans *spans;
+
+    for (i = 0; i < spanGroup->count; i++) {
+        spans = spanGroup->group + i;
+        free(spans->points);
+        free(spans->widths);
+    }
+}
+
+void
+miFillUniqueSpanGroup(DrawablePtr pDraw, GCPtr pGC, SpanGroup * spanGroup)
+{
+    int i;
+    Spans *spans;
+    Spans *yspans;
+    int *ysizes;
+    int ymin, ylength;
+
+    /* Outgoing spans for one big call to FillSpans */
+    DDXPointPtr points;
+    int *widths;
+    int count;
+
+    if (spanGroup->count == 0)
+        return;
+
+    if (spanGroup->count == 1) {
+        /* Already should be sorted, unique */
+        spans = spanGroup->group;
+        (*pGC->ops->FillSpans)
+            (pDraw, pGC, spans->count, spans->points, spans->widths, TRUE);
+        free(spans->points);
+        free(spans->widths);
+    }
+    else {
+        /* Yuck.  Gross.  Radix sort into y buckets, then sort x and uniquify */
+        /* This seems to be the fastest thing to do.  I've tried sorting on
+           both x and y at the same time rather than creating into all those
+           y buckets, but it was somewhat slower. */
+
+        ymin = spanGroup->ymin;
+        ylength = spanGroup->ymax - ymin + 1;
+
+        /* Allocate Spans for y buckets */
+        yspans = malloc(ylength * sizeof(Spans));
+        ysizes = malloc(ylength * sizeof(int));
+
+        if (!yspans || !ysizes) {
+            free(yspans);
+            free(ysizes);
+            miDisposeSpanGroup(spanGroup);
+            return;
+        }
+
+        for (i = 0; i != ylength; i++) {
+            ysizes[i] = 0;
+            yspans[i].count = 0;
+            yspans[i].points = NULL;
+            yspans[i].widths = NULL;
+        }
+
+        /* Go through every single span and put it into the correct bucket */
+        count = 0;
+        for (i = 0, spans = spanGroup->group;
+             i != spanGroup->count; i++, spans++) {
+            int index;
+            int j;
+
+            for (j = 0, points = spans->points, widths = spans->widths;
+                 j != spans->count; j++, points++, widths++) {
+                index = points->y - ymin;
+                if (index >= 0 && index < ylength) {
+                    Spans *newspans = &(yspans[index]);
+
+                    if (newspans->count == ysizes[index]) {
+                        DDXPointPtr newpoints;
+                        int *newwidths;
+
+                        ysizes[index] = (ysizes[index] + 8) * 2;
+                        newpoints = (DDXPointPtr) realloc(newspans->points,
+                                                          ysizes[index] *
+                                                          sizeof(DDXPointRec));
+                        newwidths =
+                            (int *) realloc(newspans->widths,
+                                            ysizes[index] * sizeof(int));
+                        if (!newpoints || !newwidths) {
+                            int i;
+
+                            for (i = 0; i < ylength; i++) {
+                                free(yspans[i].points);
+                                free(yspans[i].widths);
+                            }
+                            free(yspans);
+                            free(ysizes);
+                            free(newpoints);
+                            free(newwidths);
+                            miDisposeSpanGroup(spanGroup);
+                            return;
+                        }
+                        newspans->points = newpoints;
+                        newspans->widths = newwidths;
+                    }
+                    newspans->points[newspans->count] = *points;
+                    newspans->widths[newspans->count] = *widths;
+                    (newspans->count)++;
+                }               /* if y value of span in range */
+            }                   /* for j through spans */
+            count += spans->count;
+            free(spans->points);
+            spans->points = NULL;
+            free(spans->widths);
+            spans->widths = NULL;
+        }                       /* for i thorough Spans */
+
+        /* Now sort by x and uniquify each bucket into the final array */
+        points = malloc(count * sizeof(DDXPointRec));
+        widths = malloc(count * sizeof(int));
+        if (!points || !widths) {
+            int i;
+
+            for (i = 0; i < ylength; i++) {
+                free(yspans[i].points);
+                free(yspans[i].widths);
+            }
+            free(yspans);
+            free(ysizes);
+            free(points);
+            free(widths);
+            return;
+        }
+        count = 0;
+        for (i = 0; i != ylength; i++) {
+            int ycount = yspans[i].count;
+
+            if (ycount > 0) {
+                if (ycount > 1) {
+                    QuickSortSpansX(yspans[i].points, yspans[i].widths, ycount);
+                    count += UniquifySpansX
+                        (&(yspans[i]), &(points[count]), &(widths[count]));
+                }
+                else {
+                    points[count] = yspans[i].points[0];
+                    widths[count] = yspans[i].widths[0];
+                    count++;
+                }
+                free(yspans[i].points);
+                free(yspans[i].widths);
+            }
+        }
+
+        (*pGC->ops->FillSpans) (pDraw, pGC, count, points, widths, TRUE);
+        free(points);
+        free(widths);
+        free(yspans);
+        free(ysizes);           /* use (DE)xalloc for these? */
+    }
+
+    spanGroup->count = 0;
+    spanGroup->ymin = MAXSHORT;
+    spanGroup->ymax = MINSHORT;
+}
diff --git a/mi/mispans.h b/mi/mispans.h
new file mode 100644
index 000000000..f3148ff19
--- /dev/null
+++ b/mi/mispans.h
@@ -0,0 +1,87 @@
+/***********************************************************
+
+Copyright 1989, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1989 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef MISPANS_H
+#define MISPANS_H
+
+typedef struct {
+    int count;                  /* number of spans                  */
+    DDXPointPtr points;         /* pointer to list of start points  */
+    int *widths;                /* pointer to list of widths        */
+} Spans;
+
+typedef struct {
+    int size;                   /* Total number of *Spans allocated     */
+    int count;                  /* Number of *Spans actually in group   */
+    Spans *group;               /* List of Spans                        */
+    int ymin, ymax;             /* Min, max y values encountered        */
+} SpanGroup;
+
+/* Initialize SpanGroup.  MUST BE DONE before use. */
+extern _X_EXPORT void miInitSpanGroup(SpanGroup *       /*spanGroup */
+    );
+
+/* Add a Spans to a SpanGroup. The spans MUST BE in y-sorted order */
+extern _X_EXPORT void miAppendSpans(SpanGroup * /*spanGroup */ ,
+                                    SpanGroup * /*otherGroup */ ,
+                                    Spans *     /*spans */
+    );
+
+/* Paint a span group, insuring that each pixel is painted at most once */
+extern _X_EXPORT void miFillUniqueSpanGroup(DrawablePtr /*pDraw */ ,
+                                            GCPtr /*pGC */ ,
+                                            SpanGroup * /*spanGroup */
+    );
+
+/* Free up data in a span group.  MUST BE DONE or you'll suffer memory leaks */
+extern _X_EXPORT void miFreeSpanGroup(SpanGroup *       /*spanGroup */
+    );
+
+/* Rops which must use span groups */
+#define miSpansCarefulRop(rop)	(((rop) & 0xc) == 0x8 || ((rop) & 0x3) == 0x2)
+#define miSpansEasyRop(rop)	(!miSpansCarefulRop(rop))
+
+#endif                          /* MISPANS_H */
diff --git a/mi/miwideline.c b/mi/miwideline.c
index 54de1d3e6..1994cb4e5 100644
--- a/mi/miwideline.c
+++ b/mi/miwideline.c
@@ -787,7 +787,7 @@ miFillRectPolyHelper(DrawablePtr pDrawable,
     }
 }
 
-static int
+int
 miPolyBuildEdge(double x0, double y0, double k, /* x0 * dy - y0 * dx */
                 int dx, int dy, int xi, int yi, int left, PolyEdgePtr edge)
 {
@@ -839,7 +839,7 @@ miPolyBuildEdge(double x0, double y0, double k, /* x0 * dy - y0 * dx */
 
 #define StepAround(v, incr, max) (((v) + (incr) < 0) ? (max - 1) : ((v) + (incr) == max) ? 0 : ((v) + (incr)))
 
-static int
+int
 miPolyBuildPoly(PolyVertexPtr vertices,
                 PolySlopePtr slopes,
                 int count,
@@ -1379,7 +1379,7 @@ miRoundJoinFace(LineFacePtr face, PolyEdgePtr edge, Bool *leftEdge)
     return y;
 }
 
-static void
+void
 miRoundJoinClip(LineFacePtr pLeft, LineFacePtr pRight,
                 PolyEdgePtr edge1, PolyEdgePtr edge2,
                 int *y1, int *y2, Bool *left1, Bool *left2)
@@ -1400,7 +1400,7 @@ miRoundJoinClip(LineFacePtr pLeft, LineFacePtr pRight,
     *y2 = miRoundJoinFace(pRight, edge2, left2);
 }
 
-static int
+int
 miRoundCapClip(LineFacePtr face, Bool isInt, PolyEdgePtr edge, Bool *leftEdge)
 {
     int y;
diff --git a/mi/miwideline.h b/mi/miwideline.h
index 88bc3d6c8..4c5d3e3c5 100644
--- a/mi/miwideline.h
+++ b/mi/miwideline.h
@@ -91,3 +91,29 @@ typedef struct _LineFace {
 	ValidateGC (pDrawable, pGC); \
     } \
 }
+
+int miPolyBuildPoly(PolyVertexPtr vertices,
+                    PolySlopePtr slopes, int count, int xi,
+                    int yi, PolyEdgePtr left,
+                    PolyEdgePtr right, int *pnleft,
+                    int *pnright, int *h);
+
+int miPolyBuildEdge(double x0, double y0, double k, int dx,
+                    int dy, int xi, int yi, int left,
+                    PolyEdgePtr edge);
+
+void miRoundJoinClip(LineFacePtr /*pLeft */,
+                     LineFacePtr /*pRight */,
+                     PolyEdgePtr /*edge1 */,
+                     PolyEdgePtr /*edge2 */,
+                     int * /*y1 */,
+                     int * /*y2 */,
+                     Bool * /*left1 */,
+                     Bool * /*left2 */
+);
+
+int miRoundCapClip(LineFacePtr /*face */,
+                   Bool /*isInt */,
+                   PolyEdgePtr /*edge */,
+                   Bool * /*leftEdge */
+);
diff --git a/mi/miwindow.c b/mi/miwindow.c
index 39c279e18..a3e1dc698 100644
--- a/mi/miwindow.c
+++ b/mi/miwindow.c
@@ -806,3 +806,17 @@ miXYToWindow(ScreenPtr pScreen, SpritePtr pSprite, int x, int y)
     pSprite->spriteTraceGood = 1;       /* root window still there */
     return miSpriteTrace(pSprite, x, y);
 }
+
+void
+miSegregateChildren(WindowPtr pWin, RegionPtr pReg, int depth)
+{
+    WindowPtr pChild;
+
+    for (pChild = pWin->firstChild; pChild; pChild = pChild->nextSib) {
+        if (pChild->drawable.depth == depth)
+            RegionUnion(pReg, pReg, &pChild->borderClip);
+
+        if (pChild->firstChild)
+            miSegregateChildren(pChild, pReg, depth);
+    }
+}
diff --git a/miext/Makefile.am b/miext/Makefile.am
index add4d18b0..bb29e8148 100644
--- a/miext/Makefile.am
+++ b/miext/Makefile.am
@@ -1 +1,4 @@
 SUBDIRS = sync damage shadow rootless
+if COMPOSITE
+SUBDIRS += cw
+endif
diff --git a/miext/cw/Makefile.am b/miext/cw/Makefile.am
new file mode 100644
index 000000000..af4170cf7
--- /dev/null
+++ b/miext/cw/Makefile.am
@@ -0,0 +1,11 @@
+noinst_LTLIBRARIES = libcw.la
+
+AM_CFLAGS = $(DIX_CFLAGS)
+
+INCLUDES = -I$(top_srcdir)/hw/xfree86/os-support
+
+libcw_la_SOURCES = \
+	cw.c		\
+	cw_ops.c	\
+	cw_render.c     \
+        cw.h
diff --git a/miext/cw/cw.c b/miext/cw/cw.c
new file mode 100644
index 000000000..354370096
--- /dev/null
+++ b/miext/cw/cw.c
@@ -0,0 +1,524 @@
+/*
+ * Copyright © 2004 Eric Anholt
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Eric Anholt not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Eric Anholt makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * ERIC ANHOLT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL ERIC ANHOLT BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include <string.h>
+
+#include "gcstruct.h"
+#include "windowstr.h"
+#include "cw.h"
+
+#define CW_DEBUG 1
+
+#if CW_DEBUG
+#define CW_ASSERT(x) do {						\
+    if (!(x)) {								\
+	ErrorF("composite wrapper: assertion failed at %s:%d\n", __FUNC__, \
+	    __LINE__);							\
+    }									\
+} while (0)
+#else
+#define CW_ASSERT(x) do {} while (0)
+#endif
+
+DevPrivateKeyRec cwGCKeyRec;
+DevPrivateKeyRec cwScreenKeyRec;
+DevPrivateKeyRec cwWindowKeyRec;
+DevPrivateKeyRec cwPictureKeyRec;
+
+extern GCOps cwGCOps;
+
+static Bool
+ cwCloseScreen(ScreenPtr pScreen);
+
+static void
+ cwValidateGC(GCPtr pGC, unsigned long stateChanges, DrawablePtr pDrawable);
+static void
+ cwChangeGC(GCPtr pGC, unsigned long mask);
+static void
+ cwCopyGC(GCPtr pGCSrc, unsigned long mask, GCPtr pGCDst);
+static void
+ cwDestroyGC(GCPtr pGC);
+static void
+ cwChangeClip(GCPtr pGC, int type, void *pvalue, int nrects);
+static void
+ cwCopyClip(GCPtr pgcDst, GCPtr pgcSrc);
+static void
+ cwDestroyClip(GCPtr pGC);
+
+GCFuncs cwGCFuncs = {
+    cwValidateGC,
+    cwChangeGC,
+    cwCopyGC,
+    cwDestroyGC,
+    cwChangeClip,
+    cwDestroyClip,
+    cwCopyClip,
+};
+
+/* Find the real drawable to draw to, and provide offsets that will translate
+ * window coordinates to backing pixmap coordinates.
+ */
+DrawablePtr
+cwGetBackingDrawable(DrawablePtr pDrawable, int *x_off, int *y_off)
+{
+    PixmapPtr pPixmap;
+
+    if (pDrawable->type == DRAWABLE_WINDOW &&
+        (pPixmap = getCwPixmap((WindowPtr) pDrawable))) {
+        *x_off = pDrawable->x - pPixmap->screen_x;
+        *y_off = pDrawable->y - pPixmap->screen_y;
+        return &pPixmap->drawable;
+    }
+    else {
+        *x_off = *y_off = 0;
+        return pDrawable;
+    }
+}
+
+#define FUNC_PROLOGUE(pGC, pPriv) do {					\
+    (pGC)->funcs = (pPriv)->wrapFuncs;					\
+    (pGC)->ops = (pPriv)->wrapOps;					\
+} while (0)
+
+#define FUNC_EPILOGUE(pGC, pPriv) do {					\
+    (pPriv)->wrapFuncs = (pGC)->funcs;					\
+    (pPriv)->wrapOps = (pGC)->ops;					\
+    (pGC)->funcs = &cwGCFuncs;						\
+    (pGC)->ops = &cwGCOps;						\
+} while (0)
+
+static Bool
+cwCreateBackingGC(GCPtr pGC, DrawablePtr pDrawable)
+{
+    cwGCRec *pPriv = getCwGC(pGC);
+    int status, x_off, y_off;
+    XID noexpose = xFalse;
+    DrawablePtr pBackingDrawable;
+
+    pBackingDrawable = cwGetBackingDrawable(pDrawable, &x_off, &y_off);
+    pPriv->pBackingGC = CreateGC(pBackingDrawable, GCGraphicsExposures,
+                                 &noexpose, &status, (XID) 0, serverClient);
+    if (status != Success)
+        return FALSE;
+
+    pPriv->serialNumber = 0;
+    pPriv->stateChanges = GCAllBits;
+
+    return TRUE;
+}
+
+static void
+cwDestroyBackingGC(GCPtr pGC)
+{
+    cwGCPtr pPriv;
+
+    pPriv = (cwGCPtr) getCwGC(pGC);
+
+    if (pPriv->pBackingGC) {
+        FreeGC(pPriv->pBackingGC, (XID) 0);
+        pPriv->pBackingGC = NULL;
+    }
+}
+
+static void
+cwValidateGC(GCPtr pGC, unsigned long stateChanges, DrawablePtr pDrawable)
+{
+    GCPtr pBackingGC;
+    cwGCPtr pPriv;
+    DrawablePtr pBackingDrawable;
+    int x_off, y_off;
+
+    pPriv = (cwGCPtr) getCwGC(pGC);
+
+    FUNC_PROLOGUE(pGC, pPriv);
+
+    /*
+     * Must call ValidateGC to ensure pGC->pCompositeClip is valid
+     */
+    (*pGC->funcs->ValidateGC) (pGC, stateChanges, pDrawable);
+
+    if (!cwDrawableIsRedirWindow(pDrawable)) {
+        cwDestroyBackingGC(pGC);
+        FUNC_EPILOGUE(pGC, pPriv);
+        return;
+    }
+    else {
+        if (!pPriv->pBackingGC && !cwCreateBackingGC(pGC, pDrawable)) {
+            FUNC_EPILOGUE(pGC, pPriv);
+            return;
+        }
+    }
+
+    pBackingGC = pPriv->pBackingGC;
+    pBackingDrawable = cwGetBackingDrawable(pDrawable, &x_off, &y_off);
+
+    pPriv->stateChanges |= stateChanges;
+
+    /*
+     * Copy the composite clip into the backing GC if either
+     * the drawable clip list has changed or the client has changed
+     * the client clip data
+     */
+    if (pDrawable->serialNumber != pPriv->serialNumber ||
+        (pPriv->stateChanges & (GCClipXOrigin | GCClipYOrigin | GCClipMask))) {
+        ChangeGCVal vals[2];
+        RegionPtr pCompositeClip;
+
+        pCompositeClip = RegionCreate(NULL, 0);
+        RegionCopy(pCompositeClip, pGC->pCompositeClip);
+
+        /* Either the drawable has changed, or the clip list in the drawable has
+         * changed.  Copy the new clip list over and set the new translated
+         * offset for it.
+         */
+
+        (*pBackingGC->funcs->ChangeClip) (pBackingGC, CT_REGION,
+                                          pCompositeClip, 0);
+
+        vals[0].val = x_off - pDrawable->x;
+        vals[1].val = y_off - pDrawable->y;
+        ChangeGC(NullClient, pBackingGC, (GCClipXOrigin | GCClipYOrigin), vals);
+
+        pPriv->serialNumber = pDrawable->serialNumber;
+        /*
+         * Mask off any client clip changes to make sure
+         * the clip list set above remains in effect
+         */
+        pPriv->stateChanges &= ~(GCClipXOrigin | GCClipYOrigin | GCClipMask);
+    }
+
+    if (pPriv->stateChanges) {
+        CopyGC(pGC, pBackingGC, pPriv->stateChanges);
+        pPriv->stateChanges = 0;
+    }
+
+    if ((pGC->patOrg.x + x_off) != pBackingGC->patOrg.x ||
+        (pGC->patOrg.y + y_off) != pBackingGC->patOrg.y) {
+        ChangeGCVal vals[2];
+
+        vals[0].val = pGC->patOrg.x + x_off;
+        vals[1].val = pGC->patOrg.y + y_off;
+        ChangeGC(NullClient, pBackingGC,
+                 (GCTileStipXOrigin | GCTileStipYOrigin), vals);
+    }
+
+    ValidateGC(pBackingDrawable, pBackingGC);
+
+    FUNC_EPILOGUE(pGC, pPriv);
+}
+
+static void
+cwChangeGC(GCPtr pGC, unsigned long mask)
+{
+    cwGCPtr pPriv = (cwGCPtr) dixLookupPrivate(&pGC->devPrivates, cwGCKey);
+
+    FUNC_PROLOGUE(pGC, pPriv);
+
+    (*pGC->funcs->ChangeGC) (pGC, mask);
+
+    FUNC_EPILOGUE(pGC, pPriv);
+}
+
+static void
+cwCopyGC(GCPtr pGCSrc, unsigned long mask, GCPtr pGCDst)
+{
+    cwGCPtr pPriv = (cwGCPtr) dixLookupPrivate(&pGCDst->devPrivates, cwGCKey);
+
+    FUNC_PROLOGUE(pGCDst, pPriv);
+
+    (*pGCDst->funcs->CopyGC) (pGCSrc, mask, pGCDst);
+
+    FUNC_EPILOGUE(pGCDst, pPriv);
+}
+
+static void
+cwDestroyGC(GCPtr pGC)
+{
+    cwGCPtr pPriv = (cwGCPtr) dixLookupPrivate(&pGC->devPrivates, cwGCKey);
+
+    FUNC_PROLOGUE(pGC, pPriv);
+
+    cwDestroyBackingGC(pGC);
+
+    (*pGC->funcs->DestroyGC) (pGC);
+
+    /* leave it unwrapped */
+}
+
+static void
+cwChangeClip(GCPtr pGC, int type, void *pvalue, int nrects)
+{
+    cwGCPtr pPriv = (cwGCPtr) dixLookupPrivate(&pGC->devPrivates, cwGCKey);
+
+    FUNC_PROLOGUE(pGC, pPriv);
+
+    (*pGC->funcs->ChangeClip) (pGC, type, pvalue, nrects);
+
+    FUNC_EPILOGUE(pGC, pPriv);
+}
+
+static void
+cwCopyClip(GCPtr pgcDst, GCPtr pgcSrc)
+{
+    cwGCPtr pPriv = (cwGCPtr) dixLookupPrivate(&pgcDst->devPrivates, cwGCKey);
+
+    FUNC_PROLOGUE(pgcDst, pPriv);
+
+    (*pgcDst->funcs->CopyClip) (pgcDst, pgcSrc);
+
+    FUNC_EPILOGUE(pgcDst, pPriv);
+}
+
+static void
+cwDestroyClip(GCPtr pGC)
+{
+    cwGCPtr pPriv = (cwGCPtr) dixLookupPrivate(&pGC->devPrivates, cwGCKey);
+
+    FUNC_PROLOGUE(pGC, pPriv);
+
+    (*pGC->funcs->DestroyClip) (pGC);
+
+    FUNC_EPILOGUE(pGC, pPriv);
+}
+
+/*
+ * Screen wrappers.
+ */
+
+#define SCREEN_PROLOGUE(pScreen, field)				\
+  ((pScreen)->field = getCwScreen(pScreen)->field)
+
+#define SCREEN_EPILOGUE(pScreen, field, wrapper) do {		\
+    getCwScreen(pScreen)->field = (pScreen)->field;		\
+    (pScreen)->field = (wrapper);				\
+} while (0)
+
+static Bool
+cwCreateGC(GCPtr pGC)
+{
+    cwGCPtr pPriv = getCwGC(pGC);
+    ScreenPtr pScreen = pGC->pScreen;
+    Bool ret;
+
+    SCREEN_PROLOGUE(pScreen, CreateGC);
+
+    if ((ret = (*pScreen->CreateGC) (pGC)))
+        FUNC_EPILOGUE(pGC, pPriv);
+
+    SCREEN_EPILOGUE(pScreen, CreateGC, cwCreateGC);
+
+    return ret;
+}
+
+static void
+cwGetImage(DrawablePtr pSrc, int x, int y, int w, int h, unsigned int format,
+           unsigned long planemask, char *pdstLine)
+{
+    ScreenPtr pScreen = pSrc->pScreen;
+    DrawablePtr pBackingDrawable;
+    int src_off_x, src_off_y;
+
+    SCREEN_PROLOGUE(pScreen, GetImage);
+
+    pBackingDrawable = cwGetBackingDrawable(pSrc, &src_off_x, &src_off_y);
+
+    CW_OFFSET_XY_SRC(x, y);
+
+    (*pScreen->GetImage) (pBackingDrawable, x, y, w, h, format, planemask,
+                          pdstLine);
+
+    SCREEN_EPILOGUE(pScreen, GetImage, cwGetImage);
+}
+
+static void
+cwGetSpans(DrawablePtr pSrc, int wMax, DDXPointPtr ppt, int *pwidth,
+           int nspans, char *pdstStart)
+{
+    ScreenPtr pScreen = pSrc->pScreen;
+    DrawablePtr pBackingDrawable;
+    int i;
+    int src_off_x, src_off_y;
+
+    SCREEN_PROLOGUE(pScreen, GetSpans);
+
+    pBackingDrawable = cwGetBackingDrawable(pSrc, &src_off_x, &src_off_y);
+
+    for (i = 0; i < nspans; i++)
+        CW_OFFSET_XY_SRC(ppt[i].x, ppt[i].y);
+
+    (*pScreen->GetSpans) (pBackingDrawable, wMax, ppt, pwidth, nspans,
+                          pdstStart);
+
+    SCREEN_EPILOGUE(pScreen, GetSpans, cwGetSpans);
+}
+
+static void
+cwCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
+{
+    ScreenPtr pScreen = pWin->drawable.pScreen;
+
+    SCREEN_PROLOGUE(pScreen, CopyWindow);
+
+    if (!cwDrawableIsRedirWindow((DrawablePtr) pWin)) {
+        (*pScreen->CopyWindow) (pWin, ptOldOrg, prgnSrc);
+    }
+    else {
+        GCPtr pGC;
+        BoxPtr pExtents;
+        int x_off, y_off;
+        int dx, dy;
+        PixmapPtr pBackingPixmap;
+        RegionPtr pClip;
+        int src_x, src_y, dst_x, dst_y, w, h;
+
+        dx = ptOldOrg.x - pWin->drawable.x;
+        dy = ptOldOrg.y - pWin->drawable.y;
+
+        pExtents = RegionExtents(prgnSrc);
+
+        pBackingPixmap = (PixmapPtr) cwGetBackingDrawable((DrawablePtr) pWin,
+                                                          &x_off, &y_off);
+
+        src_x = pExtents->x1 - pBackingPixmap->screen_x;
+        src_y = pExtents->y1 - pBackingPixmap->screen_y;
+        w = pExtents->x2 - pExtents->x1;
+        h = pExtents->y2 - pExtents->y1;
+        dst_x = src_x - dx;
+        dst_y = src_y - dy;
+
+        /* Translate region (as required by API) */
+        RegionTranslate(prgnSrc, -dx, -dy);
+
+        pGC = GetScratchGC(pBackingPixmap->drawable.depth, pScreen);
+        /*
+         * Copy region to GC as clip, aligning as dest clip
+         */
+        pClip = RegionCreate(NULL, 0);
+        RegionIntersect(pClip, &pWin->borderClip, prgnSrc);
+        RegionTranslate(pClip,
+                        -pBackingPixmap->screen_x, -pBackingPixmap->screen_y);
+
+        (*pGC->funcs->ChangeClip) (pGC, CT_REGION, pClip, 0);
+
+        ValidateGC(&pBackingPixmap->drawable, pGC);
+
+        (*pGC->ops->CopyArea) (&pBackingPixmap->drawable,
+                               &pBackingPixmap->drawable, pGC,
+                               src_x, src_y, w, h, dst_x, dst_y);
+
+        (*pGC->funcs->DestroyClip) (pGC);
+
+        FreeScratchGC(pGC);
+    }
+
+    SCREEN_EPILOGUE(pScreen, CopyWindow, cwCopyWindow);
+}
+
+static PixmapPtr
+cwGetWindowPixmap(WindowPtr pWin)
+{
+    PixmapPtr pPixmap = getCwPixmap(pWin);
+
+    if (!pPixmap) {
+        ScreenPtr pScreen = pWin->drawable.pScreen;
+
+        SCREEN_PROLOGUE(pScreen, GetWindowPixmap);
+        if (pScreen->GetWindowPixmap)
+            pPixmap = (*pScreen->GetWindowPixmap) (pWin);
+        SCREEN_EPILOGUE(pScreen, GetWindowPixmap, cwGetWindowPixmap);
+    }
+    return pPixmap;
+}
+
+static void
+cwSetWindowPixmap(WindowPtr pWindow, PixmapPtr pPixmap)
+{
+    ScreenPtr pScreen = pWindow->drawable.pScreen;
+
+    if (pPixmap == (*pScreen->GetScreenPixmap) (pScreen))
+        pPixmap = NULL;
+    setCwPixmap(pWindow, pPixmap);
+}
+
+/* Screen initialization/teardown */
+void
+miInitializeCompositeWrapper(ScreenPtr pScreen)
+{
+    cwScreenPtr pScreenPriv;
+    Bool has_render = GetPictureScreenIfSet(pScreen) != NULL;
+
+    if (!dixRegisterPrivateKey(&cwScreenKeyRec, PRIVATE_SCREEN, 0))
+        return;
+
+    if (!dixRegisterPrivateKey(&cwGCKeyRec, PRIVATE_GC, sizeof(cwGCRec)))
+        return;
+
+    if (!dixRegisterPrivateKey(&cwWindowKeyRec, PRIVATE_WINDOW, 0))
+        return;
+
+    if (!dixRegisterPrivateKey(&cwPictureKeyRec, PRIVATE_PICTURE, 0))
+        return;
+
+    pScreenPriv = malloc(sizeof(cwScreenRec));
+    if (!pScreenPriv)
+        return;
+
+    dixSetPrivate(&pScreen->devPrivates, cwScreenKey, pScreenPriv);
+
+    SCREEN_EPILOGUE(pScreen, CloseScreen, cwCloseScreen);
+    SCREEN_EPILOGUE(pScreen, GetImage, cwGetImage);
+    SCREEN_EPILOGUE(pScreen, GetSpans, cwGetSpans);
+    SCREEN_EPILOGUE(pScreen, CreateGC, cwCreateGC);
+    SCREEN_EPILOGUE(pScreen, CopyWindow, cwCopyWindow);
+
+    SCREEN_EPILOGUE(pScreen, SetWindowPixmap, cwSetWindowPixmap);
+    SCREEN_EPILOGUE(pScreen, GetWindowPixmap, cwGetWindowPixmap);
+
+    if (has_render)
+        cwInitializeRender(pScreen);
+}
+
+static Bool
+cwCloseScreen(ScreenPtr pScreen)
+{
+    cwScreenPtr pScreenPriv;
+    PictureScreenPtr ps = GetPictureScreenIfSet(pScreen);
+
+    pScreenPriv = (cwScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
+                                                 cwScreenKey);
+    pScreen->CloseScreen = pScreenPriv->CloseScreen;
+    pScreen->GetImage = pScreenPriv->GetImage;
+    pScreen->GetSpans = pScreenPriv->GetSpans;
+    pScreen->CreateGC = pScreenPriv->CreateGC;
+    pScreen->CopyWindow = pScreenPriv->CopyWindow;
+
+    if (ps)
+        cwFiniRender(pScreen);
+
+    free(pScreenPriv);
+
+    return (*pScreen->CloseScreen) (pScreen);
+}
diff --git a/miext/cw/cw.h b/miext/cw/cw.h
new file mode 100644
index 000000000..9f880f7f5
--- /dev/null
+++ b/miext/cw/cw.h
@@ -0,0 +1,173 @@
+/*
+ * Copyright © 2004 Eric Anholt
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Eric Anholt not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Eric Anholt makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * ERIC ANHOLT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL ERIC ANHOLT BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include "gcstruct.h"
+#include "picturestr.h"
+#include "privates.h"
+
+/*
+ * One of these structures is allocated per GC that gets used with a window with
+ * backing pixmap.
+ */
+
+typedef struct {
+    GCPtr pBackingGC;           /* Copy of the GC but with graphicsExposures
+                                 * set FALSE and the clientClip set to
+                                 * clip output to the valid regions of the
+                                 * backing pixmap. */
+    unsigned long serialNumber; /* clientClip computed time */
+    unsigned long stateChanges; /* changes in parent gc since last copy */
+    GCOps *wrapOps;             /* wrapped ops */
+    GCFuncs *wrapFuncs;         /* wrapped funcs */
+} cwGCRec, *cwGCPtr;
+
+extern _X_EXPORT DevPrivateKeyRec cwGCKeyRec;
+
+#define cwGCKey (&cwGCKeyRec)
+
+#define getCwGC(pGC) ((cwGCPtr)dixLookupPrivate(&(pGC)->devPrivates, cwGCKey))
+#define setCwGC(pGC,p) dixSetPrivate(&(pGC)->devPrivates, cwGCKey, p)
+
+/*
+ * One of these structures is allocated per Picture that gets used with a
+ * window with a backing pixmap
+ */
+
+typedef struct {
+    PicturePtr pBackingPicture;
+    unsigned long serialNumber;
+    unsigned long stateChanges;
+} cwPictureRec, *cwPicturePtr;
+
+extern _X_EXPORT DevPrivateKeyRec cwPictureKeyRec;
+
+#define cwPictureKey (&cwPictureKeyRec)
+
+#define getCwPicture(pPicture) (pPicture->pDrawable ? \
+    (cwPicturePtr)dixLookupPrivate(&(pPicture)->devPrivates, cwPictureKey) : 0)
+#define setCwPicture(pPicture,p) dixSetPrivate(&(pPicture)->devPrivates, cwPictureKey, p)
+
+extern _X_EXPORT DevPrivateKeyRec cwWindowKeyRec;
+
+#define cwWindowKey (&cwWindowKeyRec)
+
+#define cwWindowPrivate(pWin) dixLookupPrivate(&(pWin)->devPrivates, cwWindowKey)
+#define getCwPixmap(pWindow)	    ((PixmapPtr) cwWindowPrivate(pWindow))
+#define setCwPixmap(pWindow,pPixmap) \
+    dixSetPrivate(&(pWindow)->devPrivates, cwWindowKey, pPixmap)
+
+#define cwDrawableIsRedirWindow(pDraw)					\
+	((pDraw)->type == DRAWABLE_WINDOW &&				\
+	 getCwPixmap((WindowPtr) (pDraw)) != NULL)
+
+typedef struct {
+    /*
+     * screen func wrappers
+     */
+    CloseScreenProcPtr CloseScreen;
+    GetImageProcPtr GetImage;
+    GetSpansProcPtr GetSpans;
+    CreateGCProcPtr CreateGC;
+
+    CopyWindowProcPtr CopyWindow;
+
+    GetWindowPixmapProcPtr GetWindowPixmap;
+    SetWindowPixmapProcPtr SetWindowPixmap;
+
+    DestroyPictureProcPtr DestroyPicture;
+    ChangePictureClipProcPtr ChangePictureClip;
+    DestroyPictureClipProcPtr DestroyPictureClip;
+
+    ChangePictureProcPtr ChangePicture;
+    ValidatePictureProcPtr ValidatePicture;
+
+    CompositeProcPtr Composite;
+    CompositeRectsProcPtr CompositeRects;
+
+    TrapezoidsProcPtr Trapezoids;
+    TrianglesProcPtr Triangles;
+
+    RasterizeTrapezoidProcPtr RasterizeTrapezoid;
+} cwScreenRec, *cwScreenPtr;
+
+extern _X_EXPORT DevPrivateKeyRec cwScreenKeyRec;
+
+#define cwScreenKey (&cwScreenKeyRec)
+
+#define getCwScreen(pScreen) ((cwScreenPtr)dixLookupPrivate(&(pScreen)->devPrivates, cwScreenKey))
+#define setCwScreen(pScreen,p) dixSetPrivate(&(pScreen)->devPrivates, cwScreenKey, p)
+
+#define CW_OFFSET_XYPOINTS(ppt, npt) do { \
+    DDXPointPtr _ppt = (DDXPointPtr)(ppt); \
+    int _i; \
+    for (_i = 0; _i < npt; _i++) { \
+	_ppt[_i].x += dst_off_x; \
+	_ppt[_i].y += dst_off_y; \
+    } \
+} while (0)
+
+#define CW_OFFSET_RECTS(prect, nrect) do { \
+    int _i; \
+    for (_i = 0; _i < nrect; _i++) { \
+	(prect)[_i].x += dst_off_x; \
+	(prect)[_i].y += dst_off_y; \
+    } \
+} while (0)
+
+#define CW_OFFSET_ARCS(parc, narc) do { \
+    int _i; \
+    for (_i = 0; _i < narc; _i++) { \
+	(parc)[_i].x += dst_off_x; \
+	(parc)[_i].y += dst_off_y; \
+    } \
+} while (0)
+
+#define CW_OFFSET_XY_DST(x, y) do { \
+    (x) = (x) + dst_off_x; \
+    (y) = (y) + dst_off_y; \
+} while (0)
+
+#define CW_OFFSET_XY_SRC(x, y) do { \
+    (x) = (x) + src_off_x; \
+    (y) = (y) + src_off_y; \
+} while (0)
+
+/* cw.c */
+extern _X_EXPORT DrawablePtr
+ cwGetBackingDrawable(DrawablePtr pDrawable, int *x_off, int *y_off);
+
+/* cw_render.c */
+
+extern _X_EXPORT void
+ cwInitializeRender(ScreenPtr pScreen);
+
+extern _X_EXPORT void
+ cwFiniRender(ScreenPtr pScreen);
+
+/* cw.c */
+
+extern _X_EXPORT void
+ miInitializeCompositeWrapper(ScreenPtr pScreen);
diff --git a/miext/cw/cw_ops.c b/miext/cw/cw_ops.c
new file mode 100644
index 000000000..4d23d437d
--- /dev/null
+++ b/miext/cw/cw_ops.c
@@ -0,0 +1,477 @@
+/*
+ * Copyright © 2004 Eric Anholt
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Eric Anholt not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Eric Anholt makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * ERIC ANHOLT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL ERIC ANHOLT BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include <stdlib.h>
+
+#include "gcstruct.h"
+#include "pixmapstr.h"
+#include "cw.h"
+#include "mi.h"
+
+#define SETUP_BACKING_DST(_pDst, _pGC) \
+    cwGCPtr pGCPrivate = getCwGC (_pGC); \
+    int dst_off_x, dst_off_y; \
+    DrawablePtr pBackingDst = cwGetBackingDrawable(pDst, &dst_off_x, \
+	&dst_off_y); \
+    GCPtr pBackingGC = pGCPrivate->pBackingGC ? pGCPrivate->pBackingGC : _pGC
+
+#define SETUP_BACKING_SRC(pSrc, pGC) \
+    int src_off_x, src_off_y; \
+    DrawablePtr pBackingSrc = cwGetBackingDrawable(pSrc, &src_off_x, \
+	&src_off_y)
+
+#define PROLOGUE(pGC) do { \
+    if (pBackingGC->serialNumber != pBackingDst->serialNumber) { \
+	ValidateGC(pBackingDst, pBackingGC); \
+    } \
+    pGC->funcs = pGCPrivate->wrapFuncs;\
+    pGC->ops = pGCPrivate->wrapOps;\
+} while (0)
+
+#define EPILOGUE(pGC) do { \
+    pGCPrivate->wrapFuncs = (pGC)->funcs; \
+    pGCPrivate->wrapOps = (pGC)->ops; \
+    (pGC)->funcs = &cwGCFuncs; \
+    (pGC)->ops = &cwGCOps; \
+} while (0)
+
+extern GCFuncs cwGCFuncs;
+
+/*
+ * GC ops -- wrap each GC operation with our own function
+ */
+
+static void cwFillSpans(DrawablePtr pDst, GCPtr pGC, int nInit,
+                        DDXPointPtr pptInit, int *pwidthInit, int fSorted);
+static void cwSetSpans(DrawablePtr pDst, GCPtr pGC, char *psrc,
+                       DDXPointPtr ppt, int *pwidth, int nspans, int fSorted);
+static void cwPutImage(DrawablePtr pDst, GCPtr pGC, int depth,
+                       int x, int y, int w, int h, int leftPad, int format,
+                       char *pBits);
+static RegionPtr cwCopyArea(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
+                            int srcx, int srcy, int w, int h,
+                            int dstx, int dsty);
+static RegionPtr cwCopyPlane(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
+                             int srcx, int srcy, int w, int h,
+                             int dstx, int dsty, unsigned long plane);
+static void cwPolyPoint(DrawablePtr pDst, GCPtr pGC, int mode, int npt,
+                        xPoint * pptInit);
+static void cwPolylines(DrawablePtr pDst, GCPtr pGC, int mode, int npt,
+                        DDXPointPtr pptInit);
+static void cwPolySegment(DrawablePtr pDst, GCPtr pGC, int nseg,
+                          xSegment * pSegs);
+static void cwPolyRectangle(DrawablePtr pDst, GCPtr pGC,
+                            int nrects, xRectangle *pRects);
+static void cwPolyArc(DrawablePtr pDst, GCPtr pGC, int narcs, xArc * parcs);
+static void cwFillPolygon(DrawablePtr pDst, GCPtr pGC, int shape, int mode,
+                          int count, DDXPointPtr pPts);
+static void cwPolyFillRect(DrawablePtr pDst, GCPtr pGC,
+                           int nrectFill, xRectangle *prectInit);
+static void cwPolyFillArc(DrawablePtr pDst, GCPtr pGC, int narcs, xArc * parcs);
+static int cwPolyText8(DrawablePtr pDrawable, GCPtr pGC, int x, int y,
+                       int count, char *chars);
+static int cwPolyText16(DrawablePtr pDst, GCPtr pGC, int x, int y,
+                        int count, unsigned short *chars);
+static void cwImageText8(DrawablePtr pDst, GCPtr pGC, int x, int y,
+                         int count, char *chars);
+static void cwImageText16(DrawablePtr pDst, GCPtr pGC, int x, int y,
+                          int count, unsigned short *chars);
+static void cwImageGlyphBlt(DrawablePtr pDst, GCPtr pGC, int x, int y,
+                            unsigned int nglyph, CharInfoPtr * ppci,
+                            void *pglyphBase);
+static void cwPolyGlyphBlt(DrawablePtr pDst, GCPtr pGC, int x, int y,
+                           unsigned int nglyph, CharInfoPtr * ppci,
+                           void *pglyphBase);
+static void cwPushPixels(GCPtr pGC, PixmapPtr pBitMap, DrawablePtr pDst,
+                         int w, int h, int x, int y);
+
+GCOps cwGCOps = {
+    cwFillSpans,
+    cwSetSpans,
+    cwPutImage,
+    cwCopyArea,
+    cwCopyPlane,
+    cwPolyPoint,
+    cwPolylines,
+    cwPolySegment,
+    cwPolyRectangle,
+    cwPolyArc,
+    cwFillPolygon,
+    cwPolyFillRect,
+    cwPolyFillArc,
+    cwPolyText8,
+    cwPolyText16,
+    cwImageText8,
+    cwImageText16,
+    cwImageGlyphBlt,
+    cwPolyGlyphBlt,
+    cwPushPixels
+};
+
+static void
+cwFillSpans(DrawablePtr pDst, GCPtr pGC, int nspans, DDXPointPtr ppt,
+            int *pwidth, int fSorted)
+{
+    SETUP_BACKING_DST(pDst, pGC);
+
+    PROLOGUE(pGC);
+
+    CW_OFFSET_XYPOINTS(ppt, nspans);
+
+    (*pBackingGC->ops->FillSpans) (pBackingDst, pBackingGC, nspans, ppt,
+                                   pwidth, fSorted);
+
+    EPILOGUE(pGC);
+}
+
+static void
+cwSetSpans(DrawablePtr pDst, GCPtr pGC, char *psrc, DDXPointPtr ppt,
+           int *pwidth, int nspans, int fSorted)
+{
+    SETUP_BACKING_DST(pDst, pGC);
+
+    PROLOGUE(pGC);
+
+    CW_OFFSET_XYPOINTS(ppt, nspans);
+
+    (*pBackingGC->ops->SetSpans) (pBackingDst, pBackingGC, psrc, ppt, pwidth,
+                                  nspans, fSorted);
+
+    EPILOGUE(pGC);
+}
+
+static void
+cwPutImage(DrawablePtr pDst, GCPtr pGC, int depth, int x, int y, int w, int h,
+           int leftPad, int format, char *pBits)
+{
+    SETUP_BACKING_DST(pDst, pGC);
+
+    PROLOGUE(pGC);
+
+    CW_OFFSET_XY_DST(x, y);
+
+    (*pBackingGC->ops->PutImage) (pBackingDst, pBackingGC, depth, x, y, w, h,
+                                  leftPad, format, pBits);
+
+    EPILOGUE(pGC);
+}
+
+static RegionPtr
+cwCopyArea(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC, int srcx, int srcy,
+           int w, int h, int dstx, int dsty)
+{
+    int odstx, odsty;
+    int osrcx, osrcy;
+
+    SETUP_BACKING_DST(pDst, pGC);
+    SETUP_BACKING_SRC(pSrc, pGC);
+
+    PROLOGUE(pGC);
+
+    odstx = dstx;
+    odsty = dsty;
+    osrcx = srcx;
+    osrcy = srcy;
+    CW_OFFSET_XY_DST(dstx, dsty);
+    CW_OFFSET_XY_SRC(srcx, srcy);
+
+    (*pBackingGC->ops->CopyArea) (pBackingSrc, pBackingDst,
+                                  pBackingGC, srcx, srcy, w, h, dstx, dsty);
+
+    EPILOGUE(pGC);
+
+    return miHandleExposures(pSrc, pDst, pGC,
+                             osrcx, osrcy, w, h, odstx, odsty);
+}
+
+static RegionPtr
+cwCopyPlane(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC, int srcx, int srcy,
+            int w, int h, int dstx, int dsty, unsigned long plane)
+{
+    int odstx, odsty;
+    int osrcx, osrcy;
+
+    SETUP_BACKING_DST(pDst, pGC);
+    SETUP_BACKING_SRC(pSrc, pGC);
+
+    PROLOGUE(pGC);
+
+    odstx = dstx;
+    odsty = dsty;
+    osrcx = srcx;
+    osrcy = srcy;
+    CW_OFFSET_XY_DST(dstx, dsty);
+    CW_OFFSET_XY_SRC(srcx, srcy);
+
+    (*pBackingGC->ops->CopyPlane) (pBackingSrc, pBackingDst,
+                                   pBackingGC, srcx, srcy, w, h,
+                                   dstx, dsty, plane);
+
+    EPILOGUE(pGC);
+
+    return miHandleExposures(pSrc, pDst, pGC,
+                             osrcx, osrcy, w, h, odstx, odsty);
+}
+
+static void
+cwPolyPoint(DrawablePtr pDst, GCPtr pGC, int mode, int npt, xPoint * ppt)
+{
+    SETUP_BACKING_DST(pDst, pGC);
+
+    PROLOGUE(pGC);
+
+    if (mode == CoordModeOrigin)
+        CW_OFFSET_XYPOINTS(ppt, npt);
+    else
+        CW_OFFSET_XYPOINTS(ppt, 1);
+
+    (*pBackingGC->ops->PolyPoint) (pBackingDst, pBackingGC, mode, npt, ppt);
+
+    EPILOGUE(pGC);
+}
+
+static void
+cwPolylines(DrawablePtr pDst, GCPtr pGC, int mode, int npt, DDXPointPtr ppt)
+{
+    SETUP_BACKING_DST(pDst, pGC);
+
+    PROLOGUE(pGC);
+
+    if (mode == CoordModeOrigin)
+        CW_OFFSET_XYPOINTS(ppt, npt);
+    else
+        CW_OFFSET_XYPOINTS(ppt, 1);
+
+    (*pBackingGC->ops->Polylines) (pBackingDst, pBackingGC, mode, npt, ppt);
+
+    EPILOGUE(pGC);
+}
+
+static void
+cwPolySegment(DrawablePtr pDst, GCPtr pGC, int nseg, xSegment * pSegs)
+{
+    SETUP_BACKING_DST(pDst, pGC);
+
+    PROLOGUE(pGC);
+
+    CW_OFFSET_XYPOINTS(pSegs, nseg * 2);
+
+    (*pBackingGC->ops->PolySegment) (pBackingDst, pBackingGC, nseg, pSegs);
+
+    EPILOGUE(pGC);
+}
+
+static void
+cwPolyRectangle(DrawablePtr pDst, GCPtr pGC, int nrects, xRectangle *pRects)
+{
+    SETUP_BACKING_DST(pDst, pGC);
+
+    PROLOGUE(pGC);
+
+    CW_OFFSET_RECTS(pRects, nrects);
+
+    (*pBackingGC->ops->PolyRectangle) (pBackingDst, pBackingGC, nrects, pRects);
+
+    EPILOGUE(pGC);
+}
+
+static void
+cwPolyArc(DrawablePtr pDst, GCPtr pGC, int narcs, xArc * pArcs)
+{
+    SETUP_BACKING_DST(pDst, pGC);
+
+    PROLOGUE(pGC);
+
+    CW_OFFSET_RECTS(pArcs, narcs);
+
+    (*pBackingGC->ops->PolyArc) (pBackingDst, pBackingGC, narcs, pArcs);
+
+    EPILOGUE(pGC);
+}
+
+static void
+cwFillPolygon(DrawablePtr pDst, GCPtr pGC, int shape, int mode, int npt,
+              DDXPointPtr ppt)
+{
+    SETUP_BACKING_DST(pDst, pGC);
+
+    PROLOGUE(pGC);
+
+    if (mode == CoordModeOrigin)
+        CW_OFFSET_XYPOINTS(ppt, npt);
+    else
+        CW_OFFSET_XYPOINTS(ppt, 1);
+
+    (*pBackingGC->ops->FillPolygon) (pBackingDst, pBackingGC, shape, mode, npt,
+                                     ppt);
+
+    EPILOGUE(pGC);
+}
+
+static void
+cwPolyFillRect(DrawablePtr pDst, GCPtr pGC, int nrects, xRectangle *pRects)
+{
+    SETUP_BACKING_DST(pDst, pGC);
+
+    PROLOGUE(pGC);
+
+    CW_OFFSET_RECTS(pRects, nrects);
+
+    (*pBackingGC->ops->PolyFillRect) (pBackingDst, pBackingGC, nrects, pRects);
+
+    EPILOGUE(pGC);
+}
+
+static void
+cwPolyFillArc(DrawablePtr pDst, GCPtr pGC, int narcs, xArc * parcs)
+{
+    SETUP_BACKING_DST(pDst, pGC);
+
+    PROLOGUE(pGC);
+
+    CW_OFFSET_RECTS(parcs, narcs);
+
+    (*pBackingGC->ops->PolyFillArc) (pBackingDst, pBackingGC, narcs, parcs);
+
+    EPILOGUE(pGC);
+}
+
+static int
+cwPolyText8(DrawablePtr pDst, GCPtr pGC, int x, int y, int count, char *chars)
+{
+    int result;
+
+    SETUP_BACKING_DST(pDst, pGC);
+
+    PROLOGUE(pGC);
+
+    CW_OFFSET_XY_DST(x, y);
+
+    result = (*pBackingGC->ops->PolyText8) (pBackingDst, pBackingGC, x, y,
+                                            count, chars);
+
+    EPILOGUE(pGC);
+
+    return result;
+}
+
+static int
+cwPolyText16(DrawablePtr pDst, GCPtr pGC, int x, int y, int count,
+             unsigned short *chars)
+{
+    int result;
+
+    SETUP_BACKING_DST(pDst, pGC);
+
+    PROLOGUE(pGC);
+
+    CW_OFFSET_XY_DST(x, y);
+
+    result = (*pBackingGC->ops->PolyText16) (pBackingDst, pBackingGC, x, y,
+                                             count, chars);
+
+    EPILOGUE(pGC);
+    return result;
+}
+
+static void
+cwImageText8(DrawablePtr pDst, GCPtr pGC, int x, int y, int count, char *chars)
+{
+    SETUP_BACKING_DST(pDst, pGC);
+
+    PROLOGUE(pGC);
+
+    CW_OFFSET_XY_DST(x, y);
+
+    (*pBackingGC->ops->ImageText8) (pBackingDst, pBackingGC, x, y, count,
+                                    chars);
+
+    EPILOGUE(pGC);
+}
+
+static void
+cwImageText16(DrawablePtr pDst, GCPtr pGC, int x, int y, int count,
+              unsigned short *chars)
+{
+    SETUP_BACKING_DST(pDst, pGC);
+
+    PROLOGUE(pGC);
+
+    CW_OFFSET_XY_DST(x, y);
+
+    (*pBackingGC->ops->ImageText16) (pBackingDst, pBackingGC, x, y, count,
+                                     chars);
+
+    EPILOGUE(pGC);
+}
+
+static void
+cwImageGlyphBlt(DrawablePtr pDst, GCPtr pGC, int x, int y, unsigned int nglyph,
+                CharInfoPtr * ppci, void *pglyphBase)
+{
+    SETUP_BACKING_DST(pDst, pGC);
+
+    PROLOGUE(pGC);
+
+    CW_OFFSET_XY_DST(x, y);
+
+    (*pBackingGC->ops->ImageGlyphBlt) (pBackingDst, pBackingGC, x, y, nglyph,
+                                       ppci, pglyphBase);
+
+    EPILOGUE(pGC);
+}
+
+static void
+cwPolyGlyphBlt(DrawablePtr pDst, GCPtr pGC, int x, int y, unsigned int nglyph,
+               CharInfoPtr * ppci, void *pglyphBase)
+{
+    SETUP_BACKING_DST(pDst, pGC);
+
+    PROLOGUE(pGC);
+
+    CW_OFFSET_XY_DST(x, y);
+
+    (*pBackingGC->ops->PolyGlyphBlt) (pBackingDst, pBackingGC, x, y, nglyph,
+                                      ppci, pglyphBase);
+
+    EPILOGUE(pGC);
+}
+
+static void
+cwPushPixels(GCPtr pGC, PixmapPtr pBitMap, DrawablePtr pDst, int w, int h,
+             int x, int y)
+{
+    SETUP_BACKING_DST(pDst, pGC);
+
+    PROLOGUE(pGC);
+
+    CW_OFFSET_XY_DST(x, y);
+
+    (*pBackingGC->ops->PushPixels) (pBackingGC, pBitMap, pBackingDst, w, h,
+                                    x, y);
+
+    EPILOGUE(pGC);
+}
diff --git a/miext/cw/cw_render.c b/miext/cw/cw_render.c
new file mode 100644
index 000000000..059d686fb
--- /dev/null
+++ b/miext/cw/cw_render.c
@@ -0,0 +1,383 @@
+/*
+ * Copyright © 2004 Eric Anholt
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Eric Anholt not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Eric Anholt makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * ERIC ANHOLT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL ERIC ANHOLT BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include <string.h>
+
+#include "gcstruct.h"
+#include "windowstr.h"
+#include "cw.h"
+
+#define cwPsDecl(pScreen)	\
+    PictureScreenPtr	ps = GetPictureScreen (pScreen);	\
+    cwScreenPtr		pCwScreen = getCwScreen (pScreen)
+
+#define cwPicturePrivate					\
+    cwPicturePtr    pPicturePrivate = getCwPicture(pPicture)
+
+#define cwSrcPictureDecl							\
+    int		    src_picture_x_off, src_picture_y_off;			\
+    PicturePtr	    pBackingSrcPicture = cwGetBackingPicture(pSrcPicture,	\
+							     &src_picture_x_off,\
+							     &src_picture_y_off)
+
+#define cwDstPictureDecl							\
+    int		    dst_picture_x_off, dst_picture_y_off;			\
+    PicturePtr	    pBackingDstPicture = cwGetBackingPicture(pDstPicture,	\
+							     &dst_picture_x_off,\
+							     &dst_picture_y_off)
+
+#define cwMskPictureDecl							\
+    int		    msk_picture_x_off = 0, msk_picture_y_off = 0;		\
+    PicturePtr	    pBackingMskPicture = (!pMskPicture ? 0 :	    		\
+					  cwGetBackingPicture(pMskPicture,	\
+							      &msk_picture_x_off,\
+							      &msk_picture_y_off))
+
+#define cwPsUnwrap(elt) {	\
+    ps->elt = pCwScreen->elt;	\
+}
+
+#define cwPsWrap(elt,func) {	\
+    pCwScreen->elt = ps->elt;	\
+    ps->elt = func;		\
+}
+
+static cwPicturePtr
+cwCreatePicturePrivate(PicturePtr pPicture)
+{
+    WindowPtr pWindow = (WindowPtr) pPicture->pDrawable;
+    PixmapPtr pPixmap = getCwPixmap(pWindow);
+    int error;
+    cwPicturePtr pPicturePrivate;
+
+    pPicturePrivate = malloc(sizeof(cwPictureRec));
+    if (!pPicturePrivate)
+        return NULL;
+
+    pPicturePrivate->pBackingPicture = CreatePicture(0, &pPixmap->drawable,
+                                                     pPicture->pFormat,
+                                                     0, 0, serverClient,
+                                                     &error);
+    if (!pPicturePrivate->pBackingPicture) {
+        free(pPicturePrivate);
+        return NULL;
+    }
+
+    /*
+     * Ensure that this serial number does not match the window's
+     */
+    pPicturePrivate->serialNumber = pPixmap->drawable.serialNumber;
+    pPicturePrivate->stateChanges = (1 << (CPLastBit + 1)) - 1;
+
+    setCwPicture(pPicture, pPicturePrivate);
+
+    return pPicturePrivate;
+}
+
+static void
+cwDestroyPicturePrivate(PicturePtr pPicture)
+{
+    cwPicturePrivate;
+
+    if (pPicturePrivate) {
+        if (pPicturePrivate->pBackingPicture)
+            FreePicture(pPicturePrivate->pBackingPicture, 0);
+        free(pPicturePrivate);
+        setCwPicture(pPicture, NULL);
+    }
+}
+
+static PicturePtr
+cwGetBackingPicture(PicturePtr pPicture, int *x_off, int *y_off)
+{
+    cwPicturePrivate;
+
+    if (pPicturePrivate) {
+        DrawablePtr pDrawable = pPicture->pDrawable;
+        WindowPtr pWindow = (WindowPtr) pDrawable;
+        PixmapPtr pPixmap = getCwPixmap(pWindow);
+
+        *x_off = pDrawable->x - pPixmap->screen_x;
+        *y_off = pDrawable->y - pPixmap->screen_y;
+
+        return pPicturePrivate->pBackingPicture;
+    }
+    else {
+        *x_off = *y_off = 0;
+        return pPicture;
+    }
+}
+
+static void
+cwDestroyPicture(PicturePtr pPicture)
+{
+    ScreenPtr pScreen = pPicture->pDrawable->pScreen;
+
+    cwPsDecl(pScreen);
+
+    cwPsUnwrap(DestroyPicture);
+    cwDestroyPicturePrivate(pPicture);
+    (*ps->DestroyPicture) (pPicture);
+    cwPsWrap(DestroyPicture, cwDestroyPicture);
+}
+
+static void
+cwChangePicture(PicturePtr pPicture, Mask mask)
+{
+    ScreenPtr pScreen = pPicture->pDrawable->pScreen;
+
+    cwPsDecl(pScreen);
+    cwPicturePtr pPicturePrivate = getCwPicture(pPicture);
+
+    cwPsUnwrap(ChangePicture);
+    (*ps->ChangePicture) (pPicture, mask);
+    if (pPicturePrivate)
+        pPicturePrivate->stateChanges |= mask;
+    cwPsWrap(ChangePicture, cwChangePicture);
+}
+
+static void
+cwValidatePicture(PicturePtr pPicture, Mask mask)
+{
+    DrawablePtr pDrawable = pPicture->pDrawable;
+    ScreenPtr pScreen = pDrawable->pScreen;
+
+    cwPsDecl(pScreen);
+    cwPicturePrivate;
+
+    cwPsUnwrap(ValidatePicture);
+
+    /*
+     * Must call ValidatePicture to ensure pPicture->pCompositeClip is valid
+     */
+    (*ps->ValidatePicture) (pPicture, mask);
+
+    if (!cwDrawableIsRedirWindow(pDrawable)) {
+        if (pPicturePrivate)
+            cwDestroyPicturePrivate(pPicture);
+    }
+    else {
+        PicturePtr pBackingPicture;
+        DrawablePtr pBackingDrawable;
+        int x_off, y_off;
+
+        pBackingDrawable = cwGetBackingDrawable(pDrawable, &x_off, &y_off);
+
+        if (pPicturePrivate &&
+            pPicturePrivate->pBackingPicture->pDrawable != pBackingDrawable) {
+            cwDestroyPicturePrivate(pPicture);
+            pPicturePrivate = 0;
+        }
+
+        if (!pPicturePrivate) {
+            pPicturePrivate = cwCreatePicturePrivate(pPicture);
+            if (!pPicturePrivate) {
+                cwPsWrap(ValidatePicture, cwValidatePicture);
+                return;
+            }
+        }
+
+        pBackingPicture = pPicturePrivate->pBackingPicture;
+
+        /*
+         * Always copy transform and filters because there's no
+         * indication of when they've changed
+         */
+        SetPictureTransform(pBackingPicture, pPicture->transform);
+
+        if (pBackingPicture->filter != pPicture->filter ||
+            pPicture->filter_nparams > 0) {
+            char *filter = PictureGetFilterName(pPicture->filter);
+
+            SetPictureFilter(pBackingPicture,
+                             filter, strlen(filter),
+                             pPicture->filter_params, pPicture->filter_nparams);
+        }
+
+        pPicturePrivate->stateChanges |= mask;
+
+        if (pPicturePrivate->serialNumber != pDrawable->serialNumber ||
+            (pPicturePrivate->
+             stateChanges & (CPClipXOrigin | CPClipYOrigin | CPClipMask))) {
+            SetPictureClipRegion(pBackingPicture, x_off - pDrawable->x,
+                                 y_off - pDrawable->y,
+                                 pPicture->pCompositeClip);
+
+            pPicturePrivate->serialNumber = pDrawable->serialNumber;
+            pPicturePrivate->stateChanges &=
+                ~(CPClipXOrigin | CPClipYOrigin | CPClipMask);
+        }
+
+        CopyPicture(pPicture, pPicturePrivate->stateChanges, pBackingPicture);
+
+        ValidatePicture(pBackingPicture);
+    }
+    cwPsWrap(ValidatePicture, cwValidatePicture);
+}
+
+static void
+cwComposite(CARD8 op,
+            PicturePtr pSrcPicture,
+            PicturePtr pMskPicture,
+            PicturePtr pDstPicture,
+            INT16 xSrc,
+            INT16 ySrc,
+            INT16 xMsk,
+            INT16 yMsk, INT16 xDst, INT16 yDst, CARD16 width, CARD16 height)
+{
+    ScreenPtr pScreen = pDstPicture->pDrawable->pScreen;
+
+    cwPsDecl(pScreen);
+    cwSrcPictureDecl;
+    cwMskPictureDecl;
+    cwDstPictureDecl;
+
+    cwPsUnwrap(Composite);
+    (*ps->Composite) (op, pBackingSrcPicture, pBackingMskPicture,
+                      pBackingDstPicture, xSrc + src_picture_x_off,
+                      ySrc + src_picture_y_off, xMsk + msk_picture_x_off,
+                      yMsk + msk_picture_y_off, xDst + dst_picture_x_off,
+                      yDst + dst_picture_y_off, width, height);
+    cwPsWrap(Composite, cwComposite);
+}
+
+static void
+cwCompositeRects(CARD8 op,
+                 PicturePtr pDstPicture,
+                 xRenderColor * color, int nRect, xRectangle *rects)
+{
+    ScreenPtr pScreen = pDstPicture->pDrawable->pScreen;
+
+    cwPsDecl(pScreen);
+    cwDstPictureDecl;
+    int i;
+
+    cwPsUnwrap(CompositeRects);
+    for (i = 0; i < nRect; i++) {
+        rects[i].x += dst_picture_x_off;
+        rects[i].y += dst_picture_y_off;
+    }
+    (*ps->CompositeRects) (op, pBackingDstPicture, color, nRect, rects);
+    cwPsWrap(CompositeRects, cwCompositeRects);
+}
+
+static void
+cwTrapezoids(CARD8 op,
+             PicturePtr pSrcPicture,
+             PicturePtr pDstPicture,
+             PictFormatPtr maskFormat,
+             INT16 xSrc, INT16 ySrc, int ntrap, xTrapezoid * traps)
+{
+    ScreenPtr pScreen = pDstPicture->pDrawable->pScreen;
+
+    cwPsDecl(pScreen);
+    cwSrcPictureDecl;
+    cwDstPictureDecl;
+    int i;
+
+    cwPsUnwrap(Trapezoids);
+    if (dst_picture_x_off || dst_picture_y_off) {
+        for (i = 0; i < ntrap; i++) {
+            traps[i].top += dst_picture_y_off << 16;
+            traps[i].bottom += dst_picture_y_off << 16;
+            traps[i].left.p1.x += dst_picture_x_off << 16;
+            traps[i].left.p1.y += dst_picture_y_off << 16;
+            traps[i].left.p2.x += dst_picture_x_off << 16;
+            traps[i].left.p2.y += dst_picture_y_off << 16;
+            traps[i].right.p1.x += dst_picture_x_off << 16;
+            traps[i].right.p1.y += dst_picture_y_off << 16;
+            traps[i].right.p2.x += dst_picture_x_off << 16;
+            traps[i].right.p2.y += dst_picture_y_off << 16;
+        }
+    }
+    (*ps->Trapezoids) (op, pBackingSrcPicture, pBackingDstPicture, maskFormat,
+                       xSrc + src_picture_x_off, ySrc + src_picture_y_off,
+                       ntrap, traps);
+    cwPsWrap(Trapezoids, cwTrapezoids);
+}
+
+static void
+cwTriangles(CARD8 op,
+            PicturePtr pSrcPicture,
+            PicturePtr pDstPicture,
+            PictFormatPtr maskFormat,
+            INT16 xSrc, INT16 ySrc, int ntri, xTriangle * tris)
+{
+    ScreenPtr pScreen = pDstPicture->pDrawable->pScreen;
+
+    cwPsDecl(pScreen);
+    cwSrcPictureDecl;
+    cwDstPictureDecl;
+    int i;
+
+    cwPsUnwrap(Triangles);
+    if (dst_picture_x_off || dst_picture_y_off) {
+        for (i = 0; i < ntri; i++) {
+            tris[i].p1.x += dst_picture_x_off << 16;
+            tris[i].p1.y += dst_picture_y_off << 16;
+            tris[i].p2.x += dst_picture_x_off << 16;
+            tris[i].p2.y += dst_picture_y_off << 16;
+            tris[i].p3.x += dst_picture_x_off << 16;
+            tris[i].p3.y += dst_picture_y_off << 16;
+        }
+    }
+    (*ps->Triangles) (op, pBackingSrcPicture, pBackingDstPicture, maskFormat,
+                      xSrc + src_picture_x_off, ySrc + src_picture_y_off,
+                      ntri, tris);
+    cwPsWrap(Triangles, cwTriangles);
+}
+
+void
+cwInitializeRender(ScreenPtr pScreen)
+{
+    cwPsDecl(pScreen);
+
+    cwPsWrap(DestroyPicture, cwDestroyPicture);
+    cwPsWrap(ChangePicture, cwChangePicture);
+    cwPsWrap(ValidatePicture, cwValidatePicture);
+    cwPsWrap(Composite, cwComposite);
+    cwPsWrap(CompositeRects, cwCompositeRects);
+    cwPsWrap(Trapezoids, cwTrapezoids);
+    cwPsWrap(Triangles, cwTriangles);
+    /* There is no need to wrap AddTraps as far as we can tell.  AddTraps can
+     * only be done on alpha-only pictures, and we won't be getting
+     * alpha-only window pictures, so there's no need to translate.
+     */
+}
+
+void
+cwFiniRender(ScreenPtr pScreen)
+{
+    cwPsDecl(pScreen);
+
+    cwPsUnwrap(DestroyPicture);
+    cwPsUnwrap(ChangePicture);
+    cwPsUnwrap(ValidatePicture);
+    cwPsUnwrap(Composite);
+    cwPsUnwrap(CompositeRects);
+    cwPsUnwrap(Trapezoids);
+    cwPsUnwrap(Triangles);
+}
diff --git a/render/picture.c b/render/picture.c
index a53f3b560..f41e2eec5 100644
--- a/render/picture.c
+++ b/render/picture.c
@@ -1354,6 +1354,76 @@ SetPictureTransform(PicturePtr pPicture, PictTransform * transform)
     return Success;
 }
 
+void
+CopyPicture(PicturePtr pSrc, Mask mask, PicturePtr pDst)
+{
+    PictureScreenPtr ps = GetPictureScreen(pSrc->pDrawable->pScreen);
+    Mask origMask = mask;
+
+    pDst->serialNumber |= GC_CHANGE_SERIAL_BIT;
+    pDst->stateChanges |= mask;
+
+    while (mask) {
+        Mask bit = lowbit(mask);
+
+        switch (bit) {
+        case CPRepeat:
+            pDst->repeat = pSrc->repeat;
+            pDst->repeatType = pSrc->repeatType;
+            break;
+        case CPAlphaMap:
+            if (pSrc->alphaMap &&
+                pSrc->alphaMap->pDrawable->type == DRAWABLE_PIXMAP)
+                pSrc->alphaMap->refcnt++;
+            if (pDst->alphaMap)
+                FreePicture((void*) pDst->alphaMap, (XID) 0);
+            pDst->alphaMap = pSrc->alphaMap;
+            break;
+        case CPAlphaXOrigin:
+            pDst->alphaOrigin.x = pSrc->alphaOrigin.x;
+            break;
+        case CPAlphaYOrigin:
+            pDst->alphaOrigin.y = pSrc->alphaOrigin.y;
+            break;
+        case CPClipXOrigin:
+            pDst->clipOrigin.x = pSrc->clipOrigin.x;
+            break;
+        case CPClipYOrigin:
+            pDst->clipOrigin.y = pSrc->clipOrigin.y;
+            break;
+        case CPClipMask:
+            if (!pSrc->clientClip) {
+                (*ps->ChangePictureClip) (pDst, CT_NONE, NULL, 0);
+            } else {
+                RegionPtr clientClip;
+                RegionPtr srcClientClip = (RegionPtr) pSrc->clientClip;
+
+                clientClip = RegionCreate(RegionExtents(srcClientClip),
+                                              RegionNumRects(srcClientClip));
+                (*ps->ChangePictureClip) (pDst, CT_REGION, clientClip, 0);
+            }
+            break;
+        case CPGraphicsExposure:
+            pDst->graphicsExposures = pSrc->graphicsExposures;
+            break;
+        case CPPolyEdge:
+            pDst->polyEdge = pSrc->polyEdge;
+            break;
+        case CPPolyMode:
+            pDst->polyMode = pSrc->polyMode;
+            break;
+        case CPDither:
+            break;
+        case CPComponentAlpha:
+            pDst->componentAlpha = pSrc->componentAlpha;
+            break;
+        }
+        mask &= ~bit;
+    }
+
+    (*ps->ChangePicture) (pDst, origMask);
+}
+
 static void
 ValidateOnePicture(PicturePtr pPicture)
 {
diff --git a/render/picturestr.h b/render/picturestr.h
index dd25a272d..0076d431d 100644
--- a/render/picturestr.h
+++ b/render/picturestr.h
@@ -449,6 +449,9 @@ SetPictureClipRegion(PicturePtr pPicture,
 extern _X_EXPORT int
  SetPictureTransform(PicturePtr pPicture, PictTransform * transform);
 
+extern _X_EXPORT void
+ CopyPicture(PicturePtr pSrc, Mask mask, PicturePtr pDst);
+
 extern _X_EXPORT void
  ValidatePicture(PicturePtr pPicture);
 
-- 
2.26.1

