Description: upstream documentation corrections
 Attempt harmonize and correct the Symmetrica doc files.
 The primary motivation is to render/maintain Symmetrica
 doc files easily parsable --- for Debian the doc files
 were parsed to generate a minimal version-script.
 Also meant to be submitted to the upstream maintainer.
Origin: debian
Author: Jerome Benoit <calculus@rezozer.net>
Last-Update: 2016-05-15

--- a/bar.doc
+++ b/bar.doc
@@ -96,7 +96,7 @@
 		next_bar
 SYNOPSIS:
 		INT next_bar(OP a,b)
-DESCRIPTION
+DESCRIPTION:
 	:	computes the next barred permutation b. The algorithm
 	uses the lehmercode. The last barred permutation will be
 	[-1,-2,-3,...]
@@ -136,7 +136,7 @@
 NAME:
 			t_BAR_BARCYCLE
 SYNOPSIS:
-		INT t_BAR_BARCYCLE(OP a,b);
+		INT t_BAR_BARCYCLE(OP a,b)
 DESCRIPTION:
 		transforms a barred permutation 'a' in list-notation into
 	cycle notation
@@ -146,7 +146,7 @@
 NAME:
 			t_BARCYCLE_BAR
 SYNOPSIS:
-		INT t_BARCYCLE_BAR(OP a,b);
+		INT t_BARCYCLE_BAR(OP a,b)
 DESCRIPTION:
 		transforms a barred permutation 'a' in cycle-notation into
 	list notation
--- a/boe.doc
+++ b/boe.doc
@@ -20,7 +20,7 @@
 NAME:		
 	specht_dg
 SYNOPSIS:	
-	INT  specht_dg(OP a,b,c) 
+	INT specht_dg(OP a,b,c)
 DESCRIPTION:	
 	you enter a PARTITION or SKEWPARTITION object a, and a
 	PERMUTATION object  b, and the output is the corresponding
--- a/classical.doc
+++ b/classical.doc
@@ -159,7 +159,7 @@
 NAME:          
 	gl_dimension
 SYNOPSIS:      
-	INT gl_dimension (OP n, OP partition, OP dim);
+	INT gl_dimension (OP n, OP partition, OP dim)
 DESCRIPTION:   
 	Calculates the dimension of the representation of GL(n)
 	       labelled by the partition. If the number of parts
@@ -174,7 +174,7 @@
 NAME:          
 	sp_dimension
 SYNOPSIS:      
-	INT sp_dimension (OP n, OP partition, OP dim);
+	INT sp_dimension (OP n, OP partition, OP dim)
 DESCRIPTION:   
 	Calculates the dimension of the representation of Sp(n)
 	       labelled by the partition. If the number of parts
@@ -190,7 +190,7 @@
 NAME:  
 	        or_dimension
 SYNOPSIS:
-	      INT or_dimension (OP n, OP partition, OP dim);
+	      INT or_dimension (OP n, OP partition, OP dim)
 DESCRIPTION:
 	   Calculates the dimension of the representation of O(n)
 	       labelled by the partition. If the sum of the first
@@ -206,7 +206,7 @@
 NAME:  
 	        so_dimension
 SYNOPSIS:
-	      INT so_dimension (OP n, OP partition, OP dim);
+	      INT so_dimension (OP n, OP partition, OP dim)
 DESCRIPTION:
 	   Calculates the dimension of the representation of SO(n)
 	       labelled by the partition. If the number of parts
@@ -229,7 +229,7 @@
 NAME:   
 	       pn_dimension
 SYNOPSIS:
-	      INT pn_dimension (OP n, OP partition, OP dim);
+	      INT pn_dimension (OP n, OP partition, OP dim)
 DESCRIPTION:
 	   Calculates the dimension of the spin representation of 
 	       O(n) (the Pin(n) group) labelled by the partition.
@@ -248,7 +248,7 @@
 NAME:  
 	        sn_dimension
 SYNOPSIS:
-	      INT sn_dimension (OP n, OP partition, OP dim);
+	      INT sn_dimension (OP n, OP partition, OP dim)
 DESCRIPTION:
 	   Calculates the dimension of the spin representation of 
 	       SO(n) (the Spin(n) group) labelled by the partition.
@@ -275,7 +275,7 @@
 NAME:   
        gl_tableaux 
 SYNOPSIS:
-      INT gl_tableaux (OP n, OP partition, OP list);
+      INT gl_tableaux (OP n, OP partition, OP list)
 DESCRIPTION:
    Calculates the set of standard tableaux ("semi-standard")
 	       for GL(n), returning a LIST of TABLEAUX in list.
@@ -286,7 +286,7 @@
 NAME: 
          sp_tableaux 
 SYNOPSIS:
-      INT sp_tableaux (OP n, OP partition, OP list);
+      INT sp_tableaux (OP n, OP partition, OP list)
 DESCRIPTION:
    Calculates the set of standard tableaux for Sp(n),
 	       returning a LIST of TABLEAUX in list.
@@ -297,7 +297,7 @@
 NAME:
           or_tableaux 
 SYNOPSIS:
-      INT or_tableaux (OP n, OP partition, OP list);
+      INT or_tableaux (OP n, OP partition, OP list)
 DESCRIPTION:
    Calculates the set of standard tableaux for O(n),
 	       returning a LIST of TABLEAUX in list.
@@ -308,7 +308,7 @@
 NAME:
 	          so_tableaux 
 SYNOPSIS:
-	      INT so_tableaux (OP n, OP partition, INT flag, OP list);
+	      INT so_tableaux (OP n, OP partition, INT flag, OP list)
 DESCRIPTION:
    Calculates the set of standard tableaux for SO(n),
 	       returning a LIST of TABLEAUX in list. flag is used
@@ -322,7 +322,7 @@
 NAME:
           pn_tableaux 
 SYNOPSIS:
-      INT pn_tableaux (OP n, OP partition, OP list);
+      INT pn_tableaux (OP n, OP partition, OP list)
 DESCRIPTION:
    Calculates the set of standard spinor-tableaux for O(n),
 	       returning a LIST of MONOM in list. Each MONOM has
@@ -337,7 +337,7 @@
 NAME:
           sn_tableaux 
 SYNOPSIS:
-      INT sn_tableaux (OP n, OP partition, INT flag, OP list);
+      INT sn_tableaux (OP n, OP partition, INT flag, OP list)
 DESCRIPTION:
    Calculates the set of standard spinor-tableaux for SO(n),
 	       returning a LIST of MONOM in list. Each MONOM has
@@ -360,7 +360,7 @@
 NAME:
           gl_character
 SYNOPSIS:
-      INT gl_character (OP n, OP partition, OP character);
+      INT gl_character (OP n, OP partition, OP character)
 DESCRIPTION:
    Calculates the character of the representation of GL(n)
 	       labelled by partition. This is the Schur function.
@@ -372,7 +372,7 @@
 NAME:
           sp_character
 SYNOPSIS:
-      INT sp_character (OP n, OP partition, OP character);
+      INT sp_character (OP n, OP partition, OP character)
 DESCRIPTION:
    Calculates the character of the representation of Sp(n)
 	       labelled by partition. It is returned as a POLYNOM
@@ -384,7 +384,7 @@
 NAME:
           or_character
 SYNOPSIS:
-      INT or_character (OP n, OP partition, OP character);
+      INT or_character (OP n, OP partition, OP character)
 DESCRIPTION:
    Calculates the character of the representation of O(n)
 	       labelled by partition. It is returned as a POLYNOM
@@ -396,7 +396,7 @@
 NAME:
           so_character
 SYNOPSIS:
-      INT so_character (OP n, OP partition, INT flag, OP character);
+      INT so_character (OP n, OP partition, INT flag, OP character)
 DESCRIPTION:
    Calculates the character of the representation of SO(n)
 	       labelled by partition. It is returned as a POLYNOM
@@ -411,7 +411,7 @@
 NAME:
           pn_character
 SYNOPSIS:
-      INT pn_character (OP n, OP partition, OP character);
+      INT pn_character (OP n, OP partition, OP character)
 DESCRIPTION:
    Calculates the spin character of the representation of
 	       O(n) labelled by partition. It is returned as a
@@ -424,7 +424,7 @@
 NAME:
           sn_character
 SYNOPSIS:
-      INT sn_character (OP n, OP partition, INT flag, OP character);
+      INT sn_character (OP n, OP partition, INT flag, OP character)
 DESCRIPTION:
    Calculates the spin character of the representation of
 	       SO(n) labelled by partition. It is returned as a
--- a/ff.doc
+++ b/ff.doc
@@ -56,7 +56,7 @@
 NAME:	
 	s_ff_di
 SYNOPSIS: 
-	INT 	s_ff_di(OP ff)
+	INT s_ff_di(OP ff)
 DESCRIPTION: 
 	gives the degree of the extension as an INT value
 
@@ -91,7 +91,7 @@
 	builds a FF object res, whose characteristic is given
 	by the INTEGER object a. The second parameter vec is a VECTOR
 	object with INTEGER entries between 0 and char-1. These are
-	the coefficents of the FF object res according to the 
+	the coefficients of the FF object res according to the
 	internally used, not documented, basis.
 
 NAME:	
--- a/ga.doc
+++ b/ga.doc
@@ -6,7 +6,7 @@
 	of objects is GRAL (for group algebra). The type of the self part
 	is a permutation instead of a vector as in the case of POLYNOM.
 	So a general object of type GRAL is a list of permutations with
-	arbitrary coefficents.
+	arbitrary coefficients.
 	For the selection of parts you have to use the macros for polynom
 	objects (up to now)
 	There are two routines for the construction
@@ -30,6 +30,8 @@
 	hplus_hecke
 SYNOPSIS:	
 	INT hplus_hecke(OP a,b)
+DESCRIPTION:
+	none
 
 NAME:		
 	hplus
@@ -46,11 +48,15 @@
 	vminus_hecke
 SYNOPSIS:	
 	INT vminus_hecke(OP a,b)
+DESCRIPTION:
+	none
 
 NAME:		
 	vminus_tabloid
 SYNOPSIS:	
 	INT vminus_tabloid(OP a,b)
+DESCRIPTION:
+	none
 
 NAME:		
 	vminus
@@ -70,7 +76,7 @@
 DESCRIPTION:	
 	computes a random element of the group algebra. The degree
 	of the involved permutations is given by the INTEGER object a. The
-	coefficents are INTEGER object given by random_integer, so they lay
+	coefficients are INTEGER object given by random_integer, so they lay
 	between -10 and 10. There are maximal ten terms.
 
 NAME:		
--- a/hiccup.doc
+++ b/hiccup.doc
@@ -441,7 +441,7 @@
 NAME:  
         hecke_scale
 SYNOPSIS: 
-     INT hecke_scale (OP hecke, OP power, OP coeff); 
+     INT hecke_scale (OP hecke, OP power, OP coeff)
 DESCRIPTION:
    The hecke algebra element hecke which is a linear
 	       combinations of permutations as described in the
@@ -475,8 +475,7 @@
 INT root_dimension (OP partition, OP p_root, OP dim);
 INT generate_root_tableaux (OP partition, OP p_root, OP std);
 INT hecke_root_generator_reps (OP partition, OP p_root, OP vector);
-INT root_represent_hecke_action (OP partition, 
-				  OP p_root, OP hecke, OP mat);
+INT root_represent_hecke_action (OP partition, OP p_root, OP hecke, OP mat);
 INT root_standardise_cold_tableaux_list (OP tableaux, OP p_root, OP result);
 
 
@@ -493,7 +492,7 @@
 
 INT hecke_add (OP hecke1, OP hecke2, OP result);
 INT hecke_mult (OP hecke1, OP hecke2, OP result);
-INT hecke_scale (OP hecke, OP power, OP coeff); 
+INT hecke_scale (OP hecke, OP power, OP coeff);
 
 
 /********************************************************************
--- a/integer.doc
+++ b/integer.doc
@@ -33,18 +33,18 @@
 NAME:   
         m_i_i
 SYNOPSIS:   
-	    INT m_i_i(INT integer; OP integerobject)
-DESCRIPTION: 
+	    INT m_i_i(INT integer, OP integerobject)
+MACRO:
+      M_I_I
+DESCRIPTION:
   builds an integerobject with value integer. First
-	it is checked whether integerobject is an empty object, if 
-	not it is freed first.
+  it is checked whether integerobject is an empty object, if
+  not it is freed first.
+  The macro version M_I_I does the same but without a check
+  on empty object.
 RETURN:
          the returnvalue is OK, or ERROR if an error
 	occured.
-MACRO:
-          there is also a macro version M_I_I which does the
-	same without a check on empty object.
-
 
 COMMENT:
 	If you have an INTEGERobject you sometimes want to select the
@@ -64,16 +64,17 @@
 
 NAME: 
 	          s_i_i
-SYNOPSIS:      
+SYNOPSIS:
 	 INT s_i_i(OP integerobject)
+MACRO:
+	 S_I_I
 DESCRIPTION:
-	    selects the INTvalue of integerobject. There is
+	selects the INTvalue of integerobject. There is
 	first a check whether it is an INTEGERobject or not.
+	The macro version S_I_I does the same but without a
+	check on INTEGERobject.
 RETURN:
 	         the returnvalue is the INTvalue or ERROR if an error occured
-MACRO: 
-	         there is also a macro version S_I_I which does the
-	same without a check on INTEGERobject.
 
 
 COMMENT:
@@ -91,18 +92,19 @@
 	will first print a line with the number 5, and then a line with the
 	number 7.
 
-NAME:           
-	c_i_i              
+NAME:
+	c_i_i
 SYNOPSIS:
-	       INT c_i_i(OP integerobject;INT integervalue)
-DESCRIPTION: 
+	       INT c_i_i(OP integerobject, INT integervalue)
+MACRO:
+	       C_I_I
+DESCRIPTION:
 	   changes the INTvalue of integerobject. There is
 	first a check whether it is an INTEGERobject or not.
+	The version C_I_I does the same but without a check
+	on INTEGERobject.
 RETURN:
 	         the returnvalue is OK or ERROR if an error occured
-MACRO:         
- there is also a macro version C_I_I which does the
-	same without a check on INTEGERobject.
 
 COMMENT:
 	For sake of consistency there is also a routine b_i_i(), which means
@@ -159,7 +161,7 @@
 NAME:
 			scan_integer
 SYNOPSIS:
-		INT scan_integer( OP a)
+		INT scan_integer(OP a)
 DESCRIPTION:
 		the sub routine for reading interactivly an
 	INTEGER object. There will be an error message if it was not possible
@@ -258,10 +260,11 @@
 	as you often need special INTEGER objects, there are some global
 	INTEGER objects, there are:
 
-	OP cons_eins			the INTEGER object with value 1
-	OP cons_null			the INTEGER object with value 0
-	OP cons_zwei			the INTEGER object with value 2
-	OP cons_negeins			the INTEGER object with value -1
+	OP cons_eins     the INTEGER object with value  1
+	OP cons_null     the INTEGER object with value  0
+	OP cons_zwei     the INTEGER object with value  2
+	OP cons_drei     the INTEGER object with value  3
+	OP cons_negeins  the INTEGER object with value -1
 
 	so you may use these global variables instead of generating your
 	own variables containing these often used INTEGER objects. But you 
@@ -269,7 +272,41 @@
 	variables. This will generate bad results in all the routines 
 	which trust on the values of these global variables.
 
+NAME:
+	cons_eins
+SYNOPSIS:
+	OP cons_eins
+DESCRIPTION:
+	the INTEGER object with value 1
 
+NAME:
+	cons_null
+SYNOPSIS:
+	OP cons_null
+DESCRIPTION:
+	the INTEGER object with value 0
+
+NAME:
+	cons_zwei
+	cons_two
+SYNOPSIS:
+	OP cons_zwei
+DESCRIPTION:
+	the INTEGER object with value 2
+
+NAME:
+	cons_drei
+SYNOPSIS:
+	OP cons_drei
+DESCRIPTION:
+	the INTEGER object with value 3
+
+NAME:
+	cons_negeins
+SYNOPSIS:
+	OP cons_negeins
+DESCRIPTION:
+	the INTEGER object with value -1
 
 	GENERAL ROUTINES
 	----------------
--- a/io.doc
+++ b/io.doc
@@ -5,7 +5,7 @@
 NAME:  
 	     display
 SYNOPSIS: 
-	  INT display( OP a)
+	  INT display(OP a)
 DESCRIPTION:
 	 This is a old routine to provide  nice output of special 
         objects. 
@@ -18,7 +18,7 @@
 NAME:  
 	     ferrers
 SYNOPSIS:
-	   INT ferrers( OP a)
+	   INT ferrers(OP a)
 DESCRIPTION:
 	 prints the Ferrers diagramm of a PARTITION object to
         stdout.
--- a/list.doc
+++ b/list.doc
@@ -7,7 +7,44 @@
 which is again a LIST object. If the next-part is NULL,
 we are at the end of the list.
 
-To select parts of a LIST object we have standard macros and 
+NAME:
+	s_l_s
+SYNOPSIS:
+	OP s_l_s()
+MACRO:
+	S_L_S
+DESCRIPTION:
+	see comment
+
+NAME:
+	c_l_s
+SYNOPSIS:
+	INT c_l_s()
+MACRO:
+	C_L_S
+DESCRIPTION:
+	see comment
+
+NAME:
+	s_l_n
+SYNOPSIS:
+	OP s_l_n()
+MACRO:
+	S_L_N
+DESCRIPTION:
+	see comment
+
+NAME:
+	c_l_n
+SYNOPSIS:
+	INT c_l_n()
+MACRO:
+	C_L_N
+DESCRIPTION:
+	see comment
+
+COMMENT:
+To select parts of a LIST object we have standard macros and
 routines:
 
 NAME                    MACRO              description
@@ -20,12 +57,13 @@
 For the construction of a LIST object there are
 m_sn_l and b_sn_l, whose description follows.
 
-NAME:          
+NAME:
                  b_sn_l
-SYNOPSIS:       
+SYNOPSIS:
                  INT b_sn_l(OP self,next,result)
-DESCRIPTION:     constructs a new LIST object using 
-      build (using the parameters as partsof the result). 
+DESCRIPTION:
+	constructs a new LIST object using
+  build (using the parameters as partsof the result).
 	If the parameters are NULL
       than there is no difference between b_sn_l and m_sn_l.
       First it frees the memory of result, if result is not
@@ -90,8 +128,7 @@
 NAME:         
 	insert_list
 SYNOPSIS:     
-	INT insert_list(OP element, list
-                       INT (* eqhandle)(), (* compfunction)() )
+	INT insert_list(OP element, list; INT (* eqhandle)(), (* compfunction)() )
 DESCRIPTION:  
 	inserts the element into the LIST object list. 
 	The second parameter list must be a LIST object. 
@@ -127,7 +164,7 @@
 NAME:           
 	lastp_list
 SYNOPSIS:       
-	INT lastp_list(OP l)
+	INT lastp_list(OP list)
 DESCRIPTION:    
 	true if next == NULL
 	a test whether we are at the end of a list
@@ -154,7 +191,7 @@
 NAME:           
 	t_LIST_VECTOR 
 SYNOPSIS:       
-	INT t_LIST_VECTOR(OP list,OP vector)
+	INT t_LIST_VECTOR(OP list, OP vector)
 DESCRIPTION:    
 	builds a VECTOR whose entries are copies
 	      of the entries of the LIST object.
--- a/moddg.doc
+++ b/moddg.doc
@@ -5,7 +5,7 @@
 NAME:		
 	brauer_char
 SYNOPSIS:	
-	INT brauer_char(OP sn,OP prime,OP bc)
+	INT brauer_char(OP sn, OP prime, OP bc)
 DESCRIPTION:
 	computes the table (MATRIX object) of brauer characters for the
 	symmetric group of degree sn (INTEGER object) and given prime
@@ -14,7 +14,7 @@
 NAME:       
 	decp_mat
 SYNOPSIS:  
-	INT decp_mat(OP n,OP p,OP dmat) 
+	INT decp_mat(OP n, OP p, OP dmat)
 DESCRIPTION: 
 	computes the decomposition matrix to the symmetric 
 	group Sn of degree n for the prime p.
@@ -47,7 +47,7 @@
 NAME:
 	moddg
 SYNOPSIS:
-	INT moddg(prime,llambda,pi,dmat) OP prime; OP llambda; OP pi; OP dmat;
+	INT moddg(OP prime, OP llambda, OP pi, OP dmat)
 DESCRIPTION:
 	computes a modular irreducible representation for the PERMUTATION object
 	pi. The result is a MATRIX object with INTEGER entries. The representation is 
--- a/nb.doc
+++ b/nb.doc
@@ -90,7 +90,7 @@
 NAME:             
 	integer_factors_to_integer
 SYNOPSIS:         
-	INT integer_factors_to_integer(OP l,OP a)
+	INT integer_factors_to_integer(OP l, OP a)
 DESCRIPTION:      
 	l is a MONOPOLY representing the factorization of an integer
     into integers with integer exponents.  These factors are combined to reform
@@ -102,7 +102,7 @@
 NAME:  
 	   make_coprimes
 SYNOPSIS: 
-	INT make_coprimes(OP number,OP result)
+	INT make_coprimes(OP number, OP result)
 DESCRIPTION:
 	      Given the number n, which should be a positive INTEGER or
     LONGINT or a MONOPOLY representing a factorisation of an integer greater
@@ -114,7 +114,7 @@
 NAME:      
        euler_phi
 SYNOPSIS:
-         INT euler_phi(OP a,OP b)
+         INT euler_phi(OP a, OP b)
 DESCRIPTION:
      Determines the number of numbers coprime to an integer a
     and returns it in b. The object a may be INTEGER object or LONGINT object.
@@ -126,7 +126,7 @@
 NAME:             
 	ganzsquareroot_longint
 SYNOPSIS:         
-	INT ganzsquareroot_longint(OP a,OP b)
+	INT ganzsquareroot_longint(OP a, OP b)
 DESCRIPTION:      
 	a is a non-negative LONGINT object.
     b is set to the integer part of its square root.  In this case, the return
@@ -139,7 +139,7 @@
 NAME:             
                   ganzsquareroot_integer
 SYNOPSIS:         
-	INT ganzsquareroot_integer(OP a,OP b)
+	INT ganzsquareroot_integer(OP a, OP b)
 DESCRIPTION:      
 	 a is a non-negative INTEGER object.
     b is set to the integer part of its square root.  In this case, the return
@@ -182,7 +182,7 @@
 NAME:  
 	           first_prime_factor
 SYNOPSIS:
-	 INT first_prime_factor(OP a,OP first_prime)
+	 INT first_prime_factor(OP a, OP first_prime)
 DESCRIPTION:
       This routine finds the smallest prime factor of an integer
     a. The prime found is returned as first_prime.
@@ -193,7 +193,7 @@
 NAME:  
 	   square_free_part
 SYNOPSIS:
-	 INT square_free_part(OP a,OP b,OP c,OP la,OP lb,OP lc)
+	 INT square_free_part(OP a, OP b, OP c, OP la, OP lb, OP lc)
 DESCRIPTION:
 	      This routine find the square-free part of the integer a,
     i.e. the product of the prime factors which occur to an odd exponent and -1,
@@ -213,7 +213,7 @@
 NAME:      
        square_free_part_0
 SYNOPSIS:
-     INT square_free_part_0( OP la,lb,lc)
+     INT square_free_part_0(OP la,lb,lc)
 DESCRIPTION:
       This routine find the square-free part of the integer, which
     is given as a prime factors list la -- a MONOPOLY containing the prime
@@ -228,7 +228,7 @@
 NAME:   
           jacobi
 SYNOPSIS:
-         INT jacobi(a,b,c) OP a,b,c;
+         INT jacobi(OP a,b,c)
 DESCRIPTION:
       The Jacobi Symbol: (a/b) b odd.  a and b are integers.  c must
     point to a location different from a and b. If a and b have a common factor,
@@ -240,7 +240,7 @@
 NAME:
              kronecker
 SYNOPSIS:
-         INT kronecker(a,b,c) OP a,b,c;
+         INT kronecker(OP a,b,c)
 DESCRIPTION: 
      The Kronecker Symbol: (a/b). a square-free and congruent to
     0 or 1 mod 4.  a and b are integers.  c must point to a location different
@@ -254,7 +254,7 @@
 NAME:             
 	b_skn_mp
 SYNOPSIS:  
-	 INT b_skn_mp( OP s,k,n,e)
+	 INT b_skn_mp(OP s,k,n,e)
 DESCRIPTION: 
 	     Build a monopoly whose self is s, coefficient is
     k and next is n.  b_skn_mp uses the objects supplied as arguments, while
@@ -266,7 +266,7 @@
 NAME:             
 	m_skn_mp
 SYNOPSIS:  
-	 INT m_skn_mp( OP s,k,n,e)
+	 INT m_skn_mp(OP s,k,n,e)
 DESCRIPTION: 
 	     Make a monopoly whose self is s, coefficient is
     k and next is n.  b_skn_mp uses the objects supplied as arguments, while
@@ -320,7 +320,7 @@
 NAME:             
 	scan_monopoly
 SYNOPSIS:        
-	 INT scan_monopoly(a) OP a;
+	 INT scan_monopoly(OP a)
 DESCRIPTION:   
 	   Routines for inputting a monopoly from stdin. scan_monopoly
     requests the type of self and coefficient.  It then transfers control to
@@ -333,7 +333,7 @@
 NAME:             
 	remove_zero_terms
 SYNOPSIS: 
-	        INT remove_zero_terms(a) OP a;
+	        INT remove_zero_terms(OP a)
 DESCRIPTION:
 	      Removes those terms from a MONOPOLY with zero coefficients
     unless this makes the list empty.  In this case, one term with self and
@@ -345,7 +345,7 @@
 NAME:
 	add_scalar_monopoly
 SYNOPSIS:
-		INT add_scalar_monopoly( OP a,b,c)
+		INT add_scalar_monopoly(OP a,b,c)
 DESCRIPTION:
 	subroutine of add
 
@@ -353,14 +353,14 @@
 NAME:
 	mult_scalar_monopoly
 SYNOPSIS:
-		INT mult_scalar_monopoly( OP a,b,c)
+		INT mult_scalar_monopoly(OP a,b,c)
 DESCRIPTION:
         subroutine of  mult
 
 NAME:
 	add_monopoly_monopoly
 SYNOPSIS:	
-	INT add_monopoly_monopoly( OP a, b, c)
+	INT add_monopoly_monopoly(OP a, b, c)
 DESCRIPTION:
         subroutine of add
 
@@ -377,7 +377,7 @@
 NAME:
 	add_monopoly
 SYNOPSIS:
-		INT add_monopoly( OP a,b,c)
+		INT add_monopoly(OP a,b,c)
 DESCRIPTION:
         subroutine of add
 
@@ -386,7 +386,7 @@
 NAME:
 	add_apply_monopol
 SYNOPSIS:	
-	INT add_apply_monopoly( OP a,b)
+	INT add_apply_monopoly(OP a,b)
 DESCRIPTION: 	
 	Addition of objects of type INTEGER, 
 	LONGINT, BRUCH and MONOPOLY. Subroutine of add_apply
@@ -394,7 +394,8 @@
 
 NAME:
 	mult_monopoly
-SYNOPSIS:	INT mult_monopoly( OP a,b,c)
+SYNOPSIS:
+	INT mult_monopoly(OP a,b,c)
 DESCRIPTION:	
 	for the multiplication of a object a of type MONOPOLY
 	with an arbitray object b, the result is the object c.
@@ -414,15 +415,15 @@
 NAME:
 	 addinvers_monopoly
 SYNOPSIS:	
-	INT addinvers_monopoly( OP a,b)
+	INT addinvers_monopoly(OP a,b)
 DESCRIPTION:
 	subroutine of the general routine addinvers
 
 NAME:
 	addinvers_apply_monopoly
 SYNOPSIS:	
-	INT addinvers_apply_monopoly(OP a) 
-DESCRITPION:
+	INT addinvers_apply_monopoly(OP a)
+DESCRIPTION:
 	subroutine of the general routine addinvers_apply
 
 NAME:
@@ -444,7 +445,7 @@
 NAME:             
 	quores_monopoly
 SYNOPSIS:     
-    INT quores_monopoly( OP poly,dpoly,qpoly,rpoly)
+    INT quores_monopoly(OP poly,dpoly,qpoly,rpoly)
 DESCRIPTION:      
 	Carries out the division algorithm on polynomials of one
     variable to find the quotient (qpoly) and remainder (rpoly).  The result
@@ -457,7 +458,7 @@
 NAME:  
            raise_power_monopoly
 SYNOPSIS:
-         INT raise_power_monopoly( OP a, b)
+         INT raise_power_monopoly(OP a, b)
 DESCRIPTION: 
      Multiplies all the self components of the terms of the
     monopoly b by the scalar a.  Viewing the monopoly as a polynomial p(x),
@@ -468,7 +469,7 @@
 NAME:             
 	scale_monopoly
 SYNOPSIS:  
-	       INT scale_monopoly(a,b) OP a, b;
+	       INT scale_monopoly(OP a,b)
 DESCRIPTION:
 	      Viewing the monopoly b as a polynomial p(x), the effect of
     this routine is to replace it by p(a*x).
@@ -478,7 +479,7 @@
 NAME:  
 	           objectread_monopoly
 SYNOPSIS:
-	         INT objectread_monopoly(f,a) FILE *f; OP a;
+	         INT objectread_monopoly(FILE *f, OP a)
 DESCRIPTION:
 	      Reads a monopoly a from the stream f.
 RETURN:
@@ -487,7 +488,7 @@
 NAME:  
 	           tex_monopoly
 SYNOPSIS:
-	         INT tex_monopoly(a) OP a;
+	         INT tex_monopoly(OP a)
 DESCRIPTION:
 	      Outputs a monopoly in a form suitable for TeX processing.
     It is treated as a polynomial in x. Subroutine of the general routine
@@ -499,7 +500,7 @@
 NAME:  
 	           make_unitary0_monopoly
 SYNOPSIS:
-	         INT make_unitary0_monopoly(number,result) OP number, result;
+	         INT make_unitary0_monopoly(OP number,result)
 DESCRIPTION:
 	      Given the number n, which should be an positive INTEGER or
     LONGINT, the result returns the monopoly corresponding to x**n-1.
@@ -509,7 +510,7 @@
 NAME:  
 	           make_unitary1_monopoly
 SYNOPSIS:
-	         INT make_unitary1_monopoly(number,result) OP number, result;
+	         INT make_unitary1_monopoly(OP number,result)
 DESCRIPTION:
 	      Given the number n, which should be an positive INTEGER or
     LONGINT, the result returns the MONOPOLY x**(n-1) + x**(n-2) + ... + x + 1.
@@ -519,7 +520,7 @@
 NAME:  
 	           make_cyclotomic_monopoly
 SYNOPSIS:
-	         INT make_cyclotomic_monopoly(number,result) OP number, result;
+	         INT make_cyclotomic_monopoly(OP number,result)
 DESCRIPTION: 
 	     Given the number n, which should be an positive INTEGER or
     LONGINT or a MONOPOLY representing a factorisation of an integer greater
@@ -531,7 +532,7 @@
 NAME:
 			t_MONOPOLY_POLYNOM
 SYNOPSIS:	
-	INT t_MONOPOLY_POLYNOM(OP a,b) 
+	INT t_MONOPOLY_POLYNOM(OP a,b)
 DESCRIPTION:	
 	converts a MONOPOLY object  a into a POLYNOM object b
 	with one variable.
@@ -540,7 +541,7 @@
 NAME: 
 	            eq_fieldobject_int
 SYNOPSIS:
-	         INT eq_fieldobject_int(type,a,i) OBJECTKIND type; OP a; INT i;
+	         INT eq_fieldobject_int(OBJECTKIND type, OP a, INT i)
 DESCRIPTION:
 	      Determines if the 'field object' (a monopoly, sqrad or cyclo)
     is equal to the integer i.  Returns OK for equality. There are six
@@ -557,8 +558,7 @@
 NAME:  
                   b_ksd_n
 SYNOPSIS: 
-                  INT b_ksd_n(kind,self,data,result) OBJECTKIND kind;
-                        OP self,data,result;
+                  INT b_ksd_n(OBJECTKIND kind; OP self,data,result)
 DESCRIPTION:
 	       build a number object (sqrad or cyclo), whose type
     is 'kind', and with the given self and data.  b_ksd_n uses the objects
@@ -569,8 +569,7 @@
 NAME:  
 	           m_ksd_n
 SYNOPSIS: 
-	        INT m_ksd_n(kind,self,data,result) OBJECTKIND kind;
-                        OP self,data,result;
+	        INT m_ksd_n(OBJECTKIND kind; OP self,data,result)
 DESCRIPTION:
 	      Make a number object (sqrad or cyclo), whose type
     is 'kind', and with the given self and data.  b_ksd_n uses the objects
@@ -581,7 +580,7 @@
 NAME:             
 	objectwrite_number
 SYNOPSIS:
-	  INT objectwrite_number(f,number) FILE *f; OP number;
+	  INT objectwrite_number(FILE *f, OP number)
 DESCRIPTION:   
 	   writes a number (sqrad or cyclo)
     to a stream.  In the case of a cyclo, the only part of the data
@@ -592,7 +591,7 @@
 NAME:             
 	objectread_number
 SYNOPSIS: 
-       INT objectread_number( FILE *f; OP number; OBJECTKIND type)
+       INT objectread_number(FILE *f, OP number, OBJECTKIND type)
 DESCRIPTION:   
 	   Reads a number (sqrad or cyclo) from 
      a stream.  In the case of a cyclo, the only part of the data
@@ -605,7 +604,7 @@
 NAME:            
 	 fprint_number
 SYNOPSIS: 
-	        INT fprint_number(f,n) FILE *f; OP n;
+	        INT fprint_number(FILE *f, OP n)
 DESCRIPTION:
 	      Prints the number n on the stream f.  The self is printed
     first and is separated by a colon from the data list in the case of a sqrad
@@ -629,7 +628,7 @@
 NAME:  
 	           mult_lists
 SYNOPSIS: 
-	        INT mult_lists(a,b,c) OP a, b, c;
+	        INT mult_lists(OP a,b,c)
 DESCRIPTION:
 	      Multiplies the entries in two lists pairwise, putting the
     resulting objects in a list.  Duplicate objects are ignored.
@@ -639,7 +638,7 @@
 NAME:  
 	           tidy
 SYNOPSIS:
-	         INT tidy(a) OP a;
+	         INT tidy(OP a)
 DESCRIPTION:
 	      Tidies up an object which contains cyclos in some of its
     components.  Such cyclos are reduced modulo the cyclotomic polynomial.
@@ -650,7 +649,7 @@
 NAME: 
             make_monopoly_sqrad
 SYNOPSIS:
-         INT make_monopoly_sqrad(a,b) OP a,b;
+         INT make_monopoly_sqrad(OP a,b)
 DESCRIPTION:
       Makes b a sqrad whose self is a copy of the monopoly a.
     Also determines the data of the sqrad.
@@ -660,7 +659,7 @@
 NAME:
              make_scalar_sqrad
 SYNOPSIS:
-         INT make_scalar_sqrad(a,b) OP a,b;
+         INT make_scalar_sqrad(OP a,b)
 DESCRIPTION:
       Makes b a sqrad whose self is 1 and whose coefficient is a.
 RETURN:
@@ -669,7 +668,7 @@
 NAME:  
            scan_sqrad
 SYNOPSIS: 
-        INT scan_sqrad(a) OP a;
+        INT scan_sqrad(OP a)
 DESCRIPTION:
       Input a sqrad directly from standard input.
 RETURN:
@@ -679,42 +678,42 @@
 NAME:
 	 add_scalar_sqrad
 SYNOPSIS:
-	INT add_scalar_sqrad(a,b,c) OP a,b,c;
+	INT add_scalar_sqrad(OP a,b,c)
 DESCRIPTION:
 	this is a subroutine  of the general routine add
 
 NAME:
 	 mult_scalar_sqrad
 SYNOPSIS:
-	INT mult_scalar_sqrad(a,b,c) OP a, b, c;
+	INT mult_scalar_sqrad(OP a,b,c)
 DESCRIPTION:
         this is a subroutine  of the general routine mult
 
 NAME:
 	add_sqrad_sqrad
 SYNOPSIS:
-	INT add_sqrad_sqrad(a,b,c) OP a, b, c;
+	INT add_sqrad_sqrad(OP a,b,c)
 DESCRIPTION:
         this is a subroutine  of the general routine add
 
 NAME:
 	mult_sqrad_sqrad
 SYNOPSIS:
-	INT mult_sqrad_sqrad(a,b,c) OP a, b, c;
+	INT mult_sqrad_sqrad(OP a,b,c)
 DESCRIPTION:
         this is a subroutine  of the general routine mult
 
 NAME:
 	add_sqrad
 SYNOPSIS:
-	INT add_sqrad(a,b,c) OP a,b,c;
+	INT add_sqrad(OP a,b,c)
 DESCRIPTION:
         this is a subroutine  of the general routine add
 
 NAME:
 	add_apply_sqrad
 SYNOPSIS:
-	INT add_apply_sqrad(a,b) OP a,b;
+	INT add_apply_sqrad(OP a,b)
 DESCRIPTION:
     Addition of objects of type INTEGER, LONGINT, BRUCH, POLYNOM,
     SQ_RADICA or CYCLOTOMIC.
@@ -723,14 +722,14 @@
 NAME:
 	mult_sqrad
 SYNOPSIS:
-	INT mult_sqrad(a,b,c) OP a,b,c;
+	INT mult_sqrad(OP a,b,c)
 DESCRIPTION:
         this is a subroutine  of the general routine mult
 
 NAME:
 	mult_apply_sqrad
 SYNOPSIS:
-	INT mult_apply_sqrad(a,b) OP a,b;
+	INT mult_apply_sqrad(OP a,b)
 DESCRIPTION:
     Multiplication of objects the first of type SQ_RADICAL and the second of
     type INTEGER, LONGINT, CYCLOTOMIC, BRUCH, MATRIX, MONOM, VECTOR,
@@ -740,40 +739,40 @@
 NAME:
 	addinvers_sqrad
 SYNOPSIS:
-	INT addinvers_sqrad(a,b) OP a,b;
+	INT addinvers_sqrad(OP a,b)
 DESCRIPTION:
         this is a subroutine  of the general routine addinvers
 
 NAME:
 	addinvers_apply_sqrad
 SYNOPSIS:
-	INT addinvers_apply_sqrad(a) OP a;
+	INT addinvers_apply_sqrad(OP a)
 DESCRIPTION:
         this is a subroutine  of the general routine addinvers_apply
 
 NAME:
 	invers_sqrad
 SYNOPSIS:
-	INT invers_sqrad(a,b) OP a,b;
+	INT invers_sqrad(OP a,b)
 DESCRIPTION:
 	this is a subroutine  of the general routine invers
 
 NAME:
 	nullp_sqrad
 SYNOPSIS:
-	INT nullp_sqrad(a) OP a;
+	INT nullp_sqrad(OP a)
 DESCRIPTION:
 	this is a subroutine  of the general routine nullp
 
 SYNOPSIS:
-	INT comp_sqrad(a,b) OP a,b;
+	INT comp_sqrad(OP a,b)
 DESCRIPTION:     
 	Uses comp_list on the self fields.
 
 NAME:   
 	          tex_sqrad
 SYNOPSIS: 
-	        INT tex_sqrad(a) OP a;
+	        INT tex_sqrad(OP a)
 DESCRIPTION:
 	      Outputs a sqrad in a form suitable for TeX processing.
     Each term of the self is expressed in the form: coefficient * \sqrt (self).
@@ -783,7 +782,7 @@
 NAME:  
 	           squareroot_integer
 SYNOPSIS:
-	         INT squareroot_integer(a,b) OP a,b;
+	         INT squareroot_integer(OP a,b)
 DESCRIPTION:
 	      b is a sqrad whose square is the scalar a, which is a
 	INTEGER object. This is a
@@ -795,7 +794,7 @@
 NAME:  
                   squareroot_longint
 SYNOPSIS:
-                  INT squareroot_longint(a,b) OP a,b;
+                  INT squareroot_longint(OP a,b)
 DESCRIPTION:
 	      b is a sqrad whose square is the scalar a, which is a
 	LONGINT object. This is a
@@ -806,7 +805,7 @@
 NAME:  
                   squareroot_bruch
 SYNOPSIS:
-                  INT squareroot_bruch(a,b) OP a,b;
+                  INT squareroot_bruch(OP a,b)
 DESCRIPTION:
 	      b is a sqrad whose square is the scalar a, which is a
 	BRUCH object. This is a
@@ -819,7 +818,7 @@
 NAME:  
 	           convert_radical_cyclo
 SYNOPSIS:
-	         INT convert_radical_cyclo(a,b) OP a,b;
+	         INT convert_radical_cyclo(OP a,b)
 DESCRIPTION:
 	      Converts the square root of an integer a to a cyclo b.
 RETURN:
@@ -829,7 +828,7 @@
 NAME:
 	             trans_index_monopoly_cyclo
 SYNOPSIS: 
-	        INT trans_index_monopoly_cyclo(a,b,c) OP a,b,c;
+	        INT trans_index_monopoly_cyclo(OP a,b,c)
 DESCRIPTION: 
 	     Given a positive integer a and a monopoly b corresponding to
     the polynomial p(x), a cyclo c is constructed whose index is a and which
@@ -841,7 +840,7 @@
 NAME:   
 	          field_check_cyclo
 SYNOPSIS: 
-	        INT field_check_cyclo(a) OP a;
+	        INT field_check_cyclo(OP a)
 DESCRIPTION: 
 	     Check if element of field element , the CYCLOTOMIC
 	object a, is essentially an INTEGER,
@@ -852,7 +851,7 @@
 NAME:   
                   field_check_sqrad
 SYNOPSIS: 
-                  INT field_check_sqrad(a) OP a;
+                  INT field_check_sqrad(OP a)
 DESCRIPTION: 
 	     Check if element of field element, the SQ_RADICAL 
 	object a, is essentially an INTEGER,
@@ -863,14 +862,14 @@
 NAME:
 	make_scalar_cyclo
 SYNOPSIS:
-	INT make_scalar_cyclo(a,b) OP a,b;
+	INT make_scalar_cyclo(OP a,b)
 DESCRIPTION:
 	transfer a scalar object l into an CYCLOTOMIC object b.
 
 NAME:           
 	  make_index_coeff_power_cyclo
 SYNOPSIS:
-	         INT make_index_coeff_power_cyclo(a,b,c,d) OP a,b,c,d;
+	         INT make_index_coeff_power_cyclo(OP a,b,c,d)
 DESCRIPTION:
 	      The monomial b * x:c is treated as a cyclotomic number,
     where x is the basic primitive a-th root of unity.  A cyclo d is
@@ -881,7 +880,7 @@
 NAME:  
 	           scan_cyclo
 SYNOPSIS:
-	         INT scan_cyclo(a) OP a;
+	         INT scan_cyclo(OP a)
 DESCRIPTION:
 	      Input a cyclo directly from standard input.
 	Subroutine of the general routine scan.
@@ -892,21 +891,21 @@
 NAME:
 	add_scalar_cyclo
 SYNOPSIS:
-	INT add_scalar_cyclo(a,b,c) OP a,b,c;
+	INT add_scalar_cyclo(OP a,b,c)
 DESCRIPTION:
 	this is a subroutine of the general routine add
 
 NAME:
 	 mult_scalar_cyclo
 SYNOPSIS:
-	INT mult_scalar_cyclo(a,b,c) OP a, b, c;
+	INT mult_scalar_cyclo(OP a,b,c)
 DESCRIPTION:
         this is a subroutine of the general routine mult
 
 NAME:
 	add_cyclo_cyclo
 SYNOPSIS:
-	INT add_cyclo_cyclo(a,b,c) OP a,b,c; 
+	INT add_cyclo_cyclo(OP a,b,c)
 DESCRIPTION:
 	 c is completely tidied. 
 	this is a subroutine of the general routine add
@@ -914,7 +913,7 @@
 NAME:
 	mult_cyclo_cyclo
 SYNOPSIS:
-	INT mult_cyclo_cyclo(a,b,c) OP a,b,c;
+	INT mult_cyclo_cyclo(OP a,b,c)
 DESCRIPTION:
 	 c is completely tidied.
 	this is a subroutine of the general routine mult
@@ -922,14 +921,14 @@
 NAME:
 	add_cyclo
 SYNOPSIS:
-	INT add_cyclo(a,b,c) OP a,b,c;
+	INT add_cyclo(OP a,b,c)
 DESCRIPTION:
         this is a subroutine of the general routine add
 
 NAME:
 	add_apply_cyclo
 SYNOPSIS:
-	INT add_apply_cyclo(a,b) OP a,b;
+	INT add_apply_cyclo(OP a,b)
 DESCRIPTION:
     Adds a cyclo to an object of type INTEGER, LONGINT, BRUCH, SQ_RADICAL,
     CYCLOTOMIC or POLYNOM.
@@ -938,13 +937,13 @@
 NAME:
 	mult_cyclo
 SYNOPSIS:
-	INT mult_cyclo(a,b,c) OP a,b,c;
+	INT mult_cyclo(OP a,b,c)
 DESCRIPTION:
         this is a subroutine of the general routine mult
 NAME:
 	 mult_apply_cyclo
 SYNOPSIS:
-	INT mult_apply_cyclo(a,b) OP a,b;
+	INT mult_apply_cyclo(OP a,b)
 DESCRIPTION:
     Multiplies a cyclo with an object of type INTEGER, LONGINT, BRUCH,
     SQ_RADICAL, CYCLOTOMIC, POLYNOM, SCHUBERT, VECTOR or MATRIX.
@@ -953,13 +952,13 @@
 NAME:
 	addinvers_cyclo
 SYNOPSIS:
-	INT addinvers_cyclo(a,b) OP a,b;
+	INT addinvers_cyclo(OP a,b)
 DESCRIPTION:
 	this is a subroutine of the general routine addinvers
 NAME:
 	addinvers_apply_cyclo
 SYNOPSIS:
-	INT addinvers_apply_cyclo(a) OP a;
+	INT addinvers_apply_cyclo(OP a)
 DESCRIPTION:
         this is a subroutine of the general routine addinvers_apply
 
@@ -967,27 +966,27 @@
 NAME:
 	invers_cyclo
 SYNOPSIS:
-	INT invers_cyclo(a,b) OP a,b;
+	INT invers_cyclo(OP a,b)
 DESCRIPTION:
 	this is a subroutine of the general routine invers
 NAME:
 	nullp_cyclo
 SYNOPSIS:
-	INT nullp_cyclo(a) OP a;
+	INT nullp_cyclo(OP a)
 DESCRIPTION:
         this is a subroutine of the general routine nullp
 
 NAME:
 	comp_cyclo
 SYNOPSIS:
-	INT comp_cyclo(a) OP a;
-DESCRIPTION:         
+	INT comp_cyclo(OP a)
+DESCRIPTION:
 	Uses comp_list on the self fields.
 
 NAME:
 	             conj_cyclo
 SYNOPSIS:
-	         INT conj_cyclo(a,b,c) OP a,b,c;
+	         INT conj_cyclo(OP a,b,c)
 DESCRIPTION:
 	      If a represents the cyclotomic number p(x), where x is the
     basic primitive n-th root of unity, c is a cyclo representing the number
@@ -998,7 +997,7 @@
 NAME:  
 	           tex_cyclo
 SYNOPSIS:
-	         INT tex_cyclo(a) OP a;
+	         INT tex_cyclo(OP a)
 DESCRIPTION:
 	      Outputs a cyclo in a form suitable for TeX processing.
     Each term of the self is expressed in the form:
@@ -1021,7 +1020,7 @@
 NAME:  
 	           print_cyclo_data
 SYNOPSIS:
-	         INT print_cyclo_data(ptr) CYCLO_DATA *ptr;
+	         INT print_cyclo_data(CYCLO_DATA *ptr)
 DESCRIPTION:
 	      Prints at stdout the cyclotomic data pointed to by ptr,
     prefacing the entries by Index, Degree, Polynomial and Automorphism
--- a/nc.doc
+++ b/nc.doc
@@ -134,7 +134,7 @@
 NAME:		
 	m_gl_chartafel
 SYNOPSIS:	
-	INT m_gl_chartafel(gl,t)
+	INT m_gl_chartafel(OP gl,t)
 DESCRIPTION:	
 	you enter an object gl, which you got using a routine
 	to construct a group label (see above), the output is the
@@ -265,7 +265,7 @@
 NAME:		
 	m_gl_nc
 SYNOPSIS:	
-	INT m_gl_nc(OP gl, il, nc)
+	INT m_gl_nc(OP gl,il,nc)
 DESCRIPTION:	
 	you input the group label gl to specify the group, then
 	an object il which may be an INTEGER object, to say that you want
--- a/nu.doc
+++ b/nu.doc
@@ -303,7 +303,7 @@
         fixpoint. In the case of MATRIX or KRANZTYPUS object there
 	will be a further column and a further row at the ends, with
         empty objects. In the case of REIHE it computes the next
-	coefficent.
+	coefficient.
 RETURN:
 	       OK or ERROR
 BUGS:  
@@ -419,7 +419,7 @@
 NAME:  
 	         mod  
 SYNOPSIS:
-	       INT mod(OP a,b,c) 
+	       INT mod(OP a,b,c)
 DESCRIPTION:
 	 Computes a mod b, where a,b could be out of INTEGER or
 	LONGINT. The result is always positive,
@@ -453,7 +453,7 @@
 NAME:   
         mult
 SYNOPSIS:  
-	     INT mult(OP a,b,c) 
+	     INT mult(OP a,b,c)
 DESCRIPTION:
 	    it multiplies the two objects a and b and the result will
 	be in c. First there is a check whether a,b,c not NULL then 
--- a/object.doc
+++ b/object.doc
@@ -80,32 +80,34 @@
          s_o_k
 SYNOPSIS:    
 	  OBJECTKIND s_o_k(OP object)
+MACRO:
+    S_O_K
 DESCRIPTION:
    As OP is a pointer, there is first a check,
 	whether it is the NULL pointer, then it
-	returns the kind of the object
+	returns the kind of the object.
+  The macro S_O_K does the smae but without a check.
 RETURN: 
        The returnvalue is the kind, or in the case of
         an error the value (OBJECTKIND)ERROR. You have to cast
 	because in the normal case ERROR is of type INT.
-MACRO:
-         There is a macro S_O_K without a check
 
 COMMENT:
 To change the kind of an object, you have the routine c_o_k()
 
 NAME:  
 	        c_o_k
-SYNOPSIS:      
-	INT c_o_k(OP object; OBJECTKIND kind)
-DESCRIPTION: 
+SYNOPSIS:
+	INT c_o_k(OP object, OBJECTKIND kind)
+MACRO:
+  C_O_K
+DESCRIPTION:
 	  As OP is a pointer, there is first a check,
 	whether it is the NULL pointer, then the
-	kind of the object is changed to kind
+	kind of the object is changed to kind.
+	The macro C_O_K does the same but without a check.
 RETURN:
 	        The returnvalue is OK, or ERROR if an error occured
-MACRO: 
-	        There is a macro C_O_K without a check
 
 COMMENT:
 The second part of an object, are the datas themself. The type is 
@@ -115,21 +117,19 @@
 	s_o_s
 SYNOPSIS:
 	OBJECTSELF s_o_s(OP a)
+MACRO:
+	S_O_S
 DESCRIPTION:
 	acess the self part of an object. This is a union 
 	of different datatypes according to the kind part
 	of the object
-MACRO:
-	S_O_S
 
 NAME:
 	c_o_s
 SYNOPSIS:
 	INT c_o_s(OP a, OBJECTSELF self)
-DESCRIPTION:
-	changes the self part of an object a. 
 MACRO:
 	C_O_S
-
-
+DESCRIPTION:
+	changes the self part of an object a.
 
--- a/part.doc
+++ b/part.doc
@@ -92,9 +92,9 @@
 	constructor m_ks_pa().
 
 NAME:             
-	b_ks_pa 
-SYNOPSIS:         
-	INT b_ks_pa(OBJECTKIND kind;OP self, result)
+	b_ks_pa
+SYNOPSIS:
+	INT b_ks_pa(OBJECTKIND kind; OP self, result)
 DESCRIPTION:
 	      this routine build out of the two components kind
 	and self of a PARTITION object a new PARTITION object result.
@@ -111,7 +111,7 @@
 NAME:             
                   m_ks_pa    
 SYNOPSIS:         
-                  INT m_ks_pa(OBJECTKIND kind;OP self, result)
+                  INT m_ks_pa(OBJECTKIND kind; OP self, result)
 DESCRIPTION:
 	      this routines build out of the two components kind
 	and self of a PARTITION object a new PARTITION object result.
@@ -134,30 +134,32 @@
 	s_pa_s       
 SYNOPSIS:         
 	OP s_pa_s(OP partition)
+MACRO:
+  S_PA_S
 DESCRIPTION:      
 	selects the self-part, which should  be an 
 	VECTOR object
 	(up to now), there is first a check whether partition is really
 	a PARTITION object, else we would get an error.
+	The macro S_PA_S does the same but without a check.
 RETURN:
 	           the self part, or NULL if an error occured
-MACRO: 
-	           there is also a macro S_PA_S, without a check
 
 NAME:      
 	       s_pa_k 
 SYNOPSIS:        
 	 OBJECTKIND s_pa_k(OP partition)
-DESCRIPTION: 
+MACRO:
+	 S_PA_K
+DESCRIPTION:
      selects the kind-part, which should  be 
 	VECTOR or EXPONENT
 	(up to now), there is first a check whether partition is really
 	a PARTITION object, else we would get an error.
+	The macro S_PA_K does the same but without a check.
 RETURN:
 	           the kind part, or (OBJECTKIND)ERROR if an error 
 	occured
-MACRO: 
-	           there is also a macro S_PA_K, without a check
 
 COMMENT:
 	As we have seen, there always (up to now) VECTOR objects as self-parts
@@ -358,7 +360,7 @@
 NAME:
 	next_partition
 SYNOPSIS:
-	next_partition(OP partone, OP partnext)
+	INT next_partition(OP partone, OP partnext)
 DESCRIPTION:
 	using the algorithm of Nijnhuis/Wilf the next partition with
 	the same weight is computed. Better to use the general routine
@@ -399,6 +401,8 @@
 	last_part_EXPONENT
 SYNOPSIS:
 	INT last_part_EXPONENT(OP n, OP res)
+DESCRIPTION:
+	none
 
 COMMENT:
 which have the same parameters and produce the specified 
--- a/perm.doc
+++ b/perm.doc
@@ -42,13 +42,49 @@
 		m_ks_p
 		m_il_p
 
+NAME:
+	c_p_k
+	c_p_s
+	s_p_k
+	s_p_i
+	s_p_ii
+	s_p_l
+	s_p_li
+	s_p_s
+	b_ks_p
+	m_ks_p
+	m_il_p
+SYNOPSIS:
+	INT c_p_k()
+	INT c_p_s()
+	OBJECTKIND s_p_k()
+	OP s_p_i()
+	INT s_p_ii()
+	OP s_p_l()
+	INT s_p_li()
+	OP s_p_s()
+	INT b_ks_p()
+	INT m_ks_p()
+	INT m_il_p()
+MACRO:
+	C_P_K
+	C_P_S
+	S_P_K
+	S_P_I
+	S_P_II
+	S_P_L
+	S_P_LI
+	S_P_S
+DESCRIPTION:
+	see chart
+
 		CONSTRUCTOR, SELECTOR, MACROS
 		-----------------------------
 
 NAME: 	     
 	c_p_k
 SYNOPSIS:    
-	c_p_k(OP p, OBJECTKIND k)
+	INT c_p_k(OP p, OBJECTKIND k)
 DESCRIPTION: 
 	changes the value, which indicates the type of the
 	PERMUTATION object p. Up to now there are only two kinds,
@@ -109,7 +145,7 @@
 NAME:		
 	bruhat_comp_perm
 SYNOPSIS:	
-	INT  bruhat_comp_perm( OP a,b)
+	INT bruhat_comp_perm( OP a,b)
 DESCRIPTION:	
 	compares according to the Bruhat order. returns the
 	constant INT NONCOMPARABLE if the two PERMUTATION objects
@@ -219,8 +255,6 @@
 	Better to use the general routine mult(OP,OP,OP).
 
 NAME:	     
-
-NAME:	     
 	fprint_permutation
 SYNOPSIS:    
 	INT fprint_permutation(FILE *fp, OP a)
@@ -253,17 +287,15 @@
 DESCRIPTION: 
 	the lehmercode is a bijection between the permutations
       	and a vector of integers.  This routine computes the 
-	image of a PERMUATION object a under this bijection, the result 
+	image of a PERMUTATION object a under this bijection, the result
 	is a VECTOR object of the same length. Better to use the general
 	routine lehmercode(OP,OP).
 
 NAME:	     
 	makevectoroftranspositions
-NAME:	     
-	makevectoroftranspositions
 SYNOPSIS:    
 	INT makevectoroftranspositions(OP deg, res)
-DESRIPTION:  
+DESCRIPTION:
 	computes the VECTOR of all PERMUTATION objects of the entered
 	degree, which are transpositions.
 RETURN:	     
@@ -509,9 +541,9 @@
 NAME:
 	        t_ZYKEL_VECTOR 
 SYNOPSIS:
-	    INT t_ZYKEL_VECTOR(OP a,b) 
+	    INT t_ZYKEL_VECTOR(OP a,b)
 DESCRIPTION:
-	 a is a PERMUATION object of ZYKEL type
+	 a is a PERMUTATION object of ZYKEL type
       b becomes a PERMUTATION object of VECTOR type
       a and b may be equal. t_zperm_vperm is a synonym 
 
@@ -520,9 +552,9 @@
 NAME:
 	        t_zperm_vperm 
 SYNOPSIS:
-	    INT t_zperm_vperm(OP a,b) 
+	    INT t_zperm_vperm(OP a,b)
 DESCRIPTION:
-	 a is a PERMUATION object of ZYKEL type
+	 a is a PERMUTATION object of ZYKEL type
       b becomes a PERMUTATION object of VECTOR type
       a and b may be equal. t_ZYKEL_VECTOR is a synonym 
 
@@ -531,9 +563,9 @@
 NAME:
 	        t_VECTOR_ZYKEL 
 SYNOPSIS:
-	    INT t_VECTOR_ZYKEL(OP a,b) 
+	    INT t_VECTOR_ZYKEL(OP a,b)
 DESCRIPTION:
-	 a is a PERMUATION object of VECTOR type
+	 a is a PERMUTATION object of VECTOR type
       b becomes a PERMUTATION object of ZYKEL type
       a and b may be equal. t_vperm_zperm is a synonym 
 
@@ -542,9 +574,9 @@
 NAME:
 	        t_vperm_zperm 
 SYNOPSIS:
-	    INT t_vperm_zperm(OP a,b) 
+	    INT t_vperm_zperm(OP a,b)
 DESCRIPTION:
-	 a is a PERMUATION object of VECTOR type
+	 a is a PERMUTATION object of VECTOR type
       b becomes a PERMUTATION object of ZYKEL type
       a and b may be equal. t_VECTOR_ZYKEL is a synonym 
 
--- a/poly.doc
+++ b/poly.doc
@@ -37,7 +37,44 @@
 		b_s_po                             build_self_polynom
 		m_s_po                             make_self_polynom
 
-		EXAMPLE:
+NAME:
+	s_po_n
+	s_po_s
+	s_po_si
+	s_po_sii
+	s_po_sl
+	s_po_sli
+	s_po_k
+	s_po_ki
+	m_skn_po
+	b_skn_po
+	b_s_po
+	m_s_po
+SYNOPSIS:
+	OP s_po_n()
+	OP s_po_s()
+	OP s_po_si()
+	INT s_po_sii()
+	OP s_po_sl()
+	INT s_po_sli()
+	OP s_po_k()
+	INT s_po_ki()
+	INT m_skn_po()
+	INT b_skn_po()
+	INT b_s_po()
+	INT m_s_po()
+MACRO:
+	S_PO_N
+	S_PO_S
+	S_PO_SI
+	S_PO_SII
+	S_PO_SL
+	S_PO_SLI
+	S_PO_K
+	S_PO_KI
+DESCRIPTION:
+	see chart
+EXAMPLE:
 			main()
 			{
 			OP a,b,c;
@@ -71,7 +108,7 @@
 			}
 
 		The routines b_s_po and m_s_po help to generate a POLYNOM object, where
-		the self-part is given by the self parameter and the coefficent is given
+		the self-part is given by the self parameter and the coefficient is given
 		by the INTEGER object 1. The next part is NULL, which means we have
 		a POLYNOM object which consist only of one MONOM object.
 
@@ -103,7 +140,7 @@
 	produces an error, because the self part is not yet initialised.
 
 NAME:		
-	symmetrip_i
+	symmetricp_i
 SYNOPSIS:	
 	INT symmetricp_i(OP a; INT i)
 DESCRIPTION:	
@@ -198,15 +235,15 @@
 NAME:        
 	gauss_polynom
 SYNOPSIS:    
-	INT gauss_polynom(a,b,c)
+	INT gauss_polynom(OP a,b,c)
 DESCRIPTION:  
 	computing Gauss polynomial using recursion.
 
 NAME:        
 	gauss_schubert_polynom
-SYNOPSIS:    
-	INT gauss_polynom(a,b,c)
-DESCRIPTION:  
+SYNOPSIS:
+	INT gauss_schubert_polynom(OP a,b,c)
+DESCRIPTION:
 	computing Gauss polynomial as a specialisation 
 	of  Schubert polynomials (slower)
 
@@ -229,7 +266,7 @@
 NAME:        
 	lagrange_polynom
 SYNOPSIS:    
-	INT lagrange_polynom(OP a,b,c) 
+	INT lagrange_polynom(OP a,b,c)
 DESCRIPTION: 
 	This routine computes the Lagrange polynomial which 
       interpolates at the points in the VECTOR object a (which
@@ -317,7 +354,7 @@
 	INT m_scalar_polynom(OP a,b)
 DESCRIPTION: 
 	a is a scalar object, b becomes the result, again
-     a POLYNOM object. a becomes the coefficent of the POLYNOM object
+     a POLYNOM object. a becomes the coefficient of the POLYNOM object
      with one single monomial, namely the monomial [0], i.e. a single variable,
      whose exponent is zero.
 
@@ -364,7 +401,7 @@
 NAME:	     
 	numberofvariables
 SYNOPSIS:    
-	INT  numberofvariables(OP pol,res)
+	INT numberofvariables(OP pol,res)
 DESCRIPTION: 
 	computes the number of variables of the POLYNOM object pol.
 	The result is a positiv INTEGER object res. If the self-part of
@@ -416,8 +453,8 @@
 DESCRIPTION:	
 	you enter a POLYNOM object a, and an VECTOR object b, which must
 	have INTEGER entries, this integer vector is treated as an exponent vector,
-	the output is the coefficent which is the object c. This is a copy
-	of the coefficent in the polynom. 
+	the output is the coefficient which is the object c. This is a copy
+	of the coefficient in the polynom.
 
 COMMENT:
 			t_POLYNOM_SCHUBERT		see sb.doc
--- a/pr.doc
+++ b/pr.doc
@@ -5,9 +5,9 @@
 
 NAME:       
 	prsym 
-SYNONPSIS:  
-	INT prsym(OP lambda, OP T_v) 
-DESCRIPTION: 
+SYNOPSIS:
+	INT prsym(OP lambda, OP T_v)
+DESCRIPTION:
 	computes the matrix representation of the involutions
 	t_k which generate (together with -Id) the covering group T'_n
 	(in Schur's notation) of S_n and stores them as MATRIX objects 
--- a/rh.doc
+++ b/rh.doc
@@ -15,21 +15,21 @@
 	INT max_degree_reihe(OP a,b)
 DESCRIPTION:	
 	you enter a REIHE object a, and the output is the
-	degree of maximal coefficent, which is computed up to now.
+	degree of maximal coefficient, which is computed up to now.
 
 
 NAME:		
 	m_function_reihe
 SYNOPSIS:	
-	INT m_function_reihe(INT (*f)(); OP a);
+	INT m_function_reihe(INT (*f)(); OP a)
 DESCRIPTION:	
-	you enter a function f, which computes an coefficent
+	you enter a function f, which computes an coefficient
 	of the series, which is specified by an paramter of the function.
 	The result is a object a of type REIHE. The syntax of the function
 	f is described now in detail:
 		INT f(OP a,b) 
 	a is a INTEGER object which gives the common degree of the 
-	coefficents, which should be computed. The result b must be of
+	coefficients, which should be computed. The result b must be of
 	the type POLYNOM object. This POLYNOM object is homogenous of
 	the entered degree. 
 EXAMPLE:	
@@ -80,13 +80,13 @@
 	INT random_reihe(OP a)
 DESCRIPTION:	
 	builds a one-parameter series with random INTEGER
-	coefficents.
+	coefficients.
 
 
 NAME:		
 	scan_reihe
 SYNOPSIS:	
-	scan_reihe(OP a)
+	INT scan_reihe(OP a)
 DESCRIPTION:	
 	this is the function which is called by scan if you
 	enter the type REIHE. Up to now you can only select between
@@ -100,8 +100,8 @@
 	you enter a REIHE object a, and an VECTOR object b, which must
 	have INTEGER entries, this integer vector is treated as an 
 	exponent vector,
-	the output is the coefficent which is the object c. This is a copy
-	of the coefficent in the series. 
+	the output is the coefficient which is the object c. This is a copy
+	of the coefficient in the series.
 
 NAME:		
 	select_degree_reihe
--- a/sab.doc
+++ b/sab.doc
@@ -34,10 +34,9 @@
 
 NAME:
 	bdg
-SYNOPSIS:     
-	INT bdg(part,perm,D);  OP part,perm,D;
-
-DESCRIPTION:  
+SYNOPSIS:
+	INT bdg(OP part,perm,D)
+DESCRIPTION:
 	Calculates the irreduzible matrix representation 
                         D^part(perm), whose entries are of integral numbers.
           reference:    H. Boerner:
@@ -47,10 +46,9 @@
 NAME:
 	sdg
 
-SYNOPSIS:     
-	INT sdg(part,perm,D);  OP part,perm,D;
-
-DESCRIPTION:  
+SYNOPSIS:
+	INT sdg(OP part,perm,D)
+DESCRIPTION:
 	Calculates the irreduzible matrix representation 
                         D^part(perm), which consists of rational numbers.
           reference:    G. James/ A. Kerber:  
@@ -60,10 +58,9 @@
 
 NAME:
 	odg
-SYNOPSIS:     
-	INT odg(part,perm,D);  OP part,perm,D;
-
-DESCRIPTION:  
+SYNOPSIS:
+	INT odg(OP part,perm,D)
+DESCRIPTION:
 	Calculates the irreduzible matrix representation 
 	D^part(perm), which consists of real numbers.
 
@@ -88,12 +85,11 @@
         a)  Decomposition of the n-fold tensorproduct of the identical
                 representation of Glm(C) onto itself.
 
-NAME:	
+NAME:
 	glmndg
-SYNOPSIS:    
-	INT glmndg(m,n,M,VAR); OP m,n,M; INT VAR;
-
-DESCRIPTION: 
+SYNOPSIS:
+	INT glmndg(OP m,n,M; INT VAR)
+DESCRIPTION:
 	If VAR is equal to 0L the orthogonal representation 
                          is used for the decomposition, otherwise, if VAR 
                          equals 1L, the natural representation is considered.
@@ -110,8 +106,7 @@
 NAME:
 	glpdg
 SYNOPSIS:     
-	INT glpdg(m,part,M); OP m,part,M;
-
+	INT glpdg(OP m,part,M)
 DESCRIPTION:  
 	part has to be an PARTITION object with not more
                           than m parts.
@@ -139,8 +134,7 @@
 NAME:
 	glm_homtest
 SYNOPSIS:     
-	INT glm_homtest(m,M); OP m,M;
-
+	INT glm_homtest(OP m,M)
 DESCRIPTION:  
 	The relation D(A)*D(B) = D(A*B) is verified 
                         with two random integer matrices. 
@@ -166,8 +160,8 @@
                  --------------------------------------------------------------      
                  nr of generators of  G             |       orderS 
                  (INTEGER )                         |
-                                                    
-                 set S of generators of G           |       S 
+
+                 set S of generators of G           |       S
                  (VECTOR of PERMUTATIONS of         |
                  length n, where G <= Sn)           |
 
--- a/sb.doc
+++ b/sb.doc
@@ -25,6 +25,36 @@
 s_sch_k          S_SCH_K          select_schubert_koeff
 s_sch_ki         S_SCH_KI         select_schubert_koeff_asINT
 
+NAME:
+	s_sch_s
+	s_sch_si
+	s_sch_sii
+	s_sch_sl
+	s_sch_sli
+	s_sch_n
+	s_sch_k
+	s_sch_ki
+SYNOPSIS:
+	OP s_sch_s()
+	OP s_sch_si()
+	INT s_sch_sii()
+	OP s_sch_sl()
+	INT s_sch_sli()
+	OP s_sch_n()
+	OP s_sch_k()
+	INT s_sch_ki()
+MACRO:
+	S_SCH_S
+	S_SCH_SI
+	S_SCH_SII
+	S_SCH_SL
+	S_SCH_SLI
+	S_SCH_N
+	S_SCH_K
+	S_SCH_KI
+DESCRIPTION:
+	see chart
+
 
 NAME:		
 	m_perm_sch
@@ -33,7 +63,7 @@
 DESCRIPTION:	
 	build out of a PERMUTATION object perm,
 	a SCHUBERT object res, which is labeled by a copy
-	of the permutation and which has coefficent 1.
+	of the permutation and which has coefficient 1.
 	Compare this with the functions m_pa_s, which 
 	does the same for SCHUR objects.
 
@@ -97,7 +127,7 @@
 NAME:  
 	        m_perm_2schubert_monom_summe
 SYNOPSIS:
-	      INT m_perm_schubert_monom_summe(OP a,b)
+	      INT m_perm_2schubert_monom_summe(OP a,b)
 DESCRIPTION:
 	   this routine computes the double schubert monomial
 	coreesponding to the 
@@ -180,8 +210,8 @@
 
 NAME:
 		exchange_alphabets
-SYNOPSIS:	
-	INT exchange_alphabets(OP a,b) 
+SYNOPSIS:
+	INT exchange_alphabets(OP a,b)
 DESCRIPTION:
 		this routine exchanges the two sets of variables in a 
 	POLYNOM object a, which should be the result of a earlier call
@@ -189,7 +219,7 @@
 
 NAME:  
 	        test_schubert
-SYNOPSIS: 
+SYNOPSIS:
 	     INT test_schubert()
 DESCRIPTION:
 	   tests the installation
@@ -197,7 +227,7 @@
 NAME:
 			tex_2schubert_monom_summe
 SYNOPSIS:
-		INT   tex_2schubert_monom_summe(OP a)
+		INT tex_2schubert_monom_summe(OP a)
 DESCRIPTION:
 		this is to provide a  TeX output of the POLYNOM
 	object which was described in m_perm_2schubert_monom_summe.
--- a/sc.doc
+++ b/sc.doc
@@ -23,7 +23,38 @@
 s_sc_pli        S_SC_PLI           select_symchar_partition_length_as_INT
 s_sc_pi         S_SC_PI            select_symchar_partition_ith_entry
 
-
+NAME:
+	s_sc_d
+	s_sc_di
+	s_sc_w
+	s_sc_wli
+	s_sc_wi
+	s_sc_wii
+	s_sc_p
+	s_sc_pli
+	s_sc_pi
+SYNOPSIS:
+	OP s_sc_d(OP a)
+	INT s_sc_di(OP a)
+	OP s_sc_w(OP a)
+	INT s_sc_wli(OP a)
+	OP s_sc_wi(OP a, INT i)
+	INT s_sc_wii(OP a, INT i)
+	OP s_sc_p(OP a)
+	INT s_sc_pli(OP a)
+	OP s_sc_pi(OP a, INT i)
+MACRO:
+	S_SC_D
+	S_SC_DI
+	S_SC_W
+	S_SC_WLI
+	S_SC_WI
+	S_SC_WII
+	S_SC_P
+	S_SC_PLI
+	S_SC_PI
+DESCRIPTION:
+	see chart
 
 NAME:		
 	m_d_sc
@@ -84,7 +115,7 @@
 NAME:       
 	chartafel
 SYNOPSIS:   
-	INT chartafel(OP degree,  res)
+	INT chartafel(OP degree, res)
 DESCRIPTION: 	
 	you enter the degree of the symmetric group, as INTEGER 
 	object and the result is a MATRIX object: the charactertable 
@@ -268,7 +299,7 @@
 	INT t_SCHUR_SYMCHAR(OP sp, res)
 DESCRIPTION:	
 	the input is a SCHUR object sp, this is a sum of 
-	partitions with coefficent, this is interpreted as a decomposition
+	partitions with coefficient, this is interpreted as a decomposition
 	of a charcter into irreducible ones. This sum of irreducible
 	characters is computed, and will be the output, the SYMCHAR 
 	object res. If the partitions are of different weight, you
--- a/schur.doc
+++ b/schur.doc
@@ -11,7 +11,7 @@
 	If we want to build a SCHUR object, we need three parts
 	the PARTITION object, called self, the next part, which is the
 	next entry in the list, which is NULL at the end, or a 
-	SCHUR object, with a bigger PARTITION, and the coefficent,
+	SCHUR object, with a bigger PARTITION, and the coefficient,
 	which is of arbitray type.
 
 	To access and change the parts of a SCHUR object we have
@@ -41,6 +41,33 @@
 	and the routine make_.., which differ in the handling of
 	the inputs, make does a copy and build does no copy.
 
+NAME:
+	s_s_s
+	s_s_n
+	s_s_k
+	s_s_si
+	s_s_sl
+	s_s_sii
+	s_s_sli
+SYNOPSIS:
+	OP s_s_s(OP a)
+	OP s_s_n(OP a)
+	OP s_s_k(OP a)
+	OP s_s_si(OP a, INT i)
+	OP s_s_sl(OP a)
+	INT s_s_sii(OP a, INT i)
+	INT s_s_sli(OP a)
+MACRO:
+	S_S_S
+	S_S_N
+	S_S_K
+	S_S_SI
+	S_S_SL
+	S_S_SII
+	S_S_SLI
+DESCRIPTION:
+	see routine chart above
+
 NAME:      
 	b_skn_s
 SYNOPSIS:  
@@ -517,7 +544,7 @@
 NAME:      	
 	hall_littlewood
 SYNOPSIS:  	
-	INT  hall_littlewood(OP part, OP res)
+	INT hall_littlewood(OP part, OP res)
 DESCRIPTION: 
 	computes the so called Hall Littlewood Polynomials, i.e.
       a SCHUR object, whose coefficient are polynomials in one
@@ -528,7 +555,7 @@
 NAME:
 	compute_zonal_with_alphabet
 SYNOPSIS:
-	INT compute_zonal_with_alphabet(part,l,res) OP part,l,res;
+	INT compute_zonal_with_alphabet(OP part,l,res)
 DESCRIPTION:
 	computes the zonal polynomial, a POLYNOM object, labeled by the
 	PARTITION object part, for the alphabet in l variables.
--- a/ta.doc
+++ b/ta.doc
@@ -52,6 +52,74 @@
 b_us_t                        build_umriss_self_tableaux
 m_us_t                        make_umriss_self_tableaux
 
+NAME:
+	s_t_s
+	s_t_ij
+	s_t_iji
+	s_t_l
+	s_t_li
+	s_t_h
+	s_t_hi
+	s_t_u
+	s_t_ui
+	s_t_uii
+	s_t_ul
+	s_t_uli
+	s_t_ug
+	s_t_ugii
+	s_t_ugli
+	s_t_uk
+	s_t_ukii
+	s_t_ukli
+	b_us_t
+	m_us_t
+SYNOPSIS:
+	OP s_t_s(OP a)
+	OP s_t_ij(OP a; INT i,j)
+	INT s_t_iji(OP a; INT i,j)
+	OP s_t_l(OP a)
+	INT s_t_li(OP a)
+	OP s_t_h(OP a)
+	INT s_t_hi(OP a)
+	OP s_t_u(OP a)
+	OP s_t_ui(OP a, INT i)
+	INT s_t_uii(OP a, INT i)
+	OP s_t_ul(OP a)
+	INT s_t_uli(OP a)
+	OP s_t_ug(OP a)
+	INT s_t_ugii(OP a, INT i)
+	INT s_t_ugli(OP a)
+	OP s_t_uk(OP a)
+	INT s_t_ukii(OP a, INT i)
+	INT s_t_ukli(OP a)
+	INT b_us_t(OP umriss,self,res)
+	INT m_us_t(OP umriss,self,res)
+MACRO:
+	S_T_S
+	S_T_IJ
+	S_T_IJI
+	S_T_L
+	S_T_LI
+	S_T_H
+	S_T_HI
+	S_T_U
+	S_T_UI
+	S_T_UII
+	S_T_UL
+	S_T_ULI
+	S_T_UG
+	S_T_UGI
+	S_T_UGII
+	S_T_UGL
+	S_T_UGLI
+	S_T_UK
+	S_T_UKI
+	S_T_UKII
+	S_T_UKL
+	S_T_UKLI
+DESCRIPTION:
+	see routine chart above
+
 
 NAME:		
 	 b_matrix_tableaux
@@ -84,16 +152,16 @@
           wordoftableaux
 SYNOPSIS:
         INT wordoftableaux(OP a,b)
-
 NAME:
             rowwordoftableaux
 SYNOPSIS:
-        INT rowwordoftableaux(OP a,b) 
-
+        INT rowwordoftableaux(OP a,b)
 NAME:
             columnwordoftableaux
 SYNOPSIS:
         INT columnwordoftableaux(OP a,b)
+DESCRIPTION:
+	none
 
 COMMENT:
 To access the rows and columns of the tableaux, we have routines
@@ -187,9 +255,9 @@
 
 NAME:          
   inhalt_tableaux
-SYNOPOSIS:
+SYNOPSIS:
        INT inhalt_tableaux(OP a,b)
-DESCRITPION:
+DESCRIPTION:
 	A interessting routine is to compute the content of a 
 	tableau, i.e. the number of entries of each type, it is an integer
 	vector, where the first entry is the number of 1's in the tableau
@@ -210,7 +278,7 @@
 NAME:		
 	select_row
 SYNOPSIS:
-		select_row(OP a; INT i; OP b)
+	INT select_row(OP a; INT i; OP b)
 DESCRIPTION:
 	    this routine is more or less the same as for MATRIX objects,
 	you transform the i-th row into VECTOR object, which contains the
@@ -220,7 +288,7 @@
 NAME:		
 		select_column
 SYNOPSIS:
-		select_column(OP a; INT i; OP b)
+		INT select_column(OP a; INT i; OP b)
 DESCRIPTION:
 	    this routine is more or less the same as for MATRIX objects,
 	you transform the i-th column into VECTOR object, which contains the
@@ -244,8 +312,7 @@
 NAME:     
 	       inverse_nilplactic_jeudetaquin_tableaux
 SYNOPSIS:
-	        INT inverse_nilplactic_jeudetaquin_tableaux
-                     (OP ta; INT i,j; OP erg)
+	INT inverse_nilplactic_jeudetaquin_tableaux(OP ta; INT i,j; OP erg)
 DESCRIPTION:
 	same as inverse_jeudetaquin_tableaux put using the
 	nilplactic relations instead of the  plactic  relations
@@ -261,9 +328,9 @@
 
 NAME:
 			  operate_perm_tableaux
-SYNOPSIS:	
+SYNOPSIS:
 	  INT operate_perm_tableaux(OP a,b,c)
-DESCRIPTON:
+DESCRIPTION:
 		  permutes the entries (INTEGER) of a TABLEAUX object b
 	according to PERMUTATION object a. The result is a TABLEAUX
 	object c.
--- a/vector.doc
+++ b/vector.doc
@@ -34,18 +34,18 @@
 	m_il_v
 SYNOPSIS:    
 	 INT m_il_v(INT length; OP vectorobject)
+MACRO:
+	 M_IL_V
 DESCRIPTION:  
 	builds an vector of the given length. First there is
 	a check whether vectorobject is a empty object, if this
         is not the case it is freed.
 	Moreover, there is the allocation of the given number of 
         objects, which are set to empty objects.
+	The macro M_IL_V does the same but without any checks.
 RETURN:
 		      the returnvalue is OK, ERROR if some error occured, e.g.
 	not enough memory for the objects.
-MACRO: 
-	       there is a macro M_IL_V, which is the same without any
-	checks.
 
 
 COMMENT:
@@ -181,23 +181,24 @@
 
 NAME:         
 	s_v_l           select_vectorobject_length
-              s_v_li          select_vectorobject_lengthinteger
+  s_v_li          select_vectorobject_lengthinteger
 SYNOPSIS:
 	     OP s_v_l(OP vectorobject)
-              INT s_v_li(OP vectorobject)
+       INT s_v_li(OP vectorobject)
+MACRO:
+	S_V_L
+	S_V_LI
 DESCRIPTION:
 	  selects the length of an VECTOR object. There is first a 
 	check whether it is really an VECTOR object. There is also a 
 	check whether the length is a not negative number.
+	The macro versions do the same but without checks.
 RETURN:
 		      s_v_l gives the length part of the VECTOR object, this is
 	an INTEGER object, it is not a copy of the length part.
 	s_v_li gives the INTvalue of the length part. It is equivalent
 	to s_i_i(s_v_l()). If an error occured s_v_l returns NULL
 	and s_v_li() returns ERROR.
-MACRO: 
-	       there are macro versions which do no checks, they are called
-	S_V_L and S_V_LI
 
 COMMENT:
 To access the parts of the VECTOR object, there is the routine s_v_i(),
@@ -208,6 +209,8 @@
          s_v_i
 SYNOPSIS: 
     OP s_v_i(OP vectorobject; INT index)
+MACRO:
+	S_V_I
 DESCRIPTION:
   selects the ith entry of an VECTOR object. There is first a 
 	check whether it is really an VECTOR object. Then there is a check
@@ -215,19 +218,17 @@
 	As the VECTOR object is indexed by INT-numbers there is a 
 	(theoretical) limit on the size of a VECTOR object, namely
 	there a maximal 2^31 elements.
-RETURN:	      
+	The macro version does the same but without checks.
+RETURN:
 	s_v_i gives the ith  entry of the VECTOR object. In the case
 	of an error it returns NULL. 
-MACRO: 
-       there is a macro version which does no checks, it 
-	is called
-	S_V_I 
-
 
 NAME:
-         s_v_ii
+    s_v_ii
 SYNOPSIS: 
     INT s_v_ii(OP vectorobject; INT index)
+MACRO:
+	S_V_II
 DESCRIPTION:
   selects the INT value of the
 	ith entry of an VECTOR object. There is first a 
@@ -237,12 +238,10 @@
 	As the VECTOR object is indexed by INT-numbers there is a 
 	(theoretical) limit on the size of a VECTOR object, namely
 	there a maximal 2^31 elements.
+	The macro version does the same but without checks.
 RETURN:	      
 	s_v_ii gives the INT value of the
 	ith  entry of the VECTOR object. 
-MACRO: 
-       there is a macro version which does no checks, it is called
-	S_V_II
 
 
 NAME:
@@ -297,21 +296,14 @@
               b_l_nv 
 SYNOPSIS:     
               INT b_l_nv(OP l, OP v)
-DESCRIPTION:  
+DESCRIPTION:
 	like the routine  b_l_v  but the elements
         in the VECTOR object v are INTEGER objects with value 0.
 
-
-
-
-
-
-
-
-NAME:		
+NAME:
 	comp_numeric_vector
 SYNOPSIS:	
-	INT comp_numeric_vector(OP a,b);
+	INT comp_numeric_vector(OP a,b)
 DESCRIPTION:	
 	a special routine for the comparision of two VECTOR
 	objects with INTEGER entries. If the length of the VECTOR
@@ -571,6 +563,9 @@
 			find_vector
 SYNOPSIS:
 		OP find_vector(OP a,b)
+DESCRIPTION:
+	none
+RETURN:
 	returns NULL if there is no object in the VECTOR object b,
 	which is equal to the object a. If such a object exists,
 	the result is the object in the vector, not a copy of
@@ -580,6 +575,9 @@
 			index_vector
 SYNOPSIS:
 		INT index_vector(OP a,b)
+DESCRIPTION:
+	none
+RETURN:
 	returns -1L if there is no object in the VECTOR object b,
 	which is equal to the object a. If such a object exists,
 	the result is the index in the vector. So the result is
--- /dev/null
+++ b/misc.doc
@@ -0,0 +1,96 @@
+COMMENT:
+MISCellaneous-Functions
+-----------------------
+
+NAME:
+	complete_complete_plet
+SYNOPSIS:
+	INT complete_complete_plet(OP a, OP b, OP c)
+DESCRIPTION:
+	Computes the plethysm of two complete symmetric functions labeled
+	by INTEGER objects. The first parameter is the outer one, so we
+	compute h_a(h_b). The result is a SCHUR object.
+EXAMPLE:
+	#include "def.h"
+	#include "macro.h"
+	ANFANG
+	scan(INTEGER,a);
+	scan(INTEGER,b);
+	complete_complete_plet(a,b,c);
+	println(c);
+	ENDE
+
+NAME:
+	complete_schur_plet
+SYNOPSIS:
+	INT complete_schur_plet(OP a, OP b, OP c)
+DESCRIPTION:
+	Computes the plethysm of a complete symmetric function labeled by
+	the INTEGER object a and the Schurfunction labeled by the INTEGER
+	or PARTITION object b. The result will be a SCHUR function c. The
+	complete function is the outer one, so we compute h_a(s_b)
+EXAMPLE
+	#include "def.h"
+	#include "macro.h"
+	ANFANG
+	scan(INTEGER,a);
+	scan(PARTITION,b);
+	complete_schur_plet(a,b,c);
+	println(c);
+	ENDE
+
+NAME:
+	elementary_schur_plet
+SYNOPSIS:
+	INT elementary_schur_plet(OP a, OP b, OP c)
+DESCRIPTION:
+	Computes the plethysm of a elementary symmetric function labeled by
+	the INTEGER object a and the Schurfunction labeled by the INTEGER
+	or PARTITION object b. The result will be a SCHUR function c. The
+	elementary function is the outer one, so we compute e_a(s_b).
+EXAMPLE:
+	#include "def.h"
+	#include "macro.h"
+	ANFANG
+	scan(INTEGER,a);
+	scan(PARTITION,b);
+	elementary_schur_plet(a,b,c);
+	println(c);
+	ENDE
+
+NAME:
+	power_schur_plet
+SYNOPSIS:
+	INT power_schur_plet(OP a, OP b, OP c)
+DESCRIPTION:
+	Computes the plethysm of a power symmetric function labeled by
+	the INTEGER object a and the Schurfunction labeled by the INTEGER
+	or PARTITION object b. The result will be a SCHUR function c. The
+	complete function is the outer one, so we compute p_a(s_b).
+EXAMPLE:
+	#include "def.h"
+	#include "macro.h"
+	ANFANG
+	scan(INTEGER,a);
+	scan(PARTITION,b);
+	power_schur_plet(a,b,c);
+	println(c);
+	ENDE
+
+NAME:
+	schur_schur_plet
+SYNOPSIS:
+	INT schur_schur_plet(OP a, OP b, OP c)
+DESCRIPTION:
+	Computes the plethysm of two Schurfunctions labeled by a PARTITION
+	object or by an INTEGER object. The first parameter is the outer one,
+	so we compute s_a(s_b). The result is a SCHUR object.
+EXAMPLE:
+	#include "def.h"
+	#include "macro.h"
+	ANFANG
+	scan(PARTITION,a);
+	scan(PARTITION,b);
+	schur_schur_plet(a,b,c);
+	println(c);
+	ENDE
--- a/bruch.doc
+++ b/bruch.doc
@@ -6,7 +6,82 @@
 	There a two parts, the nominator (called oben) and the denominator
 	(called unten).
 
+NAME:
+	s_b_o
+SYNOPSIS:
+	INT s_b_o()
+MACRO:
+	S_B_O
+DESCRIPTION:
+	see comment
 
+NAME:
+	s_b_u
+SYNOPSIS:
+	INT s_b_u()
+MACRO:
+	S_B_U
+DESCRIPTION:
+	see comment
+
+NAME:
+	s_b_oi
+SYNOPSIS:
+	INT s_b_oi()
+MACRO:
+	S_B_OI
+DESCRIPTION:
+	see comment
+
+NAME:
+	s_b_ui
+SYNOPSIS:
+	INT s_b_ui()
+MACRO:
+	S_B_UI
+DESCRIPTION:
+	see comment
+
+NAME:
+	c_b_o
+SYNOPSIS:
+	INT c_b_o()
+MACRO:
+	C_B_O
+DESCRIPTION:
+	see comment
+
+NAME:
+	c_b_u
+SYNOPSIS:
+	INT c_b_u()
+MACRO:
+	C_B_U
+DESCRIPTION:
+	see comment
+
+NAME:
+	b_ou_b
+SYNOPSIS:
+	INT b_ou_b()
+DESCRIPTION:
+	see comment
+
+NAME:
+	m_ou_b
+SYNOPSIS:
+	INT m_ou_b()
+DESCRIPTION:
+	see comment
+
+NAME:
+	m_ioiu_b
+SYNOPSIS:
+	INT m_ioiu_b()
+DESCRIPTION:
+	see comment
+
+COMMENT:
 	To select these parts, to change these parts or to build new 
 	BRUCH objects out of these parts there are the following routines 
 	or macros
--- a/matrix.doc
+++ b/matrix.doc
@@ -22,17 +22,70 @@
 	b_lhs_m                        build_length_height_self_matrix
 	b_lh_m                         build_length_height_matrix
 	m_lh_m                         make_length_height_matrix
-	m_ilih_m                       make_integerlength_integerlength_
-				       matrix
+	m_ilih_m                       make_integerlength_integerlength_matrix
 	b_lh_nm                        build_length_height_null_matrix
 	m_lh_nm                        make_length_height_null_matrix
-	m_ilih_nm                      make_integerlength_integerlength_
-				       null_matrix
+	m_ilih_nm                      make_integerlength_integerlength_null_matrix
 
 	the last three routines initialize the matrix with zero entries
 	The routine s_m_ij differs from S_M_IJ because in the macro
 	S_M_IJ there is no check on the indices.
 
+NAME:
+	s_m_s
+	s_m_h
+	s_m_hi
+	s_m_l
+	s_m_li
+	s_m_ij
+	s_m_iji
+	c_m_s
+	c_m_h
+	c_m_l
+	b_lhs_m
+	b_lh_m
+	m_lh_m
+	m_ilih_m
+	b_lh_nm
+	m_lh_nm
+	m_ilih_nm
+SYNOPSIS:
+	OP s_m_s()
+	OP s_m_h()
+	INT s_m_hash()
+	INT s_m_hi()
+	INT s_m_hi()
+	OP s_m_l()
+	INT s_m_li()
+	INT s_m_li()
+	OP s_m_ij()
+	INT s_m_iji()
+	INT s_m_iji()
+	INT c_m_s()
+	INT c_m_h()
+	INT c_m_hash()
+	INT c_m_l()
+	INT b_lhs_m()
+	INT b_lh_m()
+	INT m_lh_m()
+	INT m_ilih_m()
+	INT b_lh_nm()
+	INT m_lh_nm()
+	INT m_ilih_nm()
+MACRO:
+	S_M_S
+	S_M_H
+	S_M_HI
+	S_M_L
+	S_M_LI
+	S_M_IJ
+	S_M_IJI
+	C_M_S
+	C_M_H
+	C_M_L
+DESCRIPTION:
+	see chart
+
 	BASIC ROUTINES
 	--------------
 
--- a/monom.doc
+++ b/monom.doc
@@ -5,7 +5,7 @@
 MONOMobjects are special objects, which appear as entries of 
 LISTobjects, in the case when we want to build POLYNOMs,
 SCHURobjects or similiar things. It is a structure of two
-components, one component is the coefficent and the second one
+components, one component is the coefficient and the second one
 is an entry which labels one entry in the list, for example
 to build a POLYNOMobject, we have  as self part of the list
 a MONOMobject, whose self part is a VECTORobject of
@@ -28,6 +28,43 @@
 b_sk_mo
 m_sk_mo
 
+NAME:
+	c_mo_s
+	c_mo_k
+	s_mo_s
+	s_mo_si
+	s_mo_sii
+	s_mo_sl
+	s_mo_sli
+	s_mo_k
+	s_mo_ki
+	b_sk_mo
+	m_sk_mo
+SYNOPSIS:
+	INT c_mo_s()
+	INT c_mo_k()
+	OP s_mo_s()
+	OP s_mo_si()
+	INT s_mo_sii()
+	OP s_mo_sl()
+	INT s_mo_sli()
+	OP s_mo_k()
+	INT s_mo_ki()
+	INT b_sk_mo()
+	INT m_sk_mo()
+MACRO:
+	C_MO_S
+	C_MO_K
+	S_MO_S
+	S_MO_SI
+	S_MO_SII
+	S_MO_SL
+	S_MO_SLI
+	S_MO_K
+	S_MO_KI
+DESCRIPTION:
+	see chart
+
 NAME:        
 	b_sk_mo
 SYNOPSIS:    
--- a/skew.doc
+++ b/skew.doc
@@ -22,14 +22,46 @@
 s_spa_gli          S_SPA_GLI          select_skewpart_gross_length_asINT
 s_spa_kli          S_SPA_KLI          select_skewpart_klein_length_asINT
 
+NAME:
+	s_spa_g
+	s_spa_k
+	s_spa_gi
+	s_spa_ki
+	s_spa_gii
+	s_spa_kii
+	s_spa_gli
+	s_spa_kli
+SYNOPSIS:
+	OP s_spa_g(OP a)
+	OP s_spa_k(OP a)
+	OP s_spa_gi(OP a, INT i)
+	OP s_spa_ki(OP a, INT i)
+	INT s_spa_gii(OP a, INT i)
+	INT s_spa_kii(OP a, INT i)
+	INT s_spa_gli(OP a)
+	INT s_spa_kli(OP a)
+MACRO:
+	S_SPA_G
+	S_SPA_K
+	S_SPA_GI
+	S_SPA_KI
+	S_SPA_GII
+	S_SPA_KII
+	S_SPA_GL
+	S_SPA_KL
+	S_SPA_GLI
+	S_SPA_KLI
+DESCRIPTION:
+	see routine chart above
 
 
+COMMENT:
 To build a SKEWPARTITION-object
 
 
 
-NAME:        	
-            b_gk_spa
+NAME:
+    b_gk_spa
 SYNOPSIS:
 		INT b_gk_spa(OP gross,klein,result)
 DESCRIPTION:
@@ -41,7 +73,7 @@
 	copy of the input in the result.
 
 
-NAME:        	
+NAME:
 	m_gk_spa
 SYNOPSIS:
 		INT m_gk_spa(OP gross,klein,result)
--- a/intro.doc
+++ b/intro.doc
@@ -98,3 +98,19 @@
 as the last part we give some examples, a guide for the 
 installation and a list of all routines.
 
+NAME:
+	callocobject
+	callocobject_anfang
+	callocobject_ende
+	callocobject_fast
+	callocobject_magma
+	test_callocobject
+SYNOPSIS:
+	OP callocobject()
+	INT callocobject_anfang()
+	INT callocobject_ende()
+	OP callocobject_fast()
+	OP callocobject_magma()
+	INT test_callocobject()
+DESCRIPTION:
+	none
